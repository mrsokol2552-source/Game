Оба файла прочитал целиком (архплан и расширения). Ниже — «джуниор-пайплайны» дебага для каждого из предложенных в них вариантов/подсистем. Формат: что проверить, как воспроизвести, чем измерить, что логировать, где часто ошибаются.

---

# Тайминг/пауза/фикс-тик — 3 варианта

## A) Свой `SimulationLoop` (accumulator + fixed tick)
**Шаги дебага (джуниор):**
1) Включи визуальный индикатор тика: раз в тик увеличивай `tickIndex` и показывай в углу UI. Так поймёшь: тики не «пропускаются/скачут».  
2) Логи порядка вызовов: в начале каждого тика логируй `TickStart(t)`, затем `Infection/Economy/AI`, в конце — `EventBus.Flush()`. Смотри, что порядок стабилен.  
3) Пауза: проверь, что `Update()` выходится раньше накопления (`if (IsPaused) return;`) и что UI анимации используют `unscaledDeltaTime`.  
4) «Пошагово»: кнопка «Step» вызывает ровно один проход `while (acc>=tick)`. Сделай `Assert` на «не более одного шага при Step».  
5) Тест на дрожание тика: резко меняй FPS (включить VSync/выключить) — тиковая частота должна оставаться постоянной.  
6) Профилирование: `Window → Analysis → Profiler` (Ctrl+7) и треки `Scripts`/`UI`. Смотри консистентное время тика, нет ли всплесков по GC. citeturn0search12

**Частые баги:** неправильно сбрасывают `acc` в цикле `while`, не отделили сим-время от UI-времени, забыли вызывать `EventBus.Flush()` в конце тика.

## B) Глобальная пауза через `Time.timeScale = 0`
**Шаги дебага:**
1) Убедись, что всё, что должно жить на паузе (UI/анимации меню), переведено на `Unscaled Time`: `Animator.Update Mode = Unscaled Time`; таймеры — через `unscaledDeltaTime`/`WaitForSecondsRealtime`. citeturn0search7turn0search10turn0search18  
2) Проверь корутины: замени `WaitForSeconds` на `WaitForSecondsRealtime` в UI-логике.  
3) Визуальный тест: при `timeScale=0` счётчик «тиков симуляции» не меняется, счётчик «кадров UI» — идёт.  
4) Профайлер: фильтруй по категориям `Animation`/`UI`. Убедись, что игровой код «молчит», а UI продолжает обновляться. citeturn0search12

**Частые баги:** «замерзшие» анимации UI (Animator в Normal), таймеры на `deltaTime`, а не `unscaledDeltaTime`.

## C) DOTS/Entities: `FixedStepSimulationSystemGroup`
**Шаги дебага:**
1) Открой список систем и проверь, что «горячие» системы помечены `[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]` и действительно тикают фикс-шагом. citeturn0search2  
2) Убедись, что шаг соответствует ожиданию (по умолчанию ~1/60 сек, меняется в группе); проверь настройку и фактическую частоту в Profiler (раздел `Entities`). citeturn0search6turn0search21  
3) Структурные изменения (создание/удаление сущностей) — только через `EntityCommandBuffer` (ECB) и один playback в конце фазы. Проверяй, что нигде нет прямых `EntityManager.Add/Remove` из job’ов. citeturn1search6turn1search3  
4) Если что-то «тикает не там»: проверь порядок групп (`Initialization/Simulation/FixedStepSimulation/Presentation`) и атрибуты систем. citeturn0search13

**Частые баги:** смешивают фикс-шаг и «нормальные» системы, делают структурные изменения прямо из job’ов (без ECB), не понимают, почему фикс-шаг не равен `Time.fixedDeltaTime` проекта. citeturn0search17

---

# Данные/конфиги/сейвы (ScriptableObject → runtime + JSON)

**Проверки:**
1) **SO не мутируем в рантайме.** На старте делай runtime-копию (POCO) и работай только с ней. Добавь `Assert(!Application.isPlaying || !AssetDatabase.Contains(obj))` в редакторских проверках/в тестах.  
2) **JsonUtility ограничения.** Проверь, что в моделях для сейва нет `Dictionary<>`/полиморфных полей без `SerializeReference`; JsonUtility — «структурный» JSON. Если нужен `Dictionary` или явный полиморфизм — либо адаптер, либо сторонний JSON. citeturn0search19turn0search8  
3) Если используешь `SerializeReference` для полиморфизма — проверь в простом юнит-тесте, что `JsonUtility.ToJson/FromJson` корректно восстанавливает подтипы. citeturn0search15  
4) **Версия сейва.** В JSON добавь `SaveVersion`; при загрузке — миграция по свитчу.

**Addressables (память):**
— Зеркаль `Load` и `Release`. Дебаг: счётчики «загружено/выгружено», лог по каждому handle; профилировщик памяти до/после экрана. citeturn1search10

---

# Экономика (двойное ВВП)

**Проверки/тесты:**
1) Unit-тесты на инварианты кошельков: `TryReserve` не меняет баланс, `Commit` — уменьшает; суммы транзакций сходятся в 0 («деньги не исчезают/не появляются»).  
2) «Дымовые» интеграционные тесты: 100 тиков, хаотичные расходы гос-ИИ и игрока → итоговые балансы предсказуемы.  
3) Логируй причины отказов: `[Economy] ReserveFail: amount, balance, who`.  
4) Стресс: умножь частоту вызовов (×10), проверь, что нет дрожания приоритетов.

---

# Инфекция (SIR/SEIR + клеточный автомат)

**Проверки:**
1) Подтверди «физику»: SIR/SEIR корректно двигает «S→I→R», параметры адекватны. citeturn4search0  
2) Соседство ячеек: Moore/Neumann — выбери и зафиксируй. Визуально подсвети соседей выбранной клетки (gizmos). citeturn4search1  
3) Двойной буфер: на каждом тике читаем из `gridA`, пишем в `gridB`, потом своп — тест «значение не затирается в середине цикла».  
4) «Frontier-update»: собирай список активных клеток и обновляй только их; логируй размер фронта и время шага.  
5) UI-оверлей тепловой карты: помогает «глазом» ловить скачки/застои.

**Производительность:**
— Вынеси диффузию/агрегации в Jobs + Burst, держи поля в `NativeArray<float>`. Для дебага Burst: включай `Jobs → Burst → Native Debug Mode Compilation` временно, либо `Debug = true` у конкретного job. citeturn1search11

---

# ИИ: Utility AI + GOAP + Behavior Trees

**Проверки Utility:**
1) Печатай таблицу скорингов 0..1 по целям каждый N-тик (только в Debug-режиме).  
2) Визуальные «инфлюенс-карты»: отрисуй изолинии/heatmap — дебажить приоритеты становится просто. citeturn2search7turn2search3

**Проверки GOAP:**
1) Лог плана: `[GOAP] Plan: Gather→Research[Shield-I]→Build[Turret×3]`.  
2) Ограничь глубину/время планирования; тест на отсутствие «перепланирования» каждый кадр.  
3) Ресурсные предусловия: отдельные ассерт-тесты для Preconditions/Effects.  
4) Референс по GOAP (для понимания структуры и ошибок): Orkin/F.E.A.R. (PDF). citeturn2search2

**Проверки Behavior Tree:**
1) Лог активных веток (ID ноды) и статусов `Success/Fail/Running`.  
2) Для «микро» задач (патруль/ремонт) — ограничитель тактов; избегай принятия решений в BT (пусть BT исполняет, а Utility/GOAP выбирают цель). citeturn2search5

---

# События/команды/сейвы

**Проверки:**
1) `EventBus.Flush()` вызывается **после** сим-тиков; добавь «сигнальный» лог `[EventBus] Flushed (count=X)`.  
2) «Склейка» событий (coalesce): убедись, что пачка одинаковых событий приходит одной записью.  
3) Сейв после «тикового барьера»: тест, что состояние не полудет-применённое.  
4) В ECS — playback `EntityCommandBuffer` в конце группы, не в середине. citeturn1search6

---

# Производительность и масштабирование — 3 ступени

## 1) MonoBehaviour-база
— Ранние измерения: Profiler (CPU, GC), Frame Debugger (draw calls/батчи). Учись читать причину «разбиения батчей». citeturn0search12turn0search20turn0search24

## 2) Jobs + Burst
— Выноси «горячие» циклы (диффузия, influence-карты, массовые сканы). Для дебага job’ов: временно сними `[BurstCompile]`/включи Native Debug Mode; помни, что `Debug.Log` в Bursted-коде ограничен. citeturn1search2turn1search14turn1search22

## 3) DOTS/Entities
— Фикс-шаг через `FixedStepSimulationSystemGroup`; все структурные изменения через ECB; проверь автоматическое воспроизведение буферов и «когда в кадре это происходит». citeturn0search2turn1search19

---

# Pathfinding на сетке (A* → JPS → HPA*)

**A*) Базовый A***  
— Визуалки: отрисуй `open/closed` ноды (`OnDrawGizmos`), итоговый путь (`LineRenderer`). Это мгновенно находит ошибки эвристики/блоков. citeturn3search5turn3search20

**B*) Jump Point Search (ускоритель для равномерной сетки)**  
— Тесты: сравни длину пути с A* (должна совпадать), время — меньше. Проверь «принудительные соседи» и «jump» логами. Общее описание JPS. citeturn3search0turn3search3

**C*) HPA***  
— Дебаг кластера: визуализируй границы кластеров и «порталы». Проверяй кэш межпортальных расстояний и частичные инвалидации при стройке/карантине. Базовые источники по HPA*. citeturn3search1turn3search8

---

# UI/визуализация для дебага (быстрое чек-лист меню)

- **Overlay «Тики/скорости»**: текущая скорость (×0.5/×1/×2/×4), индекс тика.  
- **Heatmap’ы**: заражение, сила своих, сила врага (influence).  
- **Отрисовка планов ГОАП/BT**: активная цель/план/нода.  
- **«Глазки» профилировки**: кнопки «Открыть Profiler/Frame Debugger» прямо из dev-меню. citeturn0search12turn0search20

---

# Мини-тестпак (Unity Test Framework)

- **EditMode**: чистые модели (экономика, правила заражения), предусловия/эффекты GOAP.  
- **PlayMode**: фикстуры сцены «маленькая карта» → 200 тиков → проверка инвариантов и сохранения/загрузки. Инструкции по Edit/Play Mode тестам. citeturn2search0turn2search12

---

## Частые «подлянки» и как их ловить
- `JsonUtility` не умеет `Dictionary<>`/полиморфизм по умолчанию — тестируй модели сейва отдельно. citeturn0search19turn0search8  
- Animator/таймеры на паузе — переводить на Unscaled Time/Realtime. citeturn0search7turn0search10  
- DOTS: структурные изменения без ECB → тормоза/рассинхрон; фикс-шаг — это именно группа, а не `Time.fixedDeltaTime`. citeturn1search6turn0search17  
- Addressables: несмиренные `Release` → утечки памяти. Делай «зеркальные» счётчики загрузок/выгрузок. citeturn1search10

---

Хочешь — разверну любой блок (например, InfectionSystem или Utility-скоры) в «пошаговый план дебага + примеры ассерт-тестов + подсказки по профилировщику» и сразу подготовлю мок-сцену для проверок.
