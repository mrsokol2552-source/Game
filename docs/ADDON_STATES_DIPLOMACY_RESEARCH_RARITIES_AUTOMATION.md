
## Оглавление
- [Обзор](#обзор)
- [Данные](#2-data)
- [Приложение](#3-application)

## Обзор
Краткий конспект дополнения: состояния, дипломатия, редкости исследований, аномалии, автоматизация, экология. Детали ниже по разделам.
Дополнение к проекту: Государства, Дипломатия, Редкости Исследований, Аномалии, Автоматизация, Экономика, Логистика и ФортификацииВерсия: 1.0 • Ядро: Unity (C#) • Архитектура: Domain/Data/Application/AI/Presentation/InfrastructureСовместимость: off‑screen LOD‑симуляция, EventBus, сохранения JSON, PathfindingЦель: объединить в единый план архитектуры все подсистемы 2D RTS с паузой – включительно несколько государств с дипломатией (посольства/союзы/слияние), расширенную экономику (двойной бюджет государства и игрока), логистику перемещений и фортификации, пересобранное древо исследований (обычные/редкие/аномальные), симуляцию заражения, аномалии и автоматизацию процессов через серверы/ядра.`nВсе новые механики вписаны в существующую архитектуру (событийная модель, off-screen симуляция, сохранения, ScriptableObject-конфиги).0) Коротко (TL;DR)Государства (States): старт за выбранное государство; уровни отношений → Нет контакта → Посольство → Союз → (возможное) Слияние.Видимость/интел:Нет контакта или вражда — AI не “видит” юниты/постройки другого государства (свой туман войны).Посольство — видны юниты/постройки, без экономики/очередей задач.Союз — видно всё (вкл.`nэкономику и очереди), но каждый контролирует только свои войска.Слияние: ежедневно малая вероятность p (растёт со временем союза); при слиянии два государства объединяются под контролем одного AI; игрок остаётся лидером своей стороны.Экономика: введено 4 базовых ресурса (труда-часы, энергия, материалы, еда) с суточным циклом производства и потребления.`nДвойной бюджет: часть прироста автоматически резервируется под задачи гос-ИИ (настройка процентами), остальное в распоряжении игрока.`nДефициты ресурсов снижают эффективность по приоритетам (отключение энергии, голод – падение прироста населения и пр.).Логистика: система узлов и коридоров снабжения (город, станция, порт, аэродром + дороги, ж/д, авиамаршруты).`nИгрок отдаёт приказы переброски (“откуда–куда”, приоритет, цель прибытия), юниты перемещаются автоматически.`nВремя в пути рассчитывается с учётом пропускной способности; есть режим “рывок” (+50% скорость за повышенный расход).`nУзкие места и очереди на маршрутах визуализируются, поддерживается авто-маршрутизация подкреплений.Фортификации: юниты-инженеры могут возводить укрепления — временные (окоп, мешки с песком, наблюдательный пункт) и постоянные (ДОТ, бункер, рвы).`nУ каждой позиции есть стоимость (труд, материалы, иногда энергия), время постройки, уровень защиты и износ.`nВременные позиции деградируют со временем и под огнём; постоянные – медленнее и поддаются ремонту.`nДоступны инструменты строительства линий (траншеи по полилинии) и узловых точек; возможно улучшение временных позиций до постоянных.Исследования: древо по категориям с “видимым одним шагом” вперёд; редкость исследований: Обычные / Редкие / Аномальные.`nШанс редкого зависит от качества исследований (скрытый агрегатный показатель зданий науки).`nСтоимость шагов растёт на 10–15% за каждый завершённый шаг (инфляция прогресса).Здания науки: два типа апгрейдов — количественный (повышение скорости исследований, RP) и качественный (повышение качества, QP).`nИгрок не знает точного шанса появления редких исследований, но получает косвенные индикаторы уровня качества.Аномалии: особые технологии доступны только при наличии содержания заражённых образцов и команд по их поимке.`nОбразцы расходуются в исследованиях; для прогресса по аномалиям требуется налаженный цикл автоматизации “поимка → доставка образцов → изучение”.Автоматизация: специальные серверные здания дают вычислительные единицы (CU); ядро автоматизации берёт под контроль один процесс (отряд или здание), потребляя много энергии и CU.`nЯдро полностью автоматизирует выбранный цикл (например, выполняет исследования или управляет отрядом без участия игрока).1) Domain (модели и правила)1.1 Сущности (Entities)public enum IntelAccess { None, UnitsAndBuildings, Full }       // уровни доступа к данным другого гос-ваpublic enum RelationKind { None, Hostile, Embassy, Alliance }    // стадия отношений между гос-вамиpublic enum ResearchRarity { Common, Rare, Anomalous }           // тип исследования по редкостиpublic enum ResourceType { Labor, Power, Materials, Food }       // базовые ресурсы экономикиpublic sealed record StateId(string Value);public sealed record SectorId(int X, int Y);public sealed class State{    public StateId Id;    public string Title;    public Dictionary<StateId, Relation> Relations = new();    public IntelLayer Intel;                     // знание о мире (свой FoW и обнаруженные объекты)    public EconomySnapshot Economy;              // запасы ресурсов и бюджеты    public ResearchProgress Research;            // прогресс по веткам исследований    public AutomationNetwork Automation;         // доступные CU и привязанные ядра    // ...`n(прочие подсистемы: очереди логистики, строительство фортификаций и пр.)}public sealed class Relation{    public RelationKind Kind;       // None/Hostile/Embassy/Alliance    public float DaysInAlliance;    // накапливается, только когда Kind=Alliance    public float Stability;         // 0..1 (доверие, история, общие цели)}public sealed class IntelLayer               // "карта знаний" государства о других{    // Права доступа к данным другого гос-ва:    public IntelAccess AccessTo(StateId other);    // Получить известные данные (с учётом FoW):    public KnownUnits GetKnownUnits(SectorId sector, StateId other);    public KnownBuildings GetKnownBuildings(SectorId sector, StateId other);    public KnownEconomy GetKnownEconomy(StateId other);    // экономика/очереди (только при Full)}// Прогресс исследований данного государства:public sealed class ResearchProgress{    public Dictionary<string, Branch> Branches;  // активные ветки (например "economy.extraction")    public int TotalSteps;                      // сколько шагов исследования завершено (для инфляции стоимости)    public float CostMultiplier;                // текущий мультипликатор стоимости (=(1+r)^TotalSteps)    public float QualityScore;                  // скрытый агрегат (отношение QP/RP от зданий науки)}public sealed class Branch{    public string Id;                // например "economy.extraction"    public int Completed;            // сколько шагов в ветке пройдено    public ResearchDef Current;      // текущий (единственный видимый) исследуемый шаг}public sealed class ResearchDef{    public string Id;    public string BranchId;    public ResearchRarity Rarity;    // Common/Rare/Anomalous    public float BaseCostRP;         // базовая стоимость (в RP)    public string[] PrereqIds;       // требования (предыдущие исследования)    public string[] RequiresAssets;  // требуемые объекты для разблокировки (напр.`nContainmentLab, CaptureTeam)}public sealed class AutomationNetwork{    public float TotalComputeUnits;   // суммарно доступные CU (от всех ServerFarm)    public List<AutomationCore> Cores;    public void AttachCore(AutomationCore core, IAutomatable target);    // ...}1.2 Формулы и правила (Diplomacy, Economy, Infection, Logistics, Fortification)Intel‑доступ:None → (ничего не видно);Embassy → Units+Buildings (разрешено видеть дислокацию/типы/прочность юнитов и построек союзника, без экономики и очередей задач);Alliance → Full (полный доступ ко всем данным, включая экономику, прогрессы исследований, очереди строительства).Примечание: уровень доступа влияет только на осведомлённость, но не даёт контроля над чужими войсками или строениями.Шанс слияния (ежедневный) – если государства находятся в союзе:p_merge(day) = clamp( p0 + a * ln(1 + DaysInAlliance/7) + b * Stability - c * Strain, 0, p_max )Где: p0=0.0015 (0.15%), a≈0.002, b≈0.005, c≈0.003, p_max=0.12.Статистика: DaysInAlliance растёт каждый день в союзе; Stability (0..1) повышается при успешных совместных операциях и малых потерях; Strain – штраф за конфликты интересов и дефициты ресурсов.`nПри успешном ролле слияния происходит объединение: одно государство поглощается другим, передаются территории, юниты, ресурсы, очереди (конфликты очередей решаются по приоритетам).Инфляция стоимости исследований: после каждого завершённого шага (глобально или в рамках ветки – настройка баланса) стоимость следующего увеличивается:Cost(next) = BaseCost * (1 + r)^(i), где i – порядковый номер шага для данного гос-ва (или ветки); r – ставка инфляции (обычно 0.10–0.15 для Common, выше для Rare/Anomalous).Редкость следующего шага: после завершения текущего исследования вычисляется новый текущий шаг ветки:pRare = clamp( pRareBase + α * QualityScore, 0, pRareMax )if (Roll(pRare)) select Rare else select Common.// Anomalous доступен, если выполнены все RequiresAssets (напр.`nContainmentLab, CaptureTeam) // и выполнен независимый Roll(pAnom), где pAnom << pRare и также зависит от QualityScore и накопленной статистики образцов.QualityScore – скрытый показатель качества исследований: QS = Σ(QP) / (Σ(RP) + ε), где RP (research points) и QP (quality points) дают научные здания.`nВысокий QS повышает шанс редких исследований.`nАномальные технологии становятся возможны только при наличии спец.`nинфраструктуры и достаточного числа заражённых образцов.Экономика – ресурсы и суточный цикл: введены четыре базовых ресурса: трудовые часы населения, энергия (производство/потребление за день), материалы (стройматериалы, боекомплект) и еда (пропитание гражданских и военных).`nЭкономический тик происходит раз в игровой день по фиксированному порядку (см.`nниже).`nДля каждого здания заданы: стоимость постройки, время строительства, штатная потребность в труде, потребление/выработка энергии, ежедневное обслуживание и прирост/переработка ресурсов.`nЗапрет отрицательных запасов: система автоматически снижает неприоритетные расходы, если ресурс на нуле (подробности – см.`nдефициты и приоритеты).Прирост населения и рекрутинг: каждый день рассчитывается прирост населения CivGrowth (чел./день) для каждого государства.`nПрирост добавляет в пул свободных гражданских; их трудовые часы вычисляются как LaborHours = CivFree * HoursPerCitizen (константа, напр.`n8 ч/день).`nЧерез постройки типа Казармы или Призывной пункт часть свободных гражданских можно конвертировать в военных: у таких построек есть лимит новобранцев в день, время подготовки и стоимость подготовки (еда, материалы, энергия, труд).`nПо завершении обучения новый военный юнит поступает в резерв/гарнизон.Двойной бюджет (гос-ИИ и игрок): вводится механика передачи части ресурсов от игрока под управление стратегического государственного AI.`nДля каждого ресурса (включая CivGrowth) у игрока есть слайдер процента передачи в диапазоне 0–100%.`nВыбранный процент от суточного прироста данного ресурса автоматически передаётся в распоряжение гос-ИИ (до поступления на склад игрока).`nОкругляется вниз до целых единиц; остаток получает игрок.`nЭти настройки можно задать глобально и при необходимости переопределить для каждого AI-союзника отдельно.`nГос-ИИ расходует свой бюджет на приоритетные задачи (оборона, карантины, базовые исследования, поддержание экономики и логистики), автоматически перераспределяя средства по Utility-оценкам важности.`nБюджет игрока используется им напрямую для точечных операций (ускоренные постройки, заказы технологий, возведение укреплений, нанятие отрядов).`nВнутри государства могут существовать механики налогов, субсидий, займов под проценты, лимитов капитальных/операционных расходов и т.п.`nдля балансировки двух потоков бюджета.Контракты и штрафы: отношения между игроком и гос-ИИ в экономике оформляются как контракты – например, на строительство объекта, проведение исследования или ликвидацию очага инфекции.`nКонтракт – это сущность с жизненным циклом (заключён, выполняется, выполнен/сорван).`nСорванные контракты влекут штрафы: уменьшение доверия/стабильности, разовые вычеты из бюджета или падение рейтинга игрока.`nВыполненные – повышают доверие и могут приносить бонусы (бонус к финансированию, перки).Модель инфекции: выбрана гибридная схема – сочетание классической эпидемиологической модели (SIR/SEIR) с клеточным автоматом на мировой сетке.`nЗаражение распространяется по ячейкам (соседство по сети ячеек – фиксированное Moore или Von Neumann)[1][2], с диффузией влияния от каждой заражённой клетки.`nПараметры SIR (скорости заражения, восстановления, смертности) настраиваемые и могут меняться, например, при исследованиях вакцины.`nРаспространение усиливается или сдерживается инфраструктурой и действиями: сооружение санитарных кордонов и карантинных зон снижает мобильность и вероятность заражения (но сокращает производство в этих зонах); наличие транспортных путей (дороги, железные дороги, авиа) может ускорять распространение инфекции между отдалёнными регионами.`nВыделяются “очаги” инфекции – кластеры клеток с высокими показателями заражённости; образуется динамическая “линия фронта” между заражёнными и чистыми территориями.`nГос-ИИ ставит целью сдерживать фронт на границах очагов, а игрок может финансировать и проводить операции прорыва (очистки) в ключевых точках.Оптимизация инфекции: обновляются только “активные” клетки (фронтир) вместо всей сетки[2][3].`nРеализация диффузии – в два шага: (1) сбор влияния соседей для всех активных клеток, (2) применение обновлений (используется двойной буфер для сетки, чтобы расчёты одного тика не влияли на него же).`nВозможен перенос тяжёлых вычислений инфекции в Unity Jobs (параллельно по чанкам IJobParallelFor, хранение полей заражения в структурах NativeArray<float> с Burst-компиляцией)[2][3], либо использование ECS (системы в группе FixedStepSimulationSystemGroup с хранением сетки в компонентах).`nБаза данных соседей (для Moore/Neumann в сетке) фиксирована для воспроизводимости.`nДля визуализации и отладки — накладывается цветовая карта заражения (heatmap), позволяющая наблюдать прогресс и обнаруживать аномалии в расчётах.Логистика (транспорт): введён класс объектов LogisticNode (тип: город, станция, порт, аэродром и пр.) и связи LogisticLink (дорога, ж/д путь, авиамаршрут) между узлами.`nИгрок не управляет непосредственно транспортом юнитов, а создаёт приказы переброски: указывает отправной узел, пункт назначения, приоритет и желаемую группу/цель прибытия.`nСистема логистики автоматически рассчитывает кратчайший по времени путь по сети узлов, учитывая пропускную способность звеньев и текущие загруженности.`nЮниты (или ресурсы) перемещаются в фоновом режиме, не требуя постоянного микроконтроля.`nРеализуется очередь на маршрутах: если пропускная способность звена ограничена, транспорт ожидает.`nПоддерживается режим ускоренной переброски (Rush) – юниты могут двигаться на ~50% быстрее ценой повышенного расхода материалов и энергии[4].`nДля стабильной работы логистики предусматриваются механизмы авто-маршрутизации: игрок может обозначить для армий “домашние” базы (узлы), и тогда пополнение войск идёт автоматически по заданным маршрутам.`nПри изменении сети (разрушены узлы, перекрыты дороги) — система частично инвалидирует кэш маршрутов и пересчитывает пути только затронутых направлений.`nДля эффективности маршрутизации на большой карте используется иерархическая навигация (например, алгоритм HPA: кластеризация сетки и вычисление путей между «порталами» кластеров)[5].`nВнутри кластера применяется быстрый алгоритм поиска (A с Jump Point Search ускорением для равномерной сетки)[6].`nПосле прокладки маршрута выполняется сглаживание пути (string-pulling) для удаления лишних углов и избегания «красных зон» (например, заражённых секторов, если есть альтернатива).Фортификации: боевые инженерные юниты могут строить полевые укрепления.`nУкрепления бывают временные (окопы, мешки с песком, наблюдательные пункты) – возводятся быстро из подручных материалов, дают небольшой бонус к защите, но постепенно ветшают; и постоянные (ДОТы, бункеры, противотанковые рвы) – требуют больше ресурсов и времени, но обеспечивают серьёзную защиту и служат долго (нуждаются лишь в ремонте).`nКаждой постройке задана стоимость в ресурсах (трудо-часы, материалы, иногда энергия), необходимое время строительства, уровень защиты/укрытия, а также показатели деградации со временем и под обстрелом.`nРеализованы инструменты игрока для быстрого размещения фортификаций: линейное строительство (рисование линии траншеи произвольной формы) – система автоматически превращает линию в последовательность сегментов окопа с суммарной стоимостью пропорционально длине; узловые точки – отдельные укрепления (точки обороны) размещаются поодиночке; апгрейд позиции – возможность улучшить существующую временную позицию до постоянной (учитывается часть уже вложенных трудо-часов и материалов).`nСтроительство выполняют доступные инженерные подразделения; несколько подразделений могут работать параллельно над разными задачами, либо над разными сегментами одной длинной траншеи.`nВременные укрепления со временем теряют эффективность (прочность, бонусы), особенно под огнём; постоянные – тоже, но медленнее, и могут быть восстановлены ремонтом.1.3 Автоматизация (Automation)public interface IAutomatable {     bool StartProcess();    // запустить процесс (если доступен ресурс)    bool IsRunning { get; } // сейчас выполняется    bool IsStalled { get; } // приостановлен (дефицит ресурсов)    bool CompleteStep();    // выполнить атомарный шаг процесса (например, один тик исследования или цикл постройки)}public sealed class AutomationCore {    public Guid Id;    public IAutomatable CurrentTarget;   // текущий автоматизируемый объект (юнит/здание)    public bool IsActive;    public float EnergyConsumption;      // потребление MW    public float ComputeConsumption;     // потребление CU    // ...}Принцип: ядро может быть привязано к одному объекту (например, отряду или лаборатории) и берёт на себя выполнение его операций.`nДля работы ядро требует большого расхода энергии и ComputeUnits (CU).`nЕсли ресурсов не хватает, ядро ставит процесс на паузу (состояние Stalled).`nПример: ядро автоматизации прикреплено к лаборатории исследований – тогда все исследования в этой лаборатории выполняются автоматически без команд игрока; либо ядро к отряду захвата образцов – отряд сам по себе выполняет цикл поимки заражённых.`nИгрок ограничен числом имеющихся ядер и общим количеством вычислительных ресурсов, поэтому должен выбирать, какие задачи автоматизировать.2) Data (конфиги, JSON, SO)2.1 Примеры JSON конфигурации (упрощённо)States & Relations (государства и отношения):{  "states": [    { "id": "player", "title": "Союз Горного Края" },    { "id": "red",    "title": "Красная Коммуна"   },    { "id": "blue",   "title": "Северный Консорциум" }  ],  "relations": [    { "a": "player", "b": "red",  "kind": "Hostile",  "stability": 0.2 },    { "a": "player", "b": "blue", "kind": "None",     "stability": 0.0 }  ]}ResearchDefs (исследования):{  "research": [    { "id": "eco.extraction.1", "branch": "economy.extraction", "rarity": "Common",      "baseCostRP": 100, "prereq": [] },    { "id": "eco.extraction.R1","branch": "economy.extraction", "rarity": "Rare",      "baseCostRP": 160, "prereq": ["eco.extraction.1"] },    { "id": "anom.capture.1",   "branch": "anomaly.capture",    "rarity": "Anomalous",      "baseCostRP": 220, "requiresAssets": ["ContainmentLab","CaptureTeam"] }  ]}Buildings (здания науки, аномалий, серверы, ядра):{  "buildings": [    { "id": "Lab_T1",        "type": "Science",     "rp": 1.0, "qp": 0.1, "power": 0.5 },    { "id": "Lab_T2",        "type": "Science",     "rp": 2.2, "qp": 0.2, "power": 0.8,      "upgradeOf": "Lab_T1" },    { "id": "Lab_Spec",      "type": "Science",     "rp": 1.0, "qp": 1.4, "power": 1.2 },    { "id": "ContainmentLab","type": "Containment", "capacity": 20, "power": 1.5 },    { "id": "ServerFarm_T1", "type": "Server",      "computeUnits": 20, "power": 3.0 },    { "id": "AutomationCore","type": "Core",        "consumeCU": 10, "power": 2.5 }  ]}Economy & Logistics (экономика, логистика, фортификации):{  "economy": {    "dailyTickHour": 0,    "transferToAI": { "laborPct": 20, "powerPct": 0, "materialsPct": 0, "foodPct": 0, "civGrowthPct": 0 }  },  "population": {    "civilians": 10000,    "baseDailyGrowth": 45,    "hoursPerCivPerDay": 8  },  "buildings": [    { "id": "farm_t1",     "type": "economic", "buildTimeDays": 3, "cost": {"materials":120},      "powerIn": 5, "laborIn": 10, "foodOut": 60 },    { "id": "barracks_t1", "type": "unit_prod", "buildTimeDays": 4, "cost": {"materials":200},      "powerIn": 10, "laborIn": 20,      "convert": { "civPerDay": 20, "trainDays": 2, "costPerRecruit": {"food": 2, "materials": 1} } }  ],  "logistics": {    "nodes": [      { "id": "city_A", "type": "city" },      { "id": "front_N", "type": "front" }    ],    "links": [      { "from": "city_A", "to": "front_N", "mode": "rail", "capacityUnitsPerDay": 50, "baseHours": 6 }    ]  },  "fortifications": [    { "id": "foxhole", "category": "temporary", "labor": 4,  "materials": 2,   "buildHours": 6,  "cover": "light" },    { "id": "bunker",  "category": "permanent", "labor": 40, "materials": 120, "powerIn": 2,    "buildDays": 5, "cover": "heavy" }  ]}Примечание: приведённые JSON-фрагменты иллюстрируют возможную структуру данных.`nВ реальном проекте конфигурации могут храниться как ScriptableObject-ы и/или JSON в Addressables.2.2 ScriptableObject каталоги и сохраненияКаталоги (Assets): StateDef.asset, ResearchDef.asset, BuildingDef.asset, RecipeDef.asset, UnitDef.asset, InfectionParams.asset и др.`n– хранят статические данные игровых сущностей.`nПри старте они используются для создания runtime-моделей (plain C# объекты), которые используются в симуляции (оригиналы SO остаются неизменными)[7].Версионирование сохранений: введён идентификатор версии SaveVersion (целый), сохраняемый вместе с данными.`nПри загрузке проверяется версия; если она старее текущей – выполняются миграции (добавление новых полей с дефолтами, пересчёт устаревших параметров и т.д.)[8].`nСтарые файлы thus автоматически поддерживаются после обновлений.Секции сохранения: помимо базовых разделов (юниты, постройки, карта) сохраняются новые подсистемы: states[] (список государств с их ресурсами), relations[] (отношения), researchProgress (прогресс по веткам и QS), automation (сеть серверов и ядра), containment (содержимое лабораторий по аномалиям).`nВ составе данных государств сохраняются DaysInAlliance, Stability по союзам, текущие ресурсы, очереди логистики, фортификаций и пр.`nВсе случайные величины (роллы слияния, выпадение редких исследований) должны быть детерминированы через сохраняемый randomSeed[9], чтобы при повторном прогоне результаты совпадали.3) Application (циклы, события, системы)3.1 EventBus – ключевые событияОсновные события, генерируемые системами в ходе игры, для подписки логики UI, логирования и скриптов:Diplomacy/RelationsChanged(StateId a, StateId b, RelationKind newKind)Diplomacy/MergeHappened(StateId winner, StateId absorbed)Intel/AccessChanged(StateId viewer, StateId target, IntelAccess newAccess)Research/StepCompleted(StateId state, string branchId, string defId, ResearchRarity rarity)Research/NextStepAssigned(StateId state, string branchId, string defId, ResearchRarity rarity)Anomaly/SamplesRequired(StateId state, int amount)      // требуются образцы (для аномалии)Anomaly/Breach(StateId state, SectorId sector, int severity) // утечка/прорыв заражённыхAutomation/CoreAttached(Guid coreId, string targetId)   // ядро автоматизации привязано к целиAutomation/CoreStalled(Guid coreId, string reason)      // пауза работы ядра (дефицит ресурсов)Power/GridOverload(StateId state, float deltaMW)        // нехватка энергии в сетке (отключения)Logistics/TransferQueued(int transportId, string fromNodeId, string toNodeId)Logistics/TransferCompleted(int transportId)(События сгруппированы по тематике.`nКроме того, используется пакетирование повторяющихся событий: при всплеске множества однотипных событий система может склеивать их в одно – например, вместо 50 раздельных событий заражения ячеек за тик выдать один батч "InfectionSpread" списком секторов.)*3.2 Simulation Loop – игровой цикл и таймингФиксированный тик: игровая симуляция работает с фиксированной длительностью шага (например, 0.5 секунды реального времени).`nРеализация – собственный цикл SimulationLoop с использованием накопителя времени (unscaledDeltaTime)[10].`nЭто обеспечивает независимость симуляции от фреймрейта и корректную паузу.`nПауза реализована либо через флаг (при IsPaused все системные тик-апдейты пропускаются), либо глобально Time.timeScale = 0 – в последнем случае нужно убедиться, что вся UI-анимация и таймеры используют unscaled время[10].`nТакже поддерживаются режимы скорости: ×0.5 / ×1 / ×2 / ×4 – изменение скорости масштабирует unscaledDeltaTime для симуляционных систем.`nДополнительно, предусмотрена кнопка «Шаг» – выполнить вручную один тик при паузе[11] (для отладки или пошаговой игры).Порядок систем на тик:Diplomacy (обработка заявок на отношения, расторжений)Intel (обновление уровней доступа, FoW слоёв)Research (генерация очков, проверка завершения шага)Automation (работа активных ядер, прогресс автоматизированных процессов)Economy/Production (суточный расчёт ресурсов и производство, если настал дневной тик)Infection/Quarantine (распространение инфекции, эффекты карантинов)Logistics (обновление статусов перебросок, прибытие/убытие юнитов)Combat/Anomaly (боевые системы, события аномалий)EventBus.Flush() (после завершения тика – отправка накопленных событий слушателям)[12][13].Примечания: Экономика и ряд систем обновляются раз в игровые сутки (может быть реализовано счетчиком тик-циклов или отдельным таймером).`nПри паузе игровые системы не обновляются, однако UI и анимации работают (на unscaled time).`nOff-screen LOD: для отдалённых секторов или объектов стратегические системы (Diplomacy, Research, Automation, Infection) могут тикать с пониженной частотой[14] или в агрегированном режиме (например, раз в 10 тиков), чтобы снизить нагрузку.`nПри большом количестве объектов алгоритмы вроде подсчёта влияний, обновления экономики или поиск пути могут распределяться на несколько кадров (cooperative multi-threading) или запускаться асинхронно в потоках/Jobs.Команды и задачи: взаимодействие игрока с игрой (построить здание, отдать приказ отряду, запустить исследование) реализовано через команды, которые помещаются в очередь и применяются либо сразу, либо в безопасной точке цикла.`nВ ряде случаев поддерживается отмена (undo) команды, пока она не выполнена (например, можно снять с постройки здание, удалив команду до её исполнения).`nВсе команды за тик логируются; при сохранении состояния важен тик-бариер – сохранение выполняется после полного завершения тика (и применения команд), чтобы не было «полуприменённых» действий[15].3.3 Системы PathfindingPathfinding: Для поиска пути юнитов на сетке используется A с улучшениями.`nНа малых дистанциях и в локальных боях работает Jump Point Search (JPS) – оптимизация A для равномерной сетки, пропускающая тривиальные промежуточные узлы[6].`nНа уровне всей карты применяется иерархический A (алгоритм HPA)[5] – сетка разделяется на области (кластеры), считаются порталы между ними; первый этап поиска строит маршрут по графу кластеров, второй этап – подробный путь внутри кластеров.`nТакой подход резко ускоряет поиск на больших картах.`nПоиск пути выполняется асинхронно (в Job-потоках) и позволяет пакетировать запросы – несколько запросов могут обрабатываться параллельно[16].`nПри изменениях карты (появилось здание, карантин) система помечает только затронутые области как требующие обновления (partial invalidation)[16].`nПосле построения маршрута производится сглаживание траектории, а также накладываются запреты на движение через опасные зоны (например, через заражённые клетки или через чужие территории, если нет разрешения) – при наличии запрета система выберет альтернативный маршрут либо выдаст предупреждение, если путь невозможен.Debug & Visualize: Для отладки алгоритма пути предусмотрено отображение: при расчёте пути можно визуализировать проход алгоритма – отображать открытые и закрытые узлы, итоговый маршрут (например, с помощью OnDrawGizmos или линий)[17].`nЭто помогает убедиться, что алгоритм работает корректно и эвристика согласована с расстоянием (иначе путь будет suboptimal или не найден).3.4 Сохранения и репликацияJSON-сохраняемость: игровые модели структурированы так, чтобы быть сериализуемыми в JSON с помощью JsonUtility.`nСледует избегать несериализуемых полей (например, Dictionary без кастомного конвертера)[18] и ссылок на ScriptableObject в полях состояния.`nПолиморфные поля (напр.`nинтерфейсы) требуют атрибута [SerializeReference] и проверки, что ToJson/FromJson корректно восстанавливает подтипы[18].`nПри сложных случаях возможен переход на стороннюю JSON-библиотеку, но базовый подход – плоские структуры данных.`nСохранения больших массивов (например, состояние сетки заражения) допустимо переводить в бинарный формат для компактности (с обёрткой в Base64 в JSON либо отдельным файлом).Addressables (память): все крупные ассеты (спрайты, звуки) загружаются через Addressables.`nВажно тщательно отслеживать выгрузку: после использования объектов необходимо вызывать Addressables.Release – иначе объекты останутся в памяти[19][20].`nРекомендуется вести счётчики загруженных ресурсов для отладки, а также группировать ассеты в Addressables-группы по используемому режиму (для разных стратегий кеширования и подгрузки)[21].4) AI (стратегия, тактика, дипломатия)4.1 Дипломатические решения (AI Diplomacy)Utility‑оценки выгод/рисков: AI оценивает целесообразность установления или разрыва отношений через utility-функции.`nПримеры выгод для Embassy/Alliance: бонусы торговли, совместный фронт обороны, наличие общих врагов[22].`nПримеры “стоимости”: риск утечки информации союзнику, вероятность нежелательного слияния (если AI не хочет потерять независимость)[22].`nРазные ИИ-фракции имеют разную политику: агрессивные стремятся к войнам, прагматичные – к локальным посольствам по границам, коалиционные – к союзам против общего противника[23].Обновление отношений: решения о смене отношений принимаются периодически (на стратегическом тикере).`nЕсли utility выгоды союза превышает порог – AI предложит союз (или согласится на предложение игрока); если наоборот риск превысил выгоду – может разорвать союз/посольство.`nПримечание: игрок инициирует дипломатию через UI, а AI – через внутренний механизм, результат всегда оформляется событием RelationsChanged.4.2 Интеллект и FoW (Intel & Fog-of-War)У каждого государства собственный слой IntelLayer, где хранится информация о других.`nПри отсутствии контакта или вражде – IntelAccess = None, данные отсутствуют (юниты и постройки противника скрыты, если не находятся в прямой видимости игрока).`nПри Embassy – устанавливается ограниченный доступ (юниты и постройки союзника видны и отображаются, но информация о его экономике, запасах ресурсов, очередях производства недоступна)[24].`nПри Alliance – доступ Full: союзники полностью прозрачны друг для друга по данным, хотя управление остаётся раздельным.Тактическое поведение AI также учитывает Intel: при Embassy союзник видит войска игрока, может реагировать на их положение (например, подтягивать свои войска к участку фронта, где игрок сконцентрировался), но не планирует использование чужих войск напрямую[24].`nПри Alliance AI координирует действия, предполагая помощь союзных войск, но прямого контроля всё равно не имеет – т.е.`nсоюзники действуют синхронно по целям, но каждый своими отрядами.4.3 Слияние государств (Merge Logic)Если два государства находятся в союзе и наступает событие Roll(p_merge) – инициируется процесс слияния.`nГенерируется событие MergeHappened, после чего один из AI назначается главным (например, выбирается “старший союзник” с большим вкладом в войну или с наибольшей экономикой)[25].`nВторое государство прекращает самостоятельное существование: его территории, постройки, юниты переходят под контроль нового объединённого государства.`nЭкономики и бюджеты объединяются, очереди строительства и исследований сливаются (конфликтующие приоритеты решаются по заранее настроенным коэффициентам приоритетов).`nИгрок, если он был лидером одного из объединяемых государств, остаётся лидером своей стороны (его статус не теряется).`nПосле слияния у нового объединённого государства пересчитывается баланс (например, Stability может снизиться из-за объединения разнородных наций, а Strain повыситься).`nСохранение/загрузка проверяется на корректную поддержку слияния (могут быть миграции данных при переходе версии).4.4 Стратегическое и тактическое поведение (Utility AI + GOAP + BT)Strategic Utility AI: глобальный стратегический AI каждой фракции оценивает возможные цели каждые N тиков (реже, например раз в 0.5–1 секунду реального времени)[26].`nЦели могут включать: сдержать распространение инфекции, закрыть стратегическое горлышко, исследовать технологию X, поддержать союзника (игрока)[27] и т.д.`nКаждой цели соответствует utility-функция, нормализованная в диапазон [0..1], которая вычисляет важность этой цели на основе текущего состояния (например, близости врага к базе, количества доступных ресурсов, уровня угрозы инфекции и пр.).`nAI выбирает цель с максимальным utility как приоритетную.GOAP (Goal-Oriented Action Planning): выбрав стратегическую цель, AI строит план действий для её достижения с помощью планировщика GOAP[27][28].`nНапример, цель "оборона рубежа" может привести к плану: собрать ресурсы → исследовать технологию «Щит-1» → построить 3 турели по дуге X.`nПланировщик ограничен по глубине и времени поиска, чтобы не зависнуть; кэшируются типовые под-планы для повторного использования[29].`nПри каждом стратегическом тике, если текущая цель выполнена или изменилась ситуация, AI может перепланировать (но чтобы избежать дергания, вводится минимальный интервал или inertia цели).`nРеференс: реализация GOAP вдохновлена классической работой Jeff Orkin (F.E.A.R.`nAI Planning)[28].Behavior Trees (BT): на тактическом уровне (для конкретных отрядов) AI использует древья поведения.`nBT обрабатывает микро-задачи вроде патрулирования, ремонта, перестройкиFormation.`nВ общем случае, стратегический AI (Utility/GOAP) не микроменеджит бой, а задаёт цели, тогда как Behavior Tree выполняет их, разбивая на примитивные действия (двигаться в точку, атаковать, отступить, залечь и т.д.).`nBT узлы могут содержать ограничители (например, выполнять поведение не больше N тактов) и условия успеха/фейла.`nВажно избегать принятия крупных решений непосредственно внутри BT – за этим следят Utility/GOAP, а BT исполняет план[30].`nДля отладки AI можно логировать активные ветки BT с каждым тиком и их результаты (Success/Fail/Running)[30].Influence Maps (карты влияния): для ускорения тактических оценок AI и придания им “осведомлённости” о ситуации используются карты влияния.`nРазличные факторы (сила врага в районе, наличие укреплений, проходимость, покрытие артиллерии и т.д.) представляются в виде полей на сетке (например, float-значение на каждый тайл)[31].`nЭти карты обновляются инкрементально: при изменениях (перемещение войск, строительство укрепления) пересчитывается локально вокруг изменения или по кольцевым зонам[32].`nUtility-оценки AI могут напрямую читать значения influence-карт вместо того, чтобы сканировать все объекты, что значительно экономит время.`nПримеры карт: карта риска заражения, карта оборонительного покрытия (где свои фортификации), карта давления противника на фронте.`nInfluence-карты хранятся в массивах, пригодных для Burst, и могут обновляться параллельно (Jobs) при необходимости[32].`nДля визуализации и отладки эти карты могут отображаться на UI (heatmap с изолиниями)[33].Оптимизация AI: стратегический AI тикает разреженно (раз в несколько симуляционных тиков), а тактические компоненты – чаще (каждый тик или через тик)[26].`nРасчёты Utility желательно распределять по кадрам, если целей много (budgeted AI).`nПланировщик GOAP ограничивается по ресурсам (глубине поиска, времени), а Behavior Trees – по количеству шагов за тик (для долгих последовательностей может растягивать выполнение).4.5 Координация союзниковСоюзный AI: при нахождении в союзе два AI обмениваются данными (как указано в IntelAccess) и стараются координировать стратегии.`nНапример, цели типа “поддержать союзника” получают повышенный utility, если союзник запрашивает помощь.`nМеханика запросов может быть реализована через события (например, игрок посылает Signal о нужде в помощи в секторе, AI-союзник усиливает туда войска).`nОднако прямого подчинения войска не получают – союзник решает сам, выделять ли силы.`nВ случае, если один из союзников – человек, а другой – AI, AI будет стараться компенсировать слабые места игрока (например, перекрывать незащищённые направления, снабжать ресурсами при критическом дефиците через дипломатию).`nПри подготовке к возможному слиянию AI может сознательно избегать конфликтов, чтобы не повышать Strain и увеличить шансы на успешное объединение.5) Presentation (UI/UX)Экран старта: выбор начального государства для игрока (иконка, название, краткое описание бонусов/особенностей).Дипломатия: экран/панель отношений – список известных государств, текущий уровень (цветом или иконкой: None/Hostile/Embassy/Alliance), индикаторы доверия/стабильности.`nКнопки действий: предложить посольство/союз, разорвать отношения.`nПри поступлении предложения от AI – всплывающее уведомление с выбором ответа.Интел‑слои: переключатели на тактической карте: “Показать свои войска”, “Показать войска с посольствами”, “Показать войска союзников”.`nОтображаются только объекты, которые соответствуют текущему уровню IntelAccess.`nВсплывающие подсказки при наведении объясняют, что игрок видит/не видит в каждом режиме.Событие слияния: при слиянии государств – диалог-событие (с оповещением, звуковым сигналом), описывающий изменения.`nПосле подтверждения – временная лента/лог показывает передачу территорий, объединение армий, перерасчёт экономики.Экран исследований: для каждой ветки отображается ровно один доступный сейчас шаг (с описанием и требуемыми RP), а далее значки неопределённых шагов (“?” или затемнённые), указывающие, что исследования будут открываться последовательно.`nШанс появления редкого шага не показывается явно, но UI может давать косвенные подсказки (например, текст о том, что “качество исследований на высоком уровне, есть шанс на редкий прорыв”).`nПосле завершения шага появляется следующий.Аномалии: индикатор количества доступных заражённых образцов (например, на HUD или в экране исследований).`nПредупреждения о утечках (Breach) – всплывающие уведомления с деталями (сектор, тяжесть).`nОтдельная панель автоматизации цикла аномалий, показывающая статус: сколько образцов в containment, сколько нужно для следующего шага, активна ли команда захвата.Автоматизация: экран сети автоматизации – отображаются построенные ServerFarm (и суммарные CU), а также все ядра.`nДля каждого ядра указано, к какому объекту оно прикреплено, его состояние (Active/Paused/Stalled), потребляемые ресурсы (энергия, CU).`nИгрок может отсюда переназначить ядро на другую цель, если свободны ресурсы.Экран экономики/суточного отчёта: отдельный UI, который открывается кнопкой.`nПоказывает баланс ресурсов за последний день: произведено/потреблено каждого ресурса, куда ушло (диаграммы или списки затрат, например, сколько на содержание, сколько на строительство и пр.), узкие места (например, “не хватило энергии, X отключений”, “нехватка еды, прирост населения снижался”).`nОтсюда же можно понять эффективность экономики, принять решения об изменении приоритетов.Панель процентов передачи ИИ: UI элемент с 5 слайдерами (Labor, Power, Materials, Food, Population Growth), устанавливающими долю, которая автоматически отдаётся гос-ИИ ежедневно.`nЕсть кнопка “Сброс к 0” или “По умолчанию”, выставляющая все 0%.`nСлайдеры доступны только для ресурсов, которые вообще генерируются (если, например, генерации материала нет – слайдер не активен).Строительное меню: улучшено фильтрами по типам зданий (экономические, военные, научные, инфраструктура).`nКаждое здание показывает требования (ресурсы, энергия, время), окупаемость или ROI (для экономических), ограничения по размещению.`nДобавлена индикация, если ресурс на постройку временно недоступен (например, не хватает энергии в сети – предупреждение).Логистика: окно управления перебросками – список всех активных приказов переброски.`nПо каждому показано: откуда и куда, тип/группа юнитов, прогресс (ETA или статус “в очереди”), приоритет.`nЕсть возможность ускорить конкретный приказ (галочка “Rush” – тратится больше ресурсов, пересчитывается ETA), либо приостановить/отменить.`nПри наведении на приказ на карте подсвечивается соответствующий маршрут и юниты.`nУзлы логистики на карте отображают значок, показывающий загруженность (цветом или проценты использования).Фортификации: при выборе инженеров появляются инструменты постройки: кнопка “Линия окопов” (после активации игрок рисует линию по земле), кнопка “Точка укрепления” (установка одиночного сооружения).`nUI показывает для текущего чертежа ожидаемую стоимость (в реальном времени, пока тянется линия или выбран тип), время строительства.`nПосле подтверждения заказ добавляется в очередь строительства фортификаций этого подразделения/армии.`nОчередь видна в UI (можно отменить задачи).`nТакже, при наведении на построенную фортификацию, отображается ее состояние (прочность, уровень защиты, остаток времени до износа для временных).6) Infrastructure (производительность, репозиторий, масштабирование)Чистые модели: Domain-сущности реализованы простыми C# классами/структурами (POCO), без наследования от UnityEngine.Object.`nЭто облегчает их сериализацию и тестирование.`nСтатические данные (конфиги) хранятся в ScriptableObject или JSON, а при запуске копируются в эти runtime-модели[7].`nБлагодаря этому, работа с данными не приводит к ненужным аллокациям или модификации ассетов на лету.Event System: для слабосвязанности используется глобальный EventBus (или посредник) – системы публикуют события, UI и другие части подписываются.`nЭто позволяет поддерживать off-screen симуляцию (события могут накапливаться и обрабатываться, когда объект вне поля зрения), а также упрощает сохранение (состояние можно сохранять, не беспокоясь о ненужных ссылках между системами – достаточно данных Domain).Performance Scaling: архитектура рассчитана на постепенное повышение производительности.`nНа начальном этапе логика может быть реализована на MonoBehaviour и обновляться на каждом тик; по мере роста нагрузки “горячие” участки (например, расчёт диффузии инфекции, генерация карт влияния, массовый поиск путей) переносятся на Jobs + Burst[2].`nПланируется использование DOTS (ECS) для наиболее тяжёлых подсистем (сетка заражения, массовые боевые объекты) – с фиксированным FixedStepSimulationSystemGroup для синхронизации с остальной игрой[2].`nВсе структурные изменения в ECS делаются через EntityCommandBuffer (однократное воспроизведение изменений в конце кадра)[34], чтобы избежать затратных sync-point’ов.Object Pooling: для частых появляющихся и исчезающих объектов (выстрелы, эффекты, маркеры на UI) применяется пуллинг – повторное использование экземпляров вместо уничтожения/создания[35].`nЭто особенно важно, если объекты загружаются через Addressables (Instantiate может быть медленным, но предзагрузка и повторное использование решает проблему).Tilemap оптимизация: для отрисовки большой карты используются Tilemap-слои.`nРекомендуется базовые слои тайлов (ландшафт) держать в режиме Chunk (крупные чанки, минимизирующие draw calls), а слои, между которыми проходят спрайты (юниты, эффекты) – в режиме Individual с использованием Sprite Atlas[36].`nЭто обеспечивает баланс между батчингом и правильным сортингом.`nВсегда проверять эффект настроек через Frame Debugger (Unity)[36].Profiling & Debug: команда начинает профилировать игру с самых ранних этапов разработки.`nУже на пустой сцене с Tilemap проводится тест производительности (сравнение режимов рендера тайлов)[37].`nВ ходе разработки на ключевых этапах делаются “контрольные точки” – замеры в Profiler и анализ Frame Debugger, чтобы отслеживать влияние новых систем[38].`nВ сборке для тестеров можно предусмотреть debug-меню с быстрыми переключателями оверлеев (показать тики, скорости, heatmap’ы влияния, пути AI и т.п.)[33][39].`nЭто ускоряет выявление проблем производительности и логики.Сетевая и DI-инфраструктура: (На будущее) Код организован по фиче-модулям (см.`nIntegration Hooks ниже).`nДля подключения зависимостей между подсистемами может использоваться простой Service Locator или DI-контейнер.`nНапример, Pathfinding-сервис, EventBus, SavingService регистрируются при старте и доступны всем системам.`nЭто снижает объем жёсткого подключения через инспектор и облегчает тестирование (можно подменять сервисы).7) Баланс и константы (первоначальный набор)p0 = 0.15%/day, p_max = 12%/day, α = 0.25 – базовые коэффициенты для расчёта шанса слияния (см.`nформулу p_merge выше).pRareBase = 8%, pRareMax = 40% – базовый и максимальный шансы выпадения редкого исследования; pAnomBase = 1% – базовый шанс аномального (ещё реже).Инфляция исследований: r_common = 0.12, r_rare = 0.14, r_anom = 0.15 – ставки удорожания шагов для каждого типа.`nПрименяются в формуле стоимости через (1+r)^i.ROI апгрейдов зданий: одно улучшенное здание должно давать прирост ≥, чем 2 базовых того же типа × коэффициент.`nДля категорий: Economy +10%, Military +15%, Science +30%, Containment +20%.`n(Напр., улучшенная электростанция должна давать хотя бы ~2.2× выход энергии относительно двух обычных).ServerFarm/Core: ServerFarm_T1 даёт 20 CU (compute units); одно AutomationCore потребляет 10 CU и ~2.5 MW энергии.Целочисленные расчёты: все ресурсы и их изменения хранятся целыми числами (без плавающих).`nДробные коэффициенты (например, прирост с процентами) рассчитываются с использованием фиксированной точки – умножаются ×1000 (для трёх знаков) и по завершении вычислений округляются вниз до целого.`nЭто гарантирует отсутствие расхождений и постепенного накопления ошибок, а также упрощает сохранение.Детерминированность: симуляционный цикл должен быть детерминированным при заданном сид генератора.`nВсе случайные события (роллы) идут от единого генератора со стартовым randomSeed, сохраняемого в сейве.`nЭто позволяет повторять сценарии (при отладке) и синхронизировать off-screen вычисления с on-screen результатами (например, автоматизация vs ручное управление дают идентичный итог с погрешностью ≤5%).8) План внедрения (5 спринтов: базовый + доп)Спринт 0 — Базовая структура и системы (первая 1–2 недели)Дни 1–2: Настройка проекта.`nСоздать базовые папки и пустую сцену.`nНастроить Tilemap (проверить режимы Chunk vs Individual для слоёв).`nРеализовать минимальный цикл SimulationLoop с поддержкой паузы, разных скоростей и шагового режима[11].`nДобавить базовые интерфейсы времени и событий (Clock, EventBus).`nТест производительности: подключить Unity Profiler и Frame Debugger сразу на этом этапе, убедиться, что пустая сцена рендерится оптимально (тайлы объединены в батчи, нет лишних draw calls)[37].Дни 3–5: Сделать начальные ScriptableObject каталоги: Units, Buildings, Techs, InfectionParams – заполнить парой примеров.`nНа их основе реализовать создание runtime-объектов (например, UnitType, BuildingType, TechDef, InfectionModel) при старте.`nРазработать EconomySystem v1: базовые классы ресурсов, ежедневный прирост и потребление (пока с упрощённой логикой).`nInfectionSystem v1: реализовать упрощённую SIR-модель на клеточной сетке (можно без диффузии, только подсчёт заражённых соседей).`nSaving v1: внедрить сохранение/загрузку в JSON, учитывая ограничения JsonUtility (избегать Dictionary, использовать [Serializable] классы)[40].`nДобавить SaveVersion = 1.`nEnd-to-end тест: запустить игру, подождать несколько тиков, сохранить, загрузить – убедиться, что состояние восстанавливается (юниты на тех же позициях, ресурсы не отрицательные и т.д.)[41].Дни 6–8: AI v1: внедрить 3–5 простых Utility-метрик (например, “угроза инфекции в стране”, “врагов на границе”, “ресурсов накоплено”) и простейший стратегический тикер, который каждые N тиков выводит в лог наиболее приоритетную цель.`nДобавить прототип Influence-карты для инфекции (float-поле на карте, обновляется от InfectionSystem) и расчет условной “линии фронта” (массив граничных клеток).`nObject Pool: подключить пул объектов (Unity ObjectPool<T>) для повторного использования хотя бы простых эффектов (например, маркеры заражения или пули)[42].Дни 9–10: AI v2: добавить GOAP-планировщик на 2–3 типа действий (например, “собрать ресурсы”, “построить турель”, “исследовать технологию X”) и пару узлов Behavior Tree для юнитов (патруль района, ремонт ближайшего здания).`nPathfinding v1: реализовать A* поиск пути на сетке, интегрировать Jump Point Search для ускорения на прямых участках[17].`nСделать API для пакетного запроса путей (список целей → список маршрутов), результаты которого можно получать асинхронно (корутина или Task).Дни 11–14: Оптимизация шаг 1: найти самые затратные места (ожидаемо InfectionSystem, InfluenceMap).`nРазбить их обновление на Jobs + Burst – например, расчёт диффузии инфекции через IJobParallelFor по частям сетки, генерация influence-карты – тоже параллельно[43].`nУбедиться, что Burst-компиляция работает (времено включить Native Debug Mode для отладки)[44].`nAddressables: перевести загрузку тяжёлых ресурсов (спрайты юнитов, текстуры) на Addressables, удостовериться в паре мест, что Release вызывается после выгрузки (память не растёт)[45].`nUI Dev-меню: добавить оверлей отображения текущей скорости/тикового индекса, heatmap заражения, простейшие кнопки быстрого вызова Profiler/FrameDebugger[39].`nЕсли по результатам профилирования узкие места остались, сделать POC на ECS: например, вынести InfectionSystem в ECS (FixedStepSimulation) для дальнейшего тестирования производительности параллельно основной реализации[46].(По итогу двух недель должен работать базовый каркас RTS: пауза, тик, примитивная экономика и инфекция, простые AI-решения, сохранения.`nДалее – внедрение расширенных механик дополняющих модулей.)Спринт 1 — Государства и видимость (1–1.5 недели)Что делаем: добавляем поддержку нескольких государств: создаём модели State/Relation/IntelLayer, интегрируем их в существующие системы (юниты теперь принадлежат государствам, экономики раздельны).`nРеализуем события и логику смены отношений (DiplomacySystem).`nДобавляем влияние уровня отношений на видимость: внедряем FoW (туман войны) на основе IntelLayer – враги не видны на карте без разведки или договорённостей.`nНастраиваем стартовый экран выбора государства игроком, базовый UI панели дипломатии (отображение отношений, кнопки предложить/разорвать).`nПроверяем EventBus-события при смене отношений.Готово, когда: AI-противники не видят чужие юниты/здания без соответствующих отношений; при уровне Embassy – видят юниты/постройки союзника, но не его ресурсы; при Alliance – видят всё, однако не могут управлять чужими юнитами.`nСохранение/загрузка включает состояния государств и их отношений, корректно восстанавливает IntelLayer.Спринт 2 — Слияние и экономика совместимости (1 неделя)Что делаем: реализуем формулу и процесс слияния государств: считаем p_merge каждый день для союзов, добавляем таймеры отсчёта дней в союзе, Stability, Strain.`nПри слиянии выполняем миграцию данных (территорий, юнитов, очередей) в коде DiplomacySystem.`nДорабатываем экономику под много-государственный режим: проверяем, что суточный тик учитывает раздельные бюджеты и транзакции между игроком и AI (процент отчисления).`nДелаем UI-событие для слияния (всплывающее окно с информацией).`nВнедряем механику дефицитов и приоритетов: настраиваем списки приоритетных расходов (см.`nDomain: содержание населения и войск прежде всего, и т.д.) и логику отключений/снижения, когда ресурс в минусе[47][48].Готово, когда: каждый день в союзе выполняется ролл слияния; повышенная Stability увеличивает шанс, а конфликты (Strain) уменьшают.`nПри наступлении события оба государства объединяются в одно, AI выбирается по правилу, экономика и войска объединены.`nСохранение после слияния корректно загружается (нет дублирования или пропажи объектов).`nВ экономической системе: при нехватке энергии происходит отключение низкоприоритетных потребителей, при голоде населения – падает прирост CivGrowth и могут происходить события (бунты) вместо немедленного краха экономики.`nВсе изменения отражаются в суточном отчёте.Спринт 3 — Исследования v2 (1.5 недели)Что делаем: перерабатываем систему исследований на основе ResearchProgress/Branch: теперь у каждой ветки есть только один текущий шаг (ResearchDef), видимый игроку.`nПосле завершения шага присваивается следующий на основе редкости: рассчитывается QualityScore от зданий науки, на его основе pRare (формула выше) – иногда выпадают Rare вместо обычных.`nДобавляем учёт аномалий: если Branch содержит аномальные исследования, они становятся доступны только при наличии специальных условий (построен ContainmentLab и есть активная CaptureTeam, а также накоплено N заражённых образцов).`nРеализуем апгрейды лабораторий: добавляем параметры RP (скорость) и QP (качество), влияющие на скорость прогресса и QualityScore соответственно.`nВ интерфейсе – обновляем экран исследований согласно новым правилам.Готово, когда: при завершении исследования ветки игрок видит новый доступный шаг; иногда вместо ожидаемого Common появляется Rare (с частотой в соответствии с качеством).`nБез построенной лаборатории содержания и отряда захвата все технологии с rarity = Anomalous помечены как недоступные (и в UI отображается, что нужны особые условия).`nЗначения ROI для научных апгрейдов соблюдаются (например, Lab_T2 даёт ~2.2× RP относительно Lab_T1), QualityScore влияет на шанс редких технологий.`nБаланс проверен: стоимость исследований монотонно растёт, редкие не выскакивают слишком часто.Спринт 4 — Аномалии и Автоматизация (1.5 недели)Что делаем: добавляем в игру новый тип зданий и юнитов для работы с аномалиями: лаборатория содержания заражённых (ContainmentLab) и команда захвата (CaptureTeam).`nПри наличии этих объектов появляются аномальные исследования (ветки типа "anomaly.").`nРеализуем механику расхода образцов: каждое исследование аномалии требует определённое количество заражённых образцов; образцы попадают в ContainmentLab, когда CaptureTeam успешно выполнит миссию (можно упростить: раз в N дней команда добывает M образцов, если рядом есть заражённый сектор).`nНастраиваем события Breach – если накоплено слишком много образцов или отключилась энергия, есть шанс побега/утечки (событие, влияющее на заражение вокруг).`nАвтоматизация: вводим здания ServerFarm (дают ComputeUnits) и объекты AutomationCore.`nРеализуем AutomationSystem, позволяющий привязать ядро к конкретному процессу (через интерфейс IAutomatable – например, к конкретной ветке исследований или отряду CaptureTeam).`nЯдро автоматически вызывает методы Start/CompleteStep у цели, имитируя игрока.`nВ интерфейсе – экран автоматизации сети.`nOff-screen симуляция: убеждаемся, что автоматизированные процессы дают тот же результат, что и ручные, при перемотке (погрешность не более 5%).`nОптимизируем нагрузку: automation tick происходит раз в несколько кадров, если объектов много.Готово, когда:* цикл “поимка → доставка → исследование” работает в игре.`nИгрок может вручную отправлять CaptureTeam, получать образцы и тратить их на исследования аномалий.`nПри установке ядра автоматизации на CaptureTeam и на лабораторию, цикл выполняется без вмешательства игрока (пока хватает энергии и CU).`nЕсли энергия или вычислительные мощности заканчиваются, ядро ставит процесс на паузу (UI показывает статус Stalled).`nИнтерфейс автоматизации позволяет отслеживать все ядра и их цели.`nOff-screen тест: если запустить игру на x10 скорости с автоматизацией и сравнить с пошаговым выполнением тех же действий, итоги совпадают (например, за 30 дней собрали X образцов и выучили технологию Y в обоих случаях ±5%).(После этих спринтов все новые механики интегрированы.`nДалее – полировка, тестирование, баланс.)9) Тест-план и инвариантыДипломатия/Intel: убедиться, что без отношений AI имеет нулевое знание о другом (при отладке – списки KnownUnits пусты).`nПри Embassy – AI видит юниты/постройки союзника (проверить, что KnownUnits/Buildings заполняются), но не видит его Economy (KnownEconomy = null).`nПри Alliance – KnownEconomy не null, доступны очереди.`nКонтроль юнитов остаётся раздельным: попытка AI приказать юниту игрока игнорируется.Слияние: проверить детерминизм – при фиксированном сид и условиях слияние происходит на той же день с тем же вероятностным исходом.`nПосле слияния все юниты поглощённого гос-ва имеют новый StateId, все его постройки и территории также переключились.`nAI продолжает работать (не теряет контроль).`nСохранение сразу после слияния и загрузка – состояние объединённого государства корректно (нет дубликатов юнитов, ресурсы суммированы).Экономика/Ресурсы: инвариант баланса ресурсов – ресурсы не возникают из воздуха и не уходят в отрицательные: суммарный приход-расход за любой период ≥ 0.`nНаписать unit-тесты на методы экономического резерва: Reserve не изменяет баланс при попытке зарезервировать, Commit списывает и сумма всех Commit равна сумме Reserve (деньги не исчезают)[49].`nСмоделировать 100 суточных тиков с хаотичными тратами гос-ИИ и игрока – проверить, что итоговые балансы предсказуемы и не отрицательны.`nДефицит-тест: установить потребление энергии выше генерации – убедиться, что сначала отключаются низкоприоритетные здания, и ни одно потребление не продолжает расти, когда ресурс 0.`nАналогично для еды – при 0 еды прирост CivGrowth падает к 0, начинаются события (бунты) если держать долго.Логистика: тест “Логистический пик” – задать множество перебросок по одному узкому коридору, убедиться, что они выстраиваются в очередь, суммарно не превышают capacityUnitsPerDay[4], ETA рассчитывается с учётом ожидания.`nПри отключении режима Rush все прибывают в срок T, при включении Rush у некоторых – быстрее, но списались дополнительные материалы/энергия.`nРазрушить узел на пути – проверить, что существующие приказы перенаправляются (или выдают предупреждение “маршрут недоступен”).Фортификации: проверить, что временные укрепления теряют прочность со временем (смоделировать 30 дней, убедиться, что параметр cover снижается у окопа).`nПостоянные – не снижаются (или гораздо медленнее).`nСтроительство: разместить длинную линию траншеи длиной L, послать 2 инженерных отряда – убедиться, что задача разделилась (каждый строит свой участок)[50] и общее время ~ равно L / (сумма скоростей).`nПопробовать улучшить временную позицию до постоянной – затраченные ранее трудо-часы учтены (например, если окоп был наполовину достроен до бункера, то на бункер осталось 50%).Исследования: проверить рост стоимости – завершить несколько шагов подряд, убедиться, что новый CostMultiplier вырос по формуле.`nРедкие исследования выпадают приблизительно с заданной частотой: можно выполнить 100 шагов при высоком QualityScore и подсчитать долю Rare – она должна быть близка к рассчитанному pRare (например, при QS, дающем 20% шанс, из 100 исследований ~20 оказались Rare).`nШанс не показывается в UI напрямую – убедиться, что нигде не раскрывается игроку точное число (только описания).Аномалии: без ContainmentLab и CaptureTeam все Anomalous-технологии недоступны (в UI – серые, с пометкой о требовании).`nПри наличии инфраструктуры – становятся исследуемыми.`nПроверить, что при начале исследования аномалии списываются требуемые образцы (и что их надо предварительно накопить).`nИнцидент-тест: хранить много образцов (больше capacity) и отключить лаборатории – должен сработать event Breach (можно подкрутить вероятность для теста).`nПосле Breach – infection в секторе вырос, событие записано.Автоматизация: убедиться, что AutomationCore не может быть прикреплено более чем к одной цели одновременно.`nПопробовать назначить два ядра на одну цель – второе должно отказать (или заменить первое – определиться в дизайне, но нельзя дублировать эффект).`nПроверить, что при нехватке энергии или CU процесс ставится на паузу: имитировать отключение энергии – AutomationCore генерирует событие CoreStalled, цель ничего не делает до возобновления.`nСравнить результат длительного процесса (например, исследований) с ядром и без – за равный промежуток (например, 10 дней перемотки) разница ≤5%.Производительность: запустить масштабный сценарий: большая карта, 1000+ юнитов, десятки построек, активная инфекция.`nПроверить в Profiler использование CPU: SimulationLoop не превышает допустимые 16ms на кадр (при необходимости снизить частоту тиков для некоторых систем).`nПамять: сделать несколько циклов загрузки-выгрузки сцены – убедиться, что нет утечек (Addressables все освобождены, объекты уничтожены).`nПрофтест на pathfinding: вызвать 100 одновременных поисков пути (например, по логистике) – время должно масштабироваться под строку (если слишком долго, задуматься о дроблении на несколько кадров).10) Риски и мерыСложность UI (дипломатия, исследования): риск перегрузить игрока информацией.`nМеры: начинаем с простого интерфейса “одна карточка на ветку” для исследований и упрощённой панели дипломатии.`nПостепенно усложняем, если нужно, ориентируясь на отзывы.`nДобавляем лог событий, чтобы игрок мог отслеживать скрытые процессы.Баланс вероятностей: вероятность слияния и выпадения редких технологий трудно подбирается “на глаз”.`nМеры: встроить телеметрию – собирать статистику по частоте слияний и редких технологий.`nИметь возможность в патче легко изменить p_max, pRareMax и др.`nОграничить сверху экстремальные значения (например, даже при супер-качестве pRareMax = 40%, не 100%).Фризы при слиянии: объединение государств – тяжёлый процесс (много объектов перемещается за один кадр).`nМеры: реализовать пошаговую миграцию (например, переносить не более N юнитов за кадр, растягивая процесс на несколько кадров, с красивой анимацией).`nИспользовать корутины или ECS-команды с разбиением.Эксплойт редкости исследований: игрок может пытаться манипулировать QualityScore (например, отключать/включать лаборатории) чтобы повысить шанс Rare.`nМеры: QualityScore рассчитывается по накопленным показателям и сглаженно, не давая резко поднять шанс.`nШанс редкого всегда скрыт, а при резком росте качества можно ввести кулдаун на выпадение Rare (например, не чаще чем 1 раз в 3 шага).Дисбаланс ресурсов и войны: есть риск, что экономика станет слишком сложной и отвлечёт от военной части, или наоборот, война сделает экономику неважной.`nМеры: настроить коэффициенты ROI так, чтобы без минимальной экономики войну не выиграть (нужно снабжение), а без побед в боях экономика быстро попадёт под удар.`nВвести события типа “беженцы” или “мобилизация”, связывающие военные успехи и экономику (например, большие потери снижают Stability и CivGrowth).`nОтслеживать метрики узких мест: если игроку постоянно не хватает какого-то ресурса, подсказать через UI, какую постройку или действие сделать.Производительность на масштабах: сотни юнитов, infection на всю карту, расчёт путей – всё это может превысить возможности CPU.`nМеры: активно использовать оптимизации: влияние – инкрементно, infection – обновление только фронта, pathfinding – иерархический и batched, тяжелые вычисления выносить в Jobs/Burst.`nПредусмотреть настройки масштаба: например, на большой карте стратегические тики реже, максимум N юнитов одновременно активно сражаются (остальные “спят” вне экрана), возможность понижения качества симуляции (LOD) для фоновый действий.11) Hooks интеграции (структура кода)/Game/Domain/States/*.cs          // State, Relation, IntelLayer (дипломатия, видимость)/Game/Domain/Research/*.cs        // ResearchProgress, Branch, ResearchDef (ветки исследований, редкости)/Game/Domain/Anomaly/*.cs         // Anomaly & Containment (образцы, события Breach)/Game/Domain/Automation/*.cs      // AutomationNetwork, AutomationCore, IAutomatable/Game/Domain/Economy/*.cs         // EconomyModel, Resource, Budget, Contracts (экономика и бюджеты)/Game/Domain/Infection/*.cs       // InfectionModel, InfectionCell, Quarantine (заражение и карантины)/Game/Domain/Logistics/*.cs       // LogisticNode, LogisticLink, TransferOrder (узлы и коридоры снабжения)/Game/Domain/Fortification/*.cs   // Fortification definitions, construction task (полевые укрепления)/Game/Application/Systems/*.cs    // DiplomacySystem, MergeSystem, ResearchSystemV2, AutomationSystem,                                 // EconomySystem (daily tick), InfectionSystem, LogisticsSystem, FortificationSystem/Game/AI/Strategic/*.cs           // DiplomacyPlanner, MergeDecider, StrategicPlanner (Utility AI), GoalPlanner (GOAP)/Game/AI/Tactical/*.cs            // BehaviorTrees, UnitAI (поведение отдельных юнитов)/Game/Presentation/UI/*.cs        // UI дипломatii, экран исследований, панель автоматизации, экономика/логистика UI/Game/Data/Defs/*.asset           // SO каталоги: StateDefs, ResearchDefs, BuildingDefs, UnitDefs, InfectionParams, RecipeDefs, FortificationDefs .../Game/Infrastructure/Saving/*.cs  // SaveManager, SaveMigrator (обработка SaveVersion)/Game/Infrastructure/Pathfinding/*.cs // Pathfinding service (A*, JPS, HPA* algorithms)Примечание: архитектурные слои разделены по папкам.`nDomain содержит логику и модели; Application – системы, управляющие этими моделями; AI – алгоритмы принятия решений; Presentation – MonoBehaviour-скрипты для UI и визуалов; Data – скриптабл-объекты и конфиги; Infrastructure – утилиты сохранения, загрузки, внешние сервисы.`nТакой organization облегчает навигацию и поддержку кода, а также подключение/отключение модулей (например, можно модульно тестировать Domain-логику, подменяя Application-слой).Приложение A — Псевдокод выбора следующего исследованияvoid CompleteResearchStep(State s, string branchId) {    var branch = s.Research.Branches[branchId];    var def = branch.Current;    // Mark current step as completed:    branch.Completed += 1;    s.Research.TotalSteps += 1;    ApplyEffects(def); // применить эффекты технологии (если есть)    // Calculate new cost multiplier due to inflation:    float r = GetInflationRate(def.Rarity);    s.Research.CostMultiplier = Mathf.Pow(1 + r, s.Research.TotalSteps);    // Determine next step:    float QS = s.Research.QualityScore;    float pRare = Mathf.Clamp(pRareBase + alpha * QS, 0, pRareMax);    ResearchDef next;    if (def.Rarity == ResearchRarity.Anomalous) {        // Anomalous branch might end or loop differently        next = null; // (можно предусмотреть конец ветки после аномалии)    } else if (Random.value < pRare) {        next = PickRandom(def.BranchId, rarity: Rare, excludeCompleted:true);    } else {        next = PickRandom(def.BranchId, rarity: Common, excludeCompleted:true);    }    // If Anomalous possible:    float pAnom = CalcAnomalyChance(QS, s.AnomalyStats);    if (next == null && Random.value < pAnom && AllAssetsPresent(def.BranchId)) {        next = GetAnomalousDef(def.BranchId);    }    branch.Current = next;    EventBus.Publish(new Research.NextStepAssigned(s.Id, branchId, next?.Id, next?.Rarity));}(Этот псевдокод иллюстрирует логику прогрессии исследований: инфляция стоимости, выбор следующего шага с учётом QualityScore и доступности аномальных технологий.)[1] [2] [3] [5] [6] [7] [8] [10] [11] [16] [20] [21] [26] [27] [28] [29] [31] [32] [34] [35] [36] [37] [38] [40] [41] [42] [43] [45] [46] document-2.txtfile://file_000000007c6861f4aefcba665986a990[4] [47] [48] [50] document-4.txtfile://file_0000000049b062438e06b107048784b7[9] [14] [22] [23] [24] [25] ADDON_STATES_RESEARCH_AUTOMATION_PLAN.mdfile://file_0000000014b86246bd27d0391214fa20[12] [13] [15] [17] [18] [19] [30] [33] [39] [44] [49] document-3.txtfile://file_000000001f0461f4847b90af8dfa8700

## Государства (States) — Структурированный раздел

Цель
- Ввести сущности государств/фракций, владение территориями и крючки для прогрессии, влияющие на дипломатию/экономику/исследования.

Данные
- ScriptableObject (позже): `StateDef { id:string, title:string }`
- JSON (пример):
```json
{
  "states": [
    { "id": "player", "title": "Игрок" },
    { "id": "red",    "title": "Красные" },
    { "id": "blue",   "title": "Синие" }
  ],
  "relations": [
    { "a": "player", "b": "red",  "kind": "Hostile",  "stability": 0.2 },
    { "a": "player", "b": "blue", "kind": "None",     "stability": 0.0 }
  ]
}
```

Ключевые сущности
- `StateId` (строка), `StateDef` (данные), `Ownership` (владение регионом/тайлом), `RelationKind` (Hostile/Neutral/Ally), `stability` (0..1).

Игровая логика (минимум)
- Владение: запрос владельца, смена владельца, события при смене (для UI/AI/экономики).
- Слияния: `Merge(a,b) -> newState` (перенос отношений и владений).
- Влияние на прогрессию: ограничения/бонусы на исследования, экономику, спавн аномалий.

События (EventBus, план)
- `States/OwnerChanged(regionId, oldState, newState)`
- `States/Merged(newStateId, absorbedStateId)`
- `Diplomacy/RelationsChanged(stateA, stateB, kind)` (см. раздел «Дипломатия»)

UI (минимум)
- Панель «Государства»: список фракций, отношение к игроку, кнопки «детали/договоры».

Технические заметки
- Хранение отношений — разреженная структура (ключ `a-b` нормализованная пара).
- Встроить в Save/Load: версия схемы, миграции через `SaveVersion`.

DoD (минимум)
- Запрос владельца и смена владельца работают; события публикуются; UI отражает изменения.

Ссылки
- Быстрый навигатор: docs/ADDON_GUIDE.md
- Оригинальный материал данного файла — ниже.
