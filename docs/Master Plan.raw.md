# Master Plan: 2D RTS (Unity)

Автоматически собранный консолидированный документ на основе всех материалов. Источник: docs/*.md

## Contents
- [1) Solution / namespaces](#1-solution-namespaces)
- [Тайминг/пауза/фикс-тик — 3 варианта](#таймингпаузафикс-тик-3-варианта)
- [Дополнение к плану разработки игры: Экономика, логистика и фортификации](#дополнение-к-плану-разработки-игры-экономика-логистика-и-фортификации)
- [document](#document)
- [Квартальный план разработки RTS-проекта (Unity 2D) для начинающего](#квартальный-план-разработки-rts-проекта-unity-2d-для-начинающего)
- [План разработки RTS-проекта (Unity 2D) – Полный Production Pipeline](#план-разработки-rts-проекта-unity-2d-полный-production-pipeline)
- [Финальный технический план проекта (2D RTS на Unity)](#финальный-технический-план-проекта-2d-rts-на-unity)

## Near-Term (2–4 Weeks)

См. выделенные ближайшие задачи: NEAR_TERM.md


## 1) Solution / namespaces
Источник: document-2.md

Отличный скелет! Ниже — расширения по каждому пункту: больше механик (геймдизайн) и больше «куда копать» по производительности (Unity/С#). Я пишу краткими блоками «Что добавить» → «Как ускорить», чтобы это сразу можно превращать в задачи.

## 1) Solution / namespaces
**Что добавить (механики):**
- `Domain/Economy`: разнести потоки «гос-ВВП» и «игрок-ВВП» на отдельные подсистемы (налоги, приоритеты госзаказа, субсидии игроку, проценты по займам, лимиты капекса/опекса). Ввести «контракты» (Build/Research/Quarantine) как сущности с жизненным циклом и штрафами за срыв.
- `Domain/Infection`: слои данных — «уровень заражения», «плотность населения», «мобильность», «санитарные кордоны», «транспортные коридоры».
- `Application/Pathfinding`: выделить слой навигационных графов в сетке (округа/регионы/горлышки, chokepoints) для тактики и ГОС-ИИ.
- `AI/Perception`: кеши влияния (influence maps) и карт давления по фронту, чтобы Utility-оценки читали готовые поля.
- `Infrastructure`: абстракция сохранений (json/binary) + версия состояния.

**Как ускорить:**
- «Тёплые» модели в рантайме = чистые C# классы, а ScriptableObject — только каталоги/дефы, без мутации на лету (модификации SO в рантайме ведут к путанице; лучше инстансить runtime-копии) citeturn0search7turn0search15.
- Для тяжёлых циклов готовьте переход на Jobs + Burst и/или Entities (DOTS) по «горячим» системам (инфекция, массовое сканирование). Используйте `NativeArray` и `[BurstCompile]` для джобов — это базовая дорожка к масштабированию citeturn0search1turn0search6turn6search14.
- Структурные изменения в ECS (создание/уничтожение сущностей) всегда через `EntityCommandBuffer` и фиксированный «replay» — так вы избегаете множества sync-point’ов в кадре citeturn0search4turn0search8.

## 2) Тайминг, пауза, фиксированный тик
**Что добавить (механики):**
- Режимы скорости: ×0.5 / ×1 / ×2 / ×4 для симуляции; стратегический ИИ тикает реже (например, 1 раз в 0.5–1 сек), тактический — каждый тик.
- «Жёсткая пауза»: симуляция стоит, UI/анимации UI — живут на `unscaledDeltaTime`.  
- Кнопка «пошагово»: один «шаг тика» по фикс-циклу.

**Как ускорить:**
- Собственный `SimulationLoop` с аккумулятором на `Time.unscaledDeltaTime` (чтобы пауза через `timeScale` не ломала таймеры UI). Если перейдёте в Entities — используйте `FixedStepSimulationSystemGroup` для фиксации шага «из коробки» citeturn0search5.
- Если решите паузить через `Time.timeScale=0`, используйте `unscaledDeltaTime` для UI/меню и анимаций (Animator в Unscaled Mode) — это каноничный паттерн в Unity citeturn5search2turn5search1.

## 3) Данные и конфиги
**Что добавить (механики):**
- «Каталоги» (SO) для юнитов/зданий/технологий/параметров инфекции; на старте — сборка runtime-объектов (иммутабельных где можно).
- Версионирование сохранений: `SaveVersion`, миграции при загрузке.

**Как ускорить:**
- Json для сейвов: помните ограничения `JsonUtility` (нет `Dictionary`, только сериализуемые поля; без полиморфизма) — планируйте структуры под эти ограничения или используйте адаптеры/обёртки citeturn2search0turn2search3turn2search6.
- Для ассетов — Addressables с дисциплиной `Load/Release` (зеркалить выгрузки, иначе «висящие» ассеты в памяти) citeturn2search10.

## 4) Экономика (двойное ВВП)
**Что добавить (механики):**
- Гос-бюджет: приоритеты (оборона/карантины/базовые исследования/логистика), авто-перераспределение по Utility-скорам.
- Игрок-бюджет: «точечные» заказы (щитовые технологии, укрепления, команды быстрого реагирования), краткосрочные займы под проценты.
- «Контракты» с KPI и штрафами: если ГОС-ИИ не удержал линию, часть гос-ВВП уходит на компенсации.

**Как ускорить:**
- Обновлять экономику реже: например, раз в N тиков; все метрики кешировать и пересчитывать инкрементально (diff-подход).

## 5) Инфекция (модель)
**Что добавить (механики):**
- Выберите основу: SIR/SEIR-подобная модель + клеточный автомат (диффузия по соседям Moore/Von Neumann), усиленная влиянием инфраструктуры (кордоны, турели, «санпункты») и транспортом. Это реалистично и объяснимо дизайнерски (SIR как канон) citeturn4search0.
- «Очаги» и «фронт»: ячейки с ростом выше порога образуют фронт; ГОС-ИИ держит фронт (линию), игрок финансирует «прорывы».
- Карантинные зоны: снижают мобильность/вероятность заражения, но режут производство.

**Как ускорить:**
- Обновлять **только активные** клетки (frontier set): поддерживать списки «грязных» ячеек вместо полного прохода сетки.
- Разнести шаги: (1) сбор влияний соседей; (2) применение (double-buffer). В Jobs использовать `IJobParallelFor` по чанкам сетки + `NativeArray<float>`; потом — Burst.
- Если пойдёте в ECS, запустите диффузию в `FixedStepSimulationSystemGroup` и храните поля как плотные массивы компонентов.  
- Ссылки по соседствам Moore/Neumann — классика для CA (общее описание) citeturn4search9.

## 6) ИИ: стратегический + тактический (Utility + GOAP + BT)
**Что добавить (механики):**
- **Utility AI**: скоринг целей «сдержать очаг», «закрыть горлышко», «исследовать X», «поддержать игрока» — нормированные функции 0..1.  
- **GOAP** для плана под выбранную цель (собирать ресурсы → исследовать «Щит-I» → построить 3 турели на дуге X). Классический референс — F.E.A.R. (Jeff Orkin) citeturn1search0.
- **Behavior Trees**: микротактика (патруль/ремонт/перехват).  
- **Influence Maps** для восприятия (давление врага/укрепления/коридоры) — легка в объяснении и богата на эвристики citeturn1search1.

**Как ускорить:**
- Тикайте стратегию разреженно (каждые N тиков), тактику — чаще; Utility-оценки разбивайте по кадрам (budgeted AI).  
- Влияния считать инкрементально и «по кольцам» от изменений; хранить как тайловые поля (float) в `NativeArray` и обновлять через Jobs.
- Планирование ограничивать по глубине/времени; кэшировать краткие планы; spatial-кеш (chokepoints/регионы) обновлять только при перестройке карты.

## 7) События, команды, сохранения
**Что добавить (механики):**
- Команды с откатом (строительство, приказ, финансирование) → лог в буфере за тик; сохранение после «безопасных» тик-барьеров.
- События «coalesce»: однородные события склеивать (например, «инфекция выросла в 50 клетках» → один батч).

**Как ускорить:**
- В ECS — структурные изменения (создание/удаление) только через `EntityCommandBuffer` и единичный playback в конце фазы (минимум sync-points) citeturn0search8.
- В классическом подходе — кольцевой буфер событий и пакетная обработка/флаш по концу тика.

## 8) Производительность и масштабирование
**Что добавить (ориентиры):**
- Эскалация: MonoBehaviour → Jobs+Burst на горячие циклы → DOTS/Entities на подсистемы «сетка/инфекция/массовая тактика».
- Пуллинг для частых объектов (снаряды, эффекты, маркеры UI), особенно если Addressables (медленнее Instantiate, но без лагов на главном потоке) citeturn6search6turn6search0.
- Tilemap: для базовых слоёв включайте **Chunk** рендер (меньше draw calls), а где нужен «прослой» спрайтов — **Individual** + Sprite Atlas для сортинга. Используйте профайлер/фрейм-дебаггер, чтобы подтверждать выигрыш на вашей сцене citeturn3search13turn3search0turn3search1.

**Как ускорить (конкретика):**
- Jobs/Burst: переносить диффузию, генерацию influence-карт, массовые сканы и агрегаты. Это и есть типовые «приятные» задачи для C# Job System + Burst citeturn0search1.
- В Entities — фиксированный сим-шаг через `FixedStepSimulationSystemGroup` и пайплайн «Sample → Decide → Apply». Фикс-шаг официально поддерживается и используется в DOTS-Physics citeturn0search5turn0search21.
- Адресация ассетов: строгий `Load/Release` и групповые политики в Addressables — это дисциплина памяти и времени загрузки citeturn2search16turn2search10.

## 9) Путь юнита (Pathfinding) на сетке
**Что добавить (механики):**
- Иерархическая навигация: **HPA*** (кластеризация сетки + абстрактные узлы) даёт резкое ускорение на больших картах; внутри кластера — A*/JPS citeturn1search2turn1search6.
- **Jump Point Search** (симметрия на равномерной сетке) как ускоритель A* без препроцессинга; есть улучшения JPS+ citeturn1search3turn1search11.
- «Полевые» маршруты: после пути — сглаживание (string-pulling), запреты на проход через заражённые «красные» зоны.

**Как ускорить:**
- Асинхронный поиск в Jobs (batch запросов); при длинных путях — навигация по «маяк-точкам» (portals) из HPA*.
- Инвалидации частичные: при строительстве/карантине — метить только затронутые кластеры/рёбра.
- Кеш популярных пар «регион→регион» и кратчайших «коридоров».

## 10) 2 недели старта — усиленная версия (план)
**Дни 1–2**  
— Папки/пустая сцена/Tilemap; `SimulationLoop` + пауза/скорости; базовые интерфейсы Clock/EventBus.  
— Тест производительности: подключите **Profiler** и **Frame Debugger** сразу, чтобы видеть стоимость тайлов/отрисовки и подтвердить режимы Tilemap (Chunk/Individual) citeturn3search11turn3search3.

**Дни 3–5**  
— SO-дефы (Units/Buildings/Techs/InfectionParams) → runtime-модели; EconomySystem v1; InfectionSystem v1 (SIR-подобный CA с Moore/Neumann).  
— Сохранения: JSON (учесть ограничения `JsonUtility`), версия сейва; e2e-тест: старт → пауза → ×2 → сейв/лоад citeturn2search0.

**Дни 6–8**  
— Utility-скоры (3–5 штук) + простейший стратегический тикер; Influence-карта заражения (float-поле) и «линия фронта».  
— Пул объектов для визуальных маркеров/снарядов (Unity `ObjectPool<T>`) citeturn6search6.

**Дни 9–10**  
— GOAP-планер (2–3 действия) + BT-узлы для патруля/ремонта.  
— Pathfinding: A* → включить JPS; API для пакетного поиска.

**Дни 11–14**  
— Разрезание тяжёлых шагов на Jobs + Burst (диффузия, influence); Addressables для тяжёлых спрайтов (строгий `Release`).  
— UI скоростей/оверлеев, горячие профилировочные сценарии (толстая карта/много огня/массовый поиск).  
— Если «горячо» — POC на Entities для диффузии инфекции в `FixedStepSimulationSystemGroup` (параллельно основной ветке) citeturn0search5.

---

### Короткие доп-подсказки
- **Tilemap**: базовые слои — `Chunk` (дёшево по draw calls); слои, между которыми должны «проходить» спрайты, — `Individual` + Sprite Atlas для корректного сортинга и батчинга citeturn3search13turn3search0.  
- **Profiler/Frame Debugger** — ставьте «контрольные точки» прогресса, иначе оптимизировать будет нечего измерять citeturn3search11turn3search1.  
- **Jobs/Burst**: храните сетку/поля в `NativeArray<float>`; Burst не дружит с управляемыми массивами — это нормально, так задумано citeturn6search20.  
- **Addressables**: «зеркальте» загрузки выгрузками (иначе память распухает), группируйте по способам загрузки/частоте использования citeturn2search10turn2search16.

Если хочешь, я разверну один выбранный блок (например, InfectionSystem или Utility AI) в полноценный «технический дизайн + псевдокод + план тестов».



## Тайминг/пауза/фикс-тик — 3 варианта
Источник: document-3.md

Оба файла прочитал целиком (архплан и расширения). Ниже — «джуниор-пайплайны» дебага для каждого из предложенных в них вариантов/подсистем. Формат: что проверить, как воспроизвести, чем измерить, что логировать, где часто ошибаются.

---

## Тайминг/пауза/фикс-тик — 3 варианта

### A) Свой `SimulationLoop` (accumulator + fixed tick)
**Шаги дебага (джуниор):**
1) Включи визуальный индикатор тика: раз в тик увеличивай `tickIndex` и показывай в углу UI. Так поймёшь: тики не «пропускаются/скачут».  
2) Логи порядка вызовов: в начале каждого тика логируй `TickStart(t)`, затем `Infection/Economy/AI`, в конце — `EventBus.Flush()`. Смотри, что порядок стабилен.  
3) Пауза: проверь, что `Update()` выходится раньше накопления (`if (IsPaused) return;`) и что UI анимации используют `unscaledDeltaTime`.  
4) «Пошагово»: кнопка «Step» вызывает ровно один проход `while (acc>=tick)`. Сделай `Assert` на «не более одного шага при Step».  
5) Тест на дрожание тика: резко меняй FPS (включить VSync/выключить) — тиковая частота должна оставаться постоянной.  
6) Профилирование: `Window → Analysis → Profiler` (Ctrl+7) и треки `Scripts`/`UI`. Смотри консистентное время тика, нет ли всплесков по GC. citeturn0search12

**Частые баги:** неправильно сбрасывают `acc` в цикле `while`, не отделили сим-время от UI-времени, забыли вызывать `EventBus.Flush()` в конце тика.

### B) Глобальная пауза через `Time.timeScale = 0`
**Шаги дебага:**
1) Убедись, что всё, что должно жить на паузе (UI/анимации меню), переведено на `Unscaled Time`: `Animator.Update Mode = Unscaled Time`; таймеры — через `unscaledDeltaTime`/`WaitForSecondsRealtime`. citeturn0search7turn0search10turn0search18  
2) Проверь корутины: замени `WaitForSeconds` на `WaitForSecondsRealtime` в UI-логике.  
3) Визуальный тест: при `timeScale=0` счётчик «тиков симуляции» не меняется, счётчик «кадров UI» — идёт.  
4) Профайлер: фильтруй по категориям `Animation`/`UI`. Убедись, что игровой код «молчит», а UI продолжает обновляться. citeturn0search12

**Частые баги:** «замерзшие» анимации UI (Animator в Normal), таймеры на `deltaTime`, а не `unscaledDeltaTime`.

### C) DOTS/Entities: `FixedStepSimulationSystemGroup`
**Шаги дебага:**
1) Открой список систем и проверь, что «горячие» системы помечены `[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]` и действительно тикают фикс-шагом. citeturn0search2  
2) Убедись, что шаг соответствует ожиданию (по умолчанию ~1/60 сек, меняется в группе); проверь настройку и фактическую частоту в Profiler (раздел `Entities`). citeturn0search6turn0search21  
3) Структурные изменения (создание/удаление сущностей) — только через `EntityCommandBuffer` (ECB) и один playback в конце фазы. Проверяй, что нигде нет прямых `EntityManager.Add/Remove` из job’ов. citeturn1search6turn1search3  
4) Если что-то «тикает не там»: проверь порядок групп (`Initialization/Simulation/FixedStepSimulation/Presentation`) и атрибуты систем. citeturn0search13

**Частые баги:** смешивают фикс-шаг и «нормальные» системы, делают структурные изменения прямо из job’ов (без ECB), не понимают, почему фикс-шаг не равен `Time.fixedDeltaTime` проекта. citeturn0search17

---

## Данные/конфиги/сейвы (ScriptableObject → runtime + JSON)

**Проверки:**
1) **SO не мутируем в рантайме.** На старте делай runtime-копию (POCO) и работай только с ней. Добавь `Assert(!Application.isPlaying || !AssetDatabase.Contains(obj))` в редакторских проверках/в тестах.  
2) **JsonUtility ограничения.** Проверь, что в моделях для сейва нет `Dictionary<>`/полиморфных полей без `SerializeReference`; JsonUtility — «структурный» JSON. Если нужен `Dictionary` или явный полиморфизм — либо адаптер, либо сторонний JSON. citeturn0search19turn0search8  
3) Если используешь `SerializeReference` для полиморфизма — проверь в простом юнит-тесте, что `JsonUtility.ToJson/FromJson` корректно восстанавливает подтипы. citeturn0search15  
4) **Версия сейва.** В JSON добавь `SaveVersion`; при загрузке — миграция по свитчу.

**Addressables (память):**
— Зеркаль `Load` и `Release`. Дебаг: счётчики «загружено/выгружено», лог по каждому handle; профилировщик памяти до/после экрана. citeturn1search10

---

## Экономика (двойное ВВП)

**Проверки/тесты:**
1) Unit-тесты на инварианты кошельков: `TryReserve` не меняет баланс, `Commit` — уменьшает; суммы транзакций сходятся в 0 («деньги не исчезают/не появляются»).  
2) «Дымовые» интеграционные тесты: 100 тиков, хаотичные расходы гос-ИИ и игрока → итоговые балансы предсказуемы.  
3) Логируй причины отказов: `[Economy] ReserveFail: amount, balance, who`.  
4) Стресс: умножь частоту вызовов (×10), проверь, что нет дрожания приоритетов.

---

## Инфекция (SIR/SEIR + клеточный автомат)

**Проверки:**
1) Подтверди «физику»: SIR/SEIR корректно двигает «S→I→R», параметры адекватны. citeturn4search0  
2) Соседство ячеек: Moore/Neumann — выбери и зафиксируй. Визуально подсвети соседей выбранной клетки (gizmos). citeturn4search1  
3) Двойной буфер: на каждом тике читаем из `gridA`, пишем в `gridB`, потом своп — тест «значение не затирается в середине цикла».  
4) «Frontier-update»: собирай список активных клеток и обновляй только их; логируй размер фронта и время шага.  
5) UI-оверлей тепловой карты: помогает «глазом» ловить скачки/застои.

**Производительность:**
— Вынеси диффузию/агрегации в Jobs + Burst, держи поля в `NativeArray<float>`. Для дебага Burst: включай `Jobs → Burst → Native Debug Mode Compilation` временно, либо `Debug = true` у конкретного job. citeturn1search11

---

## ИИ: Utility AI + GOAP + Behavior Trees

**Проверки Utility:**
1) Печатай таблицу скорингов 0..1 по целям каждый N-тик (только в Debug-режиме).  
2) Визуальные «инфлюенс-карты»: отрисуй изолинии/heatmap — дебажить приоритеты становится просто. citeturn2search7turn2search3

**Проверки GOAP:**
1) Лог плана: `[GOAP] Plan: Gather→Research[Shield-I]→Build[Turret×3]`.  
2) Ограничь глубину/время планирования; тест на отсутствие «перепланирования» каждый кадр.  
3) Ресурсные предусловия: отдельные ассерт-тесты для Preconditions/Effects.  
4) Референс по GOAP (для понимания структуры и ошибок): Orkin/F.E.A.R. (PDF). citeturn2search2

**Проверки Behavior Tree:**
1) Лог активных веток (ID ноды) и статусов `Success/Fail/Running`.  
2) Для «микро» задач (патруль/ремонт) — ограничитель тактов; избегай принятия решений в BT (пусть BT исполняет, а Utility/GOAP выбирают цель). citeturn2search5

---

## События/команды/сейвы

**Проверки:**
1) `EventBus.Flush()` вызывается **после** сим-тиков; добавь «сигнальный» лог `[EventBus] Flushed (count=X)`.  
2) «Склейка» событий (coalesce): убедись, что пачка одинаковых событий приходит одной записью.  
3) Сейв после «тикового барьера»: тест, что состояние не полудет-применённое.  
4) В ECS — playback `EntityCommandBuffer` в конце группы, не в середине. citeturn1search6

---

## Производительность и масштабирование — 3 ступени

### 1) MonoBehaviour-база
— Ранние измерения: Profiler (CPU, GC), Frame Debugger (draw calls/батчи). Учись читать причину «разбиения батчей». citeturn0search12turn0search20turn0search24

### 2) Jobs + Burst
— Выноси «горячие» циклы (диффузия, influence-карты, массовые сканы). Для дебага job’ов: временно сними `[BurstCompile]`/включи Native Debug Mode; помни, что `Debug.Log` в Bursted-коде ограничен. citeturn1search2turn1search14turn1search22

### 3) DOTS/Entities
— Фикс-шаг через `FixedStepSimulationSystemGroup`; все структурные изменения через ECB; проверь автоматическое воспроизведение буферов и «когда в кадре это происходит». citeturn0search2turn1search19

---

## Pathfinding на сетке (A* → JPS → HPA*)

**A*) Базовый A***  
— Визуалки: отрисуй `open/closed` ноды (`OnDrawGizmos`), итоговый путь (`LineRenderer`). Это мгновенно находит ошибки эвристики/блоков. citeturn3search5turn3search20

**B*) Jump Point Search (ускоритель для равномерной сетки)**  
— Тесты: сравни длину пути с A* (должна совпадать), время — меньше. Проверь «принудительные соседи» и «jump» логами. Общее описание JPS. citeturn3search0turn3search3

**C*) HPA***  
— Дебаг кластера: визуализируй границы кластеров и «порталы». Проверяй кэш межпортальных расстояний и частичные инвалидации при стройке/карантине. Базовые источники по HPA*. citeturn3search1turn3search8

---

## UI/визуализация для дебага (быстрое чек-лист меню)

- **Overlay «Тики/скорости»**: текущая скорость (×0.5/×1/×2/×4), индекс тика.  
- **Heatmap’ы**: заражение, сила своих, сила врага (influence).  
- **Отрисовка планов ГОАП/BT**: активная цель/план/нода.  
- **«Глазки» профилировки**: кнопки «Открыть Profiler/Frame Debugger» прямо из dev-меню. citeturn0search12turn0search20

---

## Мини-тестпак (Unity Test Framework)

- **EditMode**: чистые модели (экономика, правила заражения), предусловия/эффекты GOAP.  
- **PlayMode**: фикстуры сцены «маленькая карта» → 200 тиков → проверка инвариантов и сохранения/загрузки. Инструкции по Edit/Play Mode тестам. citeturn2search0turn2search12

---

### Частые «подлянки» и как их ловить
- `JsonUtility` не умеет `Dictionary<>`/полиморфизм по умолчанию — тестируй модели сейва отдельно. citeturn0search19turn0search8  
- Animator/таймеры на паузе — переводить на Unscaled Time/Realtime. citeturn0search7turn0search10  
- DOTS: структурные изменения без ECB → тормоза/рассинхрон; фикс-шаг — это именно группа, а не `Time.fixedDeltaTime`. citeturn1search6turn0search17  
- Addressables: несмиренные `Release` → утечки памяти. Делай «зеркальные» счётчики загрузок/выгрузок. citeturn1search10

---

Хочешь — разверну любой блок (например, InfectionSystem или Utility-скоры) в «пошаговый план дебага + примеры ассерт-тестов + подсказки по профилировщику» и сразу подготовлю мок-сцену для проверок.



## Дополнение к плану разработки игры: Экономика, логистика и фортификации
Источник: document-4.md

## Дополнение к плану разработки игры: Экономика, логистика и фортификации

### 1) Ресурсы и базовые правила (MUST)
1. Ввести **4 базовых ресурса**:
   - **Труда-часы (LaborHours)** мирного населения — универсальный производственный ресурс.
   - **Энергия (Power)** — объём электро-генерации/потребления за сутки.
   - **Материалы (Materials)** — стройматериалы/детали/боекомплект (унифицированно).
   - **Еда (Food)** — снабжение гражданских и военных.
2. **Суточный тик** экономики: расчёт происходит раз в игровой день в строго определённом порядке (см. §9).
3. Для каждого здания задать: **стоимость постройки**, **время строительства**, **штатную потребность в труда-часах**, **потребление/выработку энергии**, **обслуживание**, **прирост/переработку ресурсов**.
4. Нельзя уходить в минус по ресурсам. При дефиците система **автоматически снижает приоритетные расходы** (см. §10).

### 2) Рост населения и конверсия в военных (MUST)
1. Ввести **общий суточный прирост** мирного населения `CivGrowth` (ед./день).
2. Прирост формирует **пул свободных гражданских** (в труда-часах: `LaborHours = CivFree * HoursPerCivPerDay`).
3. Постройками типа **Призывной пункт/Казармы** конвертировать часть прироста в **военных**:
   - Параметры конверсии: **лимит обучаемых в день**, **время подготовки**, **стоимость в еде/материалах/энергии/труда-часах**.
   - Итог: военный юнит поступает в резерв/гарнизон после завершения обучения.

### 3) Передача процентов суточного прироста ИИ (MUST)
1. Для каждого ресурса (включая **CivGrowth**) добавить **слайдер % передачи ИИ** (0–100%, шаг 1%).
2. Передача применяется **к чистому суточному приросту** до поступления в склад игрока.
3. Округление вниз до целых; остаток остаётся у игрока.
4. Конфиг хранить помодно: **общие проценты** + возможность **переписать по фракции ИИ** (при наличии нескольких ИИ).

### 4) Типы зданий (MUST)
1. **Экономические**: Электростанция, Ферма, Шахта/Завод, Склад/Аккумулятор.
2. **Исследовательские**: Лаборатория/Университет — открывают апгрейды, повышают эффективность.
3. **Производственные юнитов**: Казармы/Завод техники/Аэродром — создают боевые юниты, требуют материалы, энергию, труда-часы и еду на содержании.

### 5) Транспорт как механика, не прямое управление (MUST)
1. Ввести **логистические узлы** (Город/Станция/Порт/Аэродром) и **коридоры** (дорога/железная дорога/воздушный мост).
2. Игрок создаёт **приказы переброски**: «откуда-куда», **приоритет**, **цель прибытия**.
3. Система считает **время в пути** с учётом пропускной способности коридоров и узких мест; юниты перемещаются **автоматически**.
4. Поддержать **резервирование транспорта** (авто-маршрутизация, перенос очереди) и **ускоренную переброску** с повышенным расходом ресурсов.

### 6) Возведение фортификаций юнитами (MUST)
1. Разделить на **временные** (окоп, пункт наблюдения, мешки с песком) и **постоянные** (ДОТ/бункер, капонир, противотанковый ров/ежи).
2. Каждой позиции задать: **стоимость** (труда-часы, материалы, иногда энергия), **время постройки**, **уровень защиты/укрытия**, **обслуживание/депрекация**.
3. Инструменты строительства:
   - **Линейное строительство** (траншеи по полилинии).
   - **Узловые точки** (опорники, башни, огневые точки).
   - **Улучшения/модернизации** (временное → постоянное).
4. Стройка идёт **инженерными юнитами**; параллельность определяется числом бригад/инструмента.

### 7) Интерфейс управления (MUST)
1. **Экран экономики/суточного отчёта**: баланс ресурсов, узкие места, очереди.
2. **Панель процентов передачи ИИ**: 5 слайдеров (LaborHours, Power, Materials, Food, CivGrowth), кнопка «сброс/по умолчанию».
3. **Строительное меню**: фильтры по типам зданий, требования, окупаемость, место размещения.
4. **Логистика**: список приказов переброски, статусы, ETA, «ускорить».
5. **Фортификации**: инструменты линии/точки, стоимость/время в реальном времени, очередь задач.

### 8) Данные/конфиг (JSON, no YAML) (MUST)
Пример (сокращённо):
{
  "economy": {
    "dailyTickHour": 0,
    "transferToAI": { "laborHoursPct": 0, "powerPct": 0, "materialsPct": 0, "foodPct": 0, "civGrowthPct": 0 }
  },
  "population": {
    "civilians": 10000,
    "baseDailyGrowth": 45,
    "hoursPerCivPerDay": 8
  },
  "buildings": [
    { "id": "farm_t1", "type": "economic", "buildTimeDays": 3, "cost": {"materials": 120}, "powerIn": 5, "laborIn": 10, "foodOut": 60 },
    { "id": "barracks_t1", "type": "unit_prod", "buildTimeDays": 4, "cost": {"materials": 200}, "powerIn": 10, "laborIn": 20,
      "convert": { "civPerDay": 20, "trainDays": 2, "costPerRecruit": {"food": 2, "materials": 1} } }
  ],
  "logistics": {
    "nodes": [{"id": "city_A","type": "rail"},{"id": "front_N","type": "front"}],
    "links": [{"from":"city_A","to":"front_N","mode":"rail","capacityUnitsPerDay":50,"baseHours":6}]
  },
  "fortifications": [
    { "id":"foxhole","category":"temporary","labor":4,"materials":2,"buildHours":6,"cover":"light" },
    { "id":"bunker","category":"permanent","labor":40,"materials":120,"powerIn":2,"buildDays":5,"cover":"heavy" }
  ]
}

### 9) Порядок суточного тика (MUST)
1. **Рост населения** → рассчёт `CivGrowth`.
2. **Передача % ИИ** по `CivGrowth` и ресурсам (на приросте).
3. **Потребление базовое** (еда населения, содержание войск/зданий, потери на хранение).
4. **Производство зданий** (еда, материалы, энергия, труда-часы).
5. **Очереди строительства/обучения** (списываем труд/материалы/энергию, продвигаем прогресс).
6. **Логистика** (обновление статусов перебросок, прибытия/выбытия).
7. **Фортификации** (прогресс стройки/ремонта/износа).
8. **Отчёт/алерты** (дефициты, простаивающие мощности, забитые коридоры).

### 10) Дефициты и приоритеты (MUST)
1. Ввести **приоритетные очереди**: 1) содержание населения/войск, 2) электропитание «жизненно важного», 3) еда военным, 4) производство, 5) исследования, 6) ускоренная логистика.
2. При нехватке **энергии** — пошаговое отключение по приоритетам; при нехватке **еды** — падение `CivGrowth` до 0 и рост риска событий (бунты/дезертирство), при длительном голоде — убывание населения.
3. Никаких «скрытых» списаний — всё видно в суточном отчёте.

### 11) Транспорт: детали реализации (SHOULD)
1. **Алгоритм пути**: кратчайшее время с ограничением по **capacityUnitsPerDay** и очередям.
2. Режим **Rush**: +50% скорость, +X% расход энергии/материалов.
3. **Авто-маршруты**: игрок задаёт «домашние» узлы для армий; пополнение идёт по умолчанию.

### 12) Фортификации: детали (SHOULD)
1. **Пакетные заказы**: линия траншей длиной L → стоимость пропорциональна L; разделение задачи между доступными инженерными бригадами.
2. **Деградация**: временные позиции теряют эффективность/прочность со временем и под огнём; постоянные — медленнее и ремонтопригодны.
3. **Апгрейд пути**: временная → капитальная без полного демонтажа (частичный зачёт уже вложенных труда-часов/материалов).

### 13) Баланс и контроль (SHOULD)
1. Встроить **тест-сценарии**: 
   - «Энергоголод»: отключения работают по приоритетам; экономика не падает в ноль.
   - «Мобилизация»: X% CivGrowth → войска; проверка узких мест по еде/материалам.
   - «Логистический пик»: массовая переброска не ломает коридоры; ETA корректны.
2. Метрики: **средняя загрузка мощностей**, **время простоя**, **узкие места по ресурсу/узлу**.

### 14) Минимально жизнеспособный срез (MVP) (MUST)
1. Суточный тик, 4 ресурса, один тип экономического здания (Ферма), одна Казарма, базовая передача % ИИ.
2. Логистика: 2 узла + 1 коридор, переброска пехотного юнита.
3. Фортификации: один временный (окоп) и один постоянный (бункер) тип.
4. Экран отчёта и слайдеры % передачи.

### 15) Технические константы (SHOULD)
- Все расчёты — **целочисленные**; доли — фикс. точность (×1000) с последующим округлением вниз при записи.
- Детерминированность тика: один источник случайности, сид, повторяемость.

---

#### Критерии готовности (DoD)
- Все пункты **MUST** реализованы и покрыты автотестами сценариев; интерфейсы (слайдеры %, экран отчёта, логистика, стройка фортификаций) работают и отражают реальные списания/приросты.
- Нет скрытых расходов, нет отрицательных значений, понятные сообщения при дефицитах.



## document
Источник: document.md

Архитектурный план проекта (C# / Unity) — 2D RTS с паузой, «двумя ВВП» (гос-ИИ и игрок) и симуляцией заражения
==============================================================================================================

Мини-допущения
--------------
- 2D на Tilemap; одна планета = одна большая карта (тайловая сетка).
- Пауза «хардовая» (останавливаем время симуляции), UI и меню — живут.
- «Гос-ИИ» — стратегический слой (макроэкономика/приоритеты), «локальный ИИ» — тактика/оборона/распространение.
- Производительность: старт на MonoBehaviour + ScriptableObject; при росте агентов подключаем Job System/Burst, при необходимости — DOTS/Entities для фиксированного тика.

1) Структура solution / namespaces
----------------------------------
/Game
  /Domain              // Чистые модели (POCO) и интерфейсы
    Economy/           // ВВП, бюджеты, производство, издержки
    Infection/         // Состояние клеток, параметры заражения
    Tech/              // Дерево технологий, эффекты
    Map/               // Координаты, граф смежности, зоны
    AI/                // Контракты AI: IStrategicPlanner, IUtilityScorer...
    Common/            // EventBus, Commands, Result, Time abstractions
  /Data                // ScriptableObject-конфиги (статические данные)
    Units/, Buildings/, Techs/, Factions/, InfectionParams/
  /Application         // Сервисы симуляции, претик/тик, сохранения
    Simulation/, Saving/, Pathfinding/, Services/
  /AI                  // Реализация: Utility AI, GOAP, Behavior Trees
    Strategic/, Tactical/, Perception/
  /Presentation        // MonoBehaviour: сцены, UI, инпут, визуализация
    UI/, VFX/, Audio/, Tilemaps/
  /Infrastructure      // Репозитории данных, JSON, DI/Service Locator

Пояснения:
- ScriptableObject — только «статические каталоги» (юниты, здания, технологии, параметры заражения).
  В рантайме — копии в виде обычных C#-объектов (иммутабельные где возможно), чтобы не мутировать ассеты.
- Tilemap — для сетки и рендеринга 2D-мира.
- EventBus / Command — слабосвязанная коммуникация между подсистемами (симуляция ⇄ UI, AI ⇄ экономика).
- Сохранения — JsonUtility (просто) или System.Text.Json (если нужен внешний формат/библиотеки).

2) Тайминг, пауза, и «фиксированный тик»
----------------------------------------
Цель: симуляция идёт фиксированным шагом (например, 5–10 тиков/сек), независимо от FPS; пауза останавливает симуляцию, но не UI.

Варианты:
- Свой SimulationLoop с накоплением accumulator += unscaledDeltaTime; пауза = isPaused = true (UI живёт).
- Можно использовать Time.timeScale = 0 для глобальной паузы (просто), но лучше контролировать симуляцию явным циклом.
- В DOTS/Entities: FixedStepSimulationSystemGroup даёт фикс-тик «из коробки».

Пример каркаса:
```csharp
public interface IClock { float Delta { get; } bool IsPaused { get; } }
public sealed class SimulationLoop : MonoBehaviour, IClock {
  [SerializeField] float tick = 0.1f; // 10 tps
  float acc; public bool IsPaused { get; private set; }
  public float Delta => IsPaused ? 0f : tick;

  void Update() {
    if (IsPaused) return;
    acc += Time.unscaledDeltaTime;
    while (acc >= tick) {
      acc -= tick;
      // вызываем системные тики по порядку:
      InfectionSystem.Tick(tick);
      EconomySystem.Tick(tick);
      StrategicAI.Tick(tick);
      TacticalAI.Tick(tick);
      EventBus.Flush();
    }
  }
  public void SetPaused(bool v) => IsPaused = v;
}
```

3) Данные и конфиги
-------------------
ScriptableObject → Runtime-модель: SO хранит конфиг, при старте превращаем в чистые объекты.

```csharp
// Data/Techs/TechDef.asset (SO)
[CreateAssetMenu(menuName="Defs/Tech")]
public class TechDef : ScriptableObject {
  public string Id;
  public string Title;
  public float ResearchCost;
  public TechDef[] Prereq;
}

// Domain/Tech/Tech.cs (runtime)
public record Tech(string Id, float Cost, IReadOnlyList<string> Prereq);
```

Почему так: SO — удобен для редактора и баланса; рантайм-копии — безопасны и сериализуемы.

4) Экономика (двойное ВВП)
--------------------------
Идея: два бюджета и две модели принятия решений.

- StateEconomy (ИИ государства): собирает налоги/ресурсы, тратит по стратегическим приоритетам (оборона, санитарные кордоны, базовые исследования).
- PlayerEconomy (личный ВВП): игрок вкладывает в прорывные исследования, постройку укреплений и «точечную поддержку» ИИ.

Мини-API:
```csharp
public interface IEconomy {
  float Balance { get; }
  bool TryReserve(float amount);
  void Commit(float amount);
  void Tick(float dt);
}

public interface IBuildService {
  bool CanPlace(BuildingType type, GridPos at, IEconomy whoPays);
  BuildOrder Place(BuildingType type, GridPos at, IEconomy whoPays);
}
```

5) Инфекция (модель заражения)
------------------------------
Отправная точка: клеточный автомат на сетке (состояния S/I/R или континуум заражения 0..1; вероятности заражения зависят от соседей, плотности, укреплений). Это можно сочетать с вейтом клеток (доля населения/мобильность).

```csharp
// Domain/Infection
public struct CellInfection { public float level; public InfectionState state; }

// Application/InfectionSystem
public sealed class InfectionSystem {
  public void Tick(float dt) {
    // 1) диффузия/заражение по соседям (Von Neumann / Moore)
    // 2) воздействие укреплений/санитарных зон (модификаторы)
    // 3) выздоровление/снижение при ресурсо-вложениях
  }
}
```

Расширения: стохастика, зоны карантина, «очаги», транспортные коридоры и т.п.

6) ИИ: стратегический + тактический (гибрид)
--------------------------------------------
Рекомендован гибрид трёх подходов:

1) Utility AI — быстро оценивает «что важно сейчас» (сдерживать очаг, построить кордон, финансировать исследование) через скоринг 0..1. Лёгкий и объяснимый слой приоритизации.
2) GOAP — строит план для выбранной цели: какие шаги выполнить (собрать ресурсы → исследовать «Щит-I» → построить 3 турели на дуге X). Подходит для «гос-ИИ», который мыслит «целями».
3) Behavior Trees — тактическое «микро»: патрули, наведение, ремонт, локальная оборона, реакции на события. Деревья хорошо отлаживаются и читабельны.

Слой восприятия:
```csharp
public interface IWorldState {
  float InfectionAt(GridPos p);
  float FriendlyStrengthIn(Region r);
  bool IsChokePoint(GridPos p);
  bool HasFortification(GridPos p);
}
```

Utility-оценки (пример):
```csharp
public interface IConsideration { float Score(IWorldState w); } // 0..1
public sealed class HoldLineConsideration : IConsideration {
  public float Score(IWorldState w) {
    // оценка важности удержания линии по метрикам мира
    return 0.5f;
  }
}
```

GOAP (эскиз):
```csharp
public interface IAction {
  bool Preconditions(IWorldState w);
  IWorldState Apply(IWorldState w);
  float Cost(IWorldState w);
}
public interface IPlanner {
  IReadOnlyList<IAction> Plan(Goal g, IWorldState w);
}
```

BT (псевдокод узлов):
```
Selector(
  If(ThreatNear) -> DeploySquad,
  Else -> Repair,
  Else -> Patrol
)
```

7) События, команды, сохранения
-------------------------------
EventBus (асинхронные события, очереди) — чтобы симуляция и UI не были жёстко связаны.
Commands — удобно логировать/откатывать действия (строительство, назначение бюджета).

Мини-EventBus:
```csharp
public static class EventBus {
  static readonly Queue<object> q = new();
  static readonly List<object> subs = new();
  public static void Publish<T>(T e) => q.Enqueue(e);
  public static void Subscribe(object handler) => subs.Add(handler);
  public static void Flush() {
    while (q.Count > 0) {
      var e = q.Dequeue();
      foreach (var h in subs) (h as dynamic).On((dynamic)e);
    }
  }
}
```

Команда строительства:
```csharp
public record PlaceBuildingCmd(BuildingType Type, GridPos At, Guid Who);
public sealed class BuildService : IBuildService {
  public BuildOrder Place(BuildingType type, GridPos at, IEconomy money) {
    if (!CanPlace(type, at, money)) return BuildOrder.Failed;
    money.Commit(type.Cost);
    var order = new BuildOrder(type, at);
    EventBus.Publish(order);
    return order;
  }
}
```

8) Производительность и масштабирование
--------------------------------------
- Начинай с обычных компонентов. Когда агентов станет много — выноси тяжёлые циклы в Jobs + Burst (сканы по сетке, диффузия инфекции, массовая тактика).
- Если карта и ИИ разрастаются — переносить горячие системы (инфекция-диффузия, массовое сканирование карты) в DOTS/Entities c фикс-шагом (FixedStepSimulationSystemGroup).
- Стратегия обновления: стратегический слой реже (раз в N тиков), тактика чаще; тяжёлые оценки разбивай по кадрам.

9) Каркас: план первых 2 недель
-------------------------------
День 1–2
- Создать проекты/папки, пустую сцену.
- Tilemap + конвертер координат (мир⇄сетка).
- SimulationLoop с фикс-тиком и паузой.

День 3–5
- SO-конфиги: BuildingDef, TechDef, InfectionParams.
- Runtime-модели и EconomySystem, InfectionSystem (простейшая CA-логика S/I/R).

День 6–10
- EventBus + базовые команды (PlaceBuilding, StartResearch).
- Utility-скоры для 3 задач гос-ИИ: «сдержать очаг», «застроить горлышко», «вложиться в исследование X».
- Простой GOAP-планер (2–3 действия), BT для патруля/ремонта.

День 11–14
- Сохранение/загрузка GameState в JSON.
- UI: пауза, скорости ×0.5/×1/×2, оверлеи инфекции/контроля.

10) Примеры кодовых скелетов (супер-кратко)
-------------------------------------------
EventBus — см. выше.

Команда строительства — см. выше.

Utility Consideration (ещё один пример):
```csharp
public sealed class OutbreakPressure : IConsideration {
  readonly Region region; readonly float threshold;
  public float Score(IWorldState w) {
    var p = w.InfectionAt(region.Center);
    return Mathf.Clamp01((p - threshold) / (1f - threshold)); // 0..1
  }
}
```

Что дальше?
-----------
- Сгенерировать минимальный Unity-каркас (папки, пустые классы/интерфейсы, шаблонные SO и MonoBehaviour) и чек-лист — чтобы можно было «просто открыть проект и начать писать».
- При желании — адаптация под Godot C# (TileMap, Autoload-синглтоны, Signals вместо EventBus).



## Квартальный план разработки RTS-проекта (Unity 2D) для начинающего
Источник: Квартальный план разработки RTS-проекта (Unity 2D) для начинающего.md

## Квартальный план разработки RTS-проекта (Unity 2D) для начинающего

Цель плана: За три месяца поэтапно обучить джуниор-разработчика созданию архитектурно сложного 2D RTS-проекта на Unity. План разбит на модули по ключевым подсистемам игры (цикл симуляции, экономика, инфекция, события, ИИ, пути и оптимизация). Каждый модуль содержит описание, учебные цели, задачи с возрастающей сложностью, пошаговые указания, советы по логированию и отладке, рекомендации по использованию AI-помощника (Codex GPT), а также способы тестирования. Модульная структура позволит постепенно наращивать навыки – от базовых механик до продвинутых оптимизаций – с обязательным пониманием и проверкой результатов на каждом этапе.

Следуя этому техническому плану, новичок сможет уверенно двигаться от создания каркаса проекта к полноценному участию в разработке сложной RTS. Важно: Не переходить к следующему модулю, пока текущий полностью не освоен и отлажен.

### Модуль 1: Базовый цикл симуляции и управление временем

#### Краткое описание модуля

В этом модуле реализуется основа игрового цикла – фиксированный цикл симуляции, независимый от частоты кадров, с возможностью паузы и изменения скорости времени. Мы создадим собственный SimulationLoop – компонент Unity, который с заданной частотой (например, 10 тиков в секунду) обновляет игровую логику, даже если FPS непостоянен[1]. Пауза должна останавливать симуляцию, не затрагивая работу интерфейса (UI)[1]. Также добавим функции изменения скорости (замедление/ускорение) и «пошагового» режима (шаг по одному тику).

Этот фундаментальный шаг научит контролировать время в игре и закладывает каркас для всех последующих систем (экономики, ИИ и т.д.), которые будут вызываться в цикле.

#### Цели обучения

- Понять концепцию фиксированного тика симуляции (fixed update loop) и зачем он нужен для RTS.

- Научиться останавливать и запускать симуляцию отдельно от рендеринга (пауза без паузы UI).

- Реализовать гибкое управление скоростью игры (разные коэффициенты времени).

- Получить навыки базовой работы с Unity MonoBehaviour (метод Update()), таймерами (Time.unscaledDeltaTime) и Debug-инструментами.

- Научиться проверять корректность игрового цикла при разных условиях (низкий/высокий FPS, пауза, одиночный шаг).

#### Основные задачи (по возрастанию сложности)

- Создание проекта и сцены. Инициализируйте Unity-проект и настройте структуру папок согласно плану архитектуры. Создайте пустую сцену с базовым окружением:

- Настройте Tilemap для игрового поля (пока просто пустая сетка)[2][3]. Убедитесь, что единицы измерения (например, 1 тайл = 1 метр) понятны – это пригодится для перемещения объектов.

- Создайте в сцене объект SimulationLoop с компонентом MonoBehaviour. Этот объект будет глобальным «таймером» симуляции.

- Разработайте интерфейс IClock (например, с свойствами Delta и IsPaused) для абстракции источника тиков[4]. Реализация этого интерфейса в SimulationLoop поможет передавать дельту времени другим системам.

- Реализация фиксированного цикла. В скрипте SimulationLoop реализуйте логику накопления времени и вызова тиков:

- Добавьте поле tick (длительность шага симуляции, например 0.1 сек для 10 тиков/сек) и аккумулятор acc[5].

- В Update() каждый кадр накапливайте невзвешенное время: acc += Time.unscaledDeltaTime. Используем unscaledDeltaTime, чтобы пауза через timeScale не влияла на наш цикл[6].

- Пока накопилось времени больше одного шага (acc >= tick), запускайте циклы симуляции по одному тику:

- Вычитайте из аккумулятора величину tick и затем вызывайте обновление всех систем игры в определённом порядке. Пока системы (экономика, инфекция, ИИ и др.) не реализованы, можете временно вызывать заглушки или логировать вызов тикov для каждой подсистемы. Позже, по мере прохождения модулей, сюда будут добавляться реальные вызовы: InfectionSystem.Tick(tick), EconomySystem.Tick(tick) и т.д.[7]. Сейчас достаточно вывести в лог, например, "Tick X processed", где X – номер тика.

- После обновления систем в конце каждого тика очищайте очередь событий: вызов EventBus.Flush(). (EventBus будет реализован в отдельном модуле, но сразу предусмотрите его вызов для правильного порядка событий[7]).

- Реализуйте возможность паузы: флаг IsPaused. В начале Update() проверяйте: если игра на паузе, не накапливайте время и сразу возвращайтесь (пропуская логику тика)[8]. В интерфейсе IClock сделайте Delta = IsPaused ? 0 : tick для удобства (или просто используйте флаг).

- Добавьте метод SetPaused(bool) для изменения состояния паузы[9]. Его будем вызывать из UI или горячей клавиши.

- Управление скоростью и одиночный шаг. Расширьте SimulationLoop для поддержки разных скоростей и пошагового режима:

- Скорости ×0.5, ×1, ×2, ×4: Введите множитель времени (например, timeMultiplier), который будет влиять на скорость симуляции. Можно просто делить/умножать значение tick или накапливаемое время. Например, для ускорения ×2 уменьшайте tick вдвое (или увеличивайте accumulator в 2 раза быстрее). Учтите, что UI и анимации должны продолжать работать с нормальной скоростью (они и так на unscaled время, так что изменение нашего tick не затронет UI)[10].

- Одиночный тик (Step): Реализуйте отдельную функцию или кнопку, по нажатию которой симуляция выполняет ровно один тик и снова останавливается. Для этого можно: если игра на паузе, принудительно вызвать один цикл while(acc >= tick) либо вызвать методы Tick() всех систем один раз вручную. Сделайте проверку (Assert), что при одном нажатии выполняется не более одного тика[11].

- Добавьте UI-контролы или горячие клавиши для управления скоростью и паузой. Например, кнопки «Пауза/Продолжить», «Шаг», а также переключатели скорости. Эти элементы можно разместить в простом Overlay-меню для разработчика.

- Логирование и визуальные индикаторы (для отладки цикла):

- Счётчик тиков: Добавьте на экран простой текстовый индикатор (например, в углу UI) или Debug.Log вывод, который увеличивается каждый раз, когда происходит тик[12]. Это поможет отследить, что тики идут регулярно и не пропускаются. Можно хранить счётчик tickCount в SimulationLoop и обновлять его в цикле.

- Лог порядка систем: В начале и конце каждого тика выводите в лог сообщения, например: "Tick #N start", а после вызова всех систем – "Tick #N end (flushed events X)". Это подтвердит, что порядок вызовов устойчивый и EventBus flush выполняется в конце тика, а не в середине.

- Индикатор паузы: отображайте на экране статус (например, надпись "PAUSED"), когда игра на паузе, чтобы визуально убеждаться, что пауза работает.

- Проверка стабильности тика: Путём резкого изменения FPS (например, включить/выключить VSync, переключить настройки качества) проверьте, что частота тиков остаётся около заявленных 10 тиков/сек без дрожания. Счётчик тиков и время можно сравнить: за 5 секунд реального времени должно накопиться ~50 тиков при ×1 скорости.

- Профилирование производительности цикла (базовое измерение):

- Откройте Unity Profiler (Window → Analysis → Profiler, либо клавиша Ctrl+7) и запустите игру на несколько секунд[13]. Посмотрите график времени на вкладках Scripts и UI. Должно быть консистентное время выполнения логики каждого тика и отсутствие скачков загрузки сборщика мусора (GC)[13]. На таком раннем этапе нагрузка минимальна, но полезно привыкнуть анализировать кадры.

- Удостоверьтесь, что GC не генерируется каждый тик из-за ваших операций. Например, если логируете каждую итерацию while, это может создавать сборки мусора из-за конкатенации строк. В продакшн-коде постоянный лог внутри цикла следует отключить или обернуть условием if (Debug.isDebugBuild).

#### Логирование и отладка

- Индикатор тиков: Проверьте, что UI-индикатор или лог счётчика тиков увеличивается равномерно и без пропусков. Если при паузе он останавливается, а при изменении скорости – меняет темп, всё правильно.

- Пауза: Во время паузы убедитесь, что метод Update() сразу выходит (ни одного тика не совершается). При этом анимации UI (если есть) должны продолжать проигрываться. Если UI-анимации замирают на паузе, убедитесь, что у Animator и таймеров использованы unscaled time (например, Animator.updateMode = UnscaledTime, WaitForSecondsRealtime вместо обычного)[14].

- Одиночный шаг: Нажатие кнопки «Step» должно приводить к выполнению ровно одного цикла while(acc>=tick). После шага цикл не должен сразу продолжаться, иначе это признак, что неправильно контролируется пауза или accumulator. Проверьте через Assert, что за один вызов Step производится не более 1 тика[11].

- Стабильность при разных FPS: Сравните поведение тиков при 30 FPS и при 200 FPS (можно ограничить FPS через QualitySettings или vsync). Число тиков в секунду и общее развитие симуляции должно быть одинаковым. Это ключевое свойство фиксированного цикла – независимость от частоты кадров[1].

- Типичные ошибки: Если замечаете, что тики «плавают» или идут быстрее/медленнее заявленного – проверьте сброс аккумулятора в цикле while. Нередко ошибка – не полностью вычитать tick из acc, что приводит к ускорению или замедлению цикла[15]. Другой частый баг – забыть вызвать EventBus.Flush() в конце тика (пока EventBus не работает, это не влияет, но позже будет критично)[16]. Также убедитесь, что симуляционное время отделено от времени UI: не используйте Time.deltaTime там, где нужен unscaledDeltaTime[6].

#### Применение Codex GPT

- Генерация кода цикла: Вы можете воспользоваться AI-помощником, чтобы получить шаблон класса. Например, спросите: «Напиши C# класс MonoBehaviour SimulationLoop с фиксированным шагом 0.1с и паузой». Codex предложит реализацию (сверьте с планом и примером из документа)[4]. Полученный код нужно внимательно проверить и протестировать.

- Исправление ошибок: Если цикл работает не так, как ожидалось (например, ticks пропускаются или идут неритмично), скопируйте свой код и запросите: «Найди ошибку в логике фиксированного цикла». Расширение Codex может подсветить проблемные места (например, неправильный сброс acc или использование deltaTime вместо unscaledDeltaTime).

- Пояснение кода: Если какие-то конструкции непонятны (например, Time.unscaledDeltaTime или работа while цикла), можно спросить: «Объясни, как работает этот код строчка за строчкой». Это поможет глубже понять шаблон фиксированного тика.

- Создание UI через Codex: Не уверены, как добавить UI-кнопки или текстовый индикатор? Спросите: «Как в Unity через код создать на экране текст для отображения счётчика тиков?». Codex может подсказать использование Canvas и TextMeshPro, либо изменение текста через скрипт.

- Сниппеты для проверки: Также Codex поможет со скриптами отладки – например, команду для печати текущего Application.targetFrameRate или для переключения VSync через скрипт, что пригодится при тестировании.

#### Тестирование и проверка результата

- Функциональный тест цикла: Запустите игру и вручную проверьте сценарии:

- Без паузы, нормальная скорость: тик-счётчик растёт примерно на 10 в секунду (если tick=0.1). Через ~5 секунд должно быть ~50 тиков.

- Пауза: при включении паузы счётчик останавливается, при снятии – продолжает расти.

- Одиночный шаг: при паузе нажатие «Step» увеличивает счётчик ровно на 1 и не больше.

- Ускорение ×2: тиковый счётчик начинает расти примерно в 2 раза быстрее (≈20 тиков/сек). Замедление ×0.5 – в 2 раза медленнее (≈5 тиков/сек).

- Тест с переменным FPS: Включите Stats в Game View (показывает текущий FPS). Изменяйте нагрузку (например, сожмите окно игры для увеличения FPS или включите интенсивную графику для просадки FPS) и наблюдайте за счётчиком тиков. Он должен быть стабильным. Например, если на высокой нагрузке FPS упал до 30, тики всё равно должны идти 10 раз/сек, просто по несколько за кадр. Если при просадке FPS игра «замедляется», значит, цикл не успевает нагнать – нужно проверить логику accumulator.

- Profiler: Запись профайлера должна показать регулярные всплески нагрузки в скриптах каждые 0.1 сек. В разделе Timeline профайлера можно увидеть, что за кадр может выполняться несколько тиков (несколько вызовов методов Tick подряд) – это нормальное поведение при фиксированном цикле, когда FPS ниже частоты тиков. Убедитесь, что время на 10 тиков ~равномерно распределено, а не накапливается бесконечно.

- Unity Frame Debugger: На этом этапе рендеринг минимален, но вы можете открыть Frame Debugger и убедиться, что Tilemap отрисовывается оптимально (Tilemap можно оставить режим Chunk для минимизации draw calls[17], если уже есть несколько слоёв). Это скорее ознакомительно – что профилировщик и дебаггер кадров работают, и вы умеете их открывать.

- Перед переходом дальше: Добейтесь, чтобы механизм времени работал полностью предсказуемо. Критерии готовности: пауза без багов, изменение скорости влияет только на симуляцию, в профайлере нет бесконтрольного роста нагрузки или утечек, а вы уверены в том, как устроен ваш цикл. Только после этого переходите к введению игровых данных и систем.

### Модуль 2: Данные и конфигурации (ScriptableObject → Runtime-модели)

#### Краткое описание модуля

Второй модуль посвящён управлению данными игры: создание конфигураций с помощью Unity ScriptableObjects и использование их для инициализации чистых C#-моделей (POCO) на старте игры. Мы подготовим "каталоги" игровых объектов (юнитов, зданий, технологий, параметров инфекции и т.п.) в виде ScriptableObject-ассетов, которые легко редактировать в Unity Editor. При запуске эти ассеты будут скопированы в обычные объекты (runtime-модели), с которыми и будет работать симуляция[18][19]. Такой подход предотвращает нежелательную мутацию ассетов во время игры и упрощает сохранение состояния[20].

Кроме того, в этом модуле заложим основу системы сохранения (Save/Load) – продумаем формат сохранения игрового состояния в JSON и версионирование данных. Пока игра простая, можно реализовать базовое сохранение экономики и параметров инфекции, чтобы убедиться в работоспособности подхода.

#### Цели обучения

- Научиться создавать ScriptableObject-ассеты и скрипты для игровых конфигураций.

- Понимать разницу между данными на этапе дизайна (ассеты) и данными в рантайме (копии, которые можно изменять).

- Реализовать загрузку конфигураций при старте игры: из ассетов в структуры, используемые системами (экономика, инфекция, технологии и т.д.).

- Понять ограничения Unity JsonUtility при сериализации и подготовить структуры данных с учётом этих ограничений (например, без Dictionary).

- Ввести концепцию версии сохранения и научиться делать миграцию при изменении формата данных.

- Закрепить навык написания простых юнит-тестов для проверки корректности моделей (например, сериализация/десериализация).

#### Основные задачи (по возрастанию сложности)

- Определение структур данных. Выделите основные типы игровых данных, которые будут конфигурироваться через редактор:

- Примеры: параметры инфекции (базовая скорость заражения, радиус распространения и т.п.), характеристики юнитов и зданий (стоимость, прочность), технологии (названия, стоимость исследования, требования).

- Для каждого типа данных создайте класс ScriptableObject. Например, InfectionParams (ScriptableObject) с полями для коэффициентов модели заражения, или BuildingDef с полями стоимости строительства, радиуса действия и пр. В документе архитектуры есть пример TechDef – ScriptableObject для технологии[21].

- Пометьте класс атрибутом [CreateAssetMenu] для удобного создания ассетов из меню Unity[21]. Добавьте необходимые поля (Id, название, числовые параметры, ссылки на связанные объекты).

- Runtime-модель: для каждого ScriptableObject определите соответствующую чистую C# модель (можно struct или record). Например, для TechDef – класс или record Tech с аналогичными полями[19], но вместо ссылок на другие SO храните, например, списки ID или индексы (т.к. runtime-объекты будут связываться между собой иначе).

- Связи и идентификаторы: продумайте систему идентификаторов. Например, у каждой технологии TechDef.Id – уникальный строковый ID[21], то же для юнитов/зданий. Эти ID можно использовать как ключи при преобразовании в runtime-модели (например, список prerequisite-технологий хранить как список строк ID или enum, вместо прямых ссылок на SO, чтобы легко сериализовать).

- Создание ассетов и загрузка. В Unity Editor создайте несколько экземпляров ваших ScriptableObject для теста:

- Например, сделайте 2-3 технологии, парочку зданий и задайте им поля.

- Создайте менеджер загрузки, который в методе Start() находит все необходимые ассеты и создает из них runtime-копии. Способы загрузки:

- Простой вариант: поместите ассеты в Resources папку и вызывайте Resources.LoadAll<T>() для каждого типа (например, всех TechDef)[22].

- Более продвинутый: заведите ScriptableObject "каталог" – например, GameConfig с полями-списками (List<TechDef> allTechs, etc.), и вручную заполните в инспекторе ссылки. В Start просто переберите эти списки.

- При загрузке каждой записи:

- Создайте соответствующий runtime-объект (например, new Tech(id, cost, prereqList) для TechDef[19]).

- Сохраняйте их в удобной структуре, например, словарь Dictionary<string, Tech> для технологий по ID, чтобы потом быстро получать по идентификатору. Учтите: словари нельзя напрямую сериализовать через JsonUtility, но для быстрого доступа в памяти они удобны. Позже при сохранении нужно будет перенести их в список или другой формат.

- Не используйте сами ScriptableObject напрямую в системе – всегда работайте с копиями. Добавьте проверку (например, в режиме редактора if(Application.isPlaying) Assert.IsFalse(AssetDatabase.Contains(obj))) что объект, с которым вы работаете, не является ассетом[23]. Это гарантирует: вы не мутируете оригинальные конфиги во время игры.

- Глобальное хранилище состояния. Спроектируйте класс GameState или несколько классов, описывающих текущее состояние игры, которое нужно будет сохранять:

- Например, GameState может содержать: текущее время/тик, состояния всех клеток (сетка инфекции), состояния экономики (балансы бюджетов), выполненные исследования, построенные здания и т.д.

- На этом этапе у нас реализованы не все системы, поэтому начните с того, что есть:

- Состояние инфекции: можно хранить как двумерный массив или список значений заражения по каждой клетке. Например, infectionGrid – массив float или небольшой класс CellState (уровень заражения + статус S/I/R).

- Состояние экономики: достаточно сохранить текущие балансы двух экономик.

- Можно добавить список выполненных технологий (пока у нас нет механики исследований, но на будущее).

- Версия сейва: добавьте поле SaveVersion (например, int) в GameState. При будущих изменениях структуры данных вы будете проверять версию и делать миграцию при загрузке[24].

- Сделайте GameState [Serializable], чтобы JsonUtility могла его сериализовать. Если в нём есть сложные поля (например, Dictionary), замените или пометьте их как [NonSerialized] и заполняйте через вспомогательные списки. Важно: JsonUtility не поддерживает Dictionary и полиморфные типы без специальных атрибутов[25]. Поэтому убедитесь, что все поля GameState – либо примитивы/структуры, либо списки/массивы таких примитивов/структур.

- Реализация сохранения и загрузки. Добавьте в проект скрипт SaveLoadService (или методы в существующем менеджере), реализующие:

- Сохранение: сбор текущего состояния игры в экземпляр GameState и сериализация его в JSON. Используйте JsonUtility.ToJson(gameState). Полученную строку можно сохранить в файл (например, в Application.persistentDataPath) или просто в PlayerPrefs для простоты.

- Загрузка: чтение JSON из файла, десериализация JsonUtility.FromJson<GameState>(json). После этого нужно применить загруженное состояние к текущей игре:

- Обновить все системы: перезаполнить сетку инфекции значениями из save, установить балансы экономик, отметить выполненные технологии и т.д. Проще всего это сделать, уничтожив текущую сцену и создав новую, инициализировав всё заново на основе GameState (особенно если структура сложная). Но можно и на лету применять.

- Миграция версий: если GameState.SaveVersion загруженного файла меньше текущей версии, выполните необходимые преобразования (например, заполнение новых полей значениями по умолчанию). Пока можно просто логировать предупреждение, что версия не совпадает, так как формат ещё не менялся. Но заложить эту логику важно на будущее[24].

- Безопасная точка сохранения: Решите, как игрок инициирует сохранение. Хороший подход – сохранять только когда игра остановлена или на паузе, чтобы не захватить промежуточное состояние. Либо дождаться конца тика (после EventBus.Flush()) и затем снять снимок состояния[26]. Сейчас, для упрощения, можно сохранять по кнопке, которая ставит игру на паузу и вызывает Save.

- Дополнительная задача (опционально): интегрируйте Addressables для загрузки ассетов, если планируете много контента:

- Это продвинутый шаг: вместо Resources использовать Addressables, что потребует инициализации Addressables API, но даст больше контроля над памятью.

- Если уже знакомы: реализуйте загрузку конфигов через Addressables.LoadAssetsAsync<T> и не забудьте правильно выгружать их через Release, иначе может быть утечка памяти[27][28].

- Добавьте счётчики или логи сколько ассетов загружено/выгружено, используя events или отладочный UI, чтобы убедиться, что нет избыточно висящих в памяти объектов[28].

#### Пошаговые указания к реализации

- Создание ScriptableObject: В Unity выберите Create → C# Script, назовите его, например, TechDef.cs. Наследуйте класс от ScriptableObject. Добавьте [CreateAssetMenu(menuName = "Defs/Tech")] сверху, чтобы в меню Assets → Create появилось создание Tech. Опишите поля: строка Id, название, числовые параметры, ссылки на другие ScriptableObject (например, список prereq типа TechDef[])[21]. Скомпилируйте, затем правой кнопкой в папке создайте пару таких ассетов и заполните поля в инспекторе.

- Runtime-модель: В папке Scripts/Domain/ соответствующей создайте класс или struct Tech (лучше struct или record, т.к. данные иммутабельны). Дайте ему такие же поля (Id, cost, prerequisites), но в prerequisites храните список строк ID или других простых значений[19]. Почему не держать ссылки на объекты? – чтобы этот класс был “чистым” и не включал UnityEngine.ScriptableObject (что затруднит сериализацию).

- Загрузка данных: Создайте скрипт GameDataLoader (MonoBehaviour на отдельном объекте менеджере или внутри SimulationLoop). В его Awake или Start получите списки ассетов. Если используете Resources, то: TechDef[] techs = Resources.LoadAll<TechDef>(""); (путь можно уточнить). Далее инициализируйте, например, Dictionary<string, Tech> techMap = new(); и цикл: foreach(var techDef in techs) { techMap[techDef.Id] = new Tech(techDef.Id, techDef.ResearchCost, techDef.Prereq.Select(t => t.Id).ToList()); }. Аналогично для других типов (Buildings, InfectionParams и т.п.). Теперь ваши системы могут обращаться к этим структурам для получения параметров.

- Использование данных в системах: Подумайте, как передать эти конфиги туда, где они нужны. Например, InfectionSystem может хранить ссылку на загруженный InfectionParams runtime-объект, EconomySystem – на настройки экономики (если такие есть). Можно сделать так, что GameDataLoader после загрузки устанавливает нужные поля в синглтонах систем или через событие сообщает о готовности данных.

- Сохранение GameState: Реализовав минимум игровых систем (после модулей 3 и 4 у нас будет экономика и инфекция), вернитесь к задаче сохранения. Например, после модуля 4, когда будет что сохранять, заполните класс GameState:

- tickCount или текущее время симуляции,

- infectionGrid (возможно, сериализуем как массив float или int статусов; большие двумерные массивы JsonUtility тоже умеет),

- stateEconomyBalance и playerEconomyBalance,

- возможно, список построек или технологий (если к тому времени появятся, иначе пропустите).

- JSON тест: Напишите небольшой метод отладки: при нажатии некой клавиши сериализуйте GameState и сразу десериализуйте обратно, сравните некоторые поля. Например, посчитайте сумму заражения по grid до сохранения и после загрузки – должна совпадать. Это выявит, если какая-то часть не сохраняется. Также проверьте, что поля как Id и списки правильно сохраняются (в JSON они должны присутствовать).

- Версионирование: Установите SaveVersion = 1 в текущем GameState. Сохраните игру, измените версию на 2 (например, добавив новое поле) – попробуйте загрузить старый JSON. Вы должны детектировать, что SaveVersion=1 (старый) и обработать: например, заполнить новое поле дефолтным значением, затем установить версию к объекту 2. Этот опыт с ручной миграцией пригодится, когда реальные изменения будут необходимы.

#### Логирование и отладка

- Мутация ассетов: В отладочном режиме (только в редакторе) проверьте, что нигде в коде вы не изменяете ScriptableObject. Помочь может Assert, предложенный в документе[23]: после создания runtime-копии можно проверить через UnityEditor.AssetDatabase.Contains(obj) – вернёт true, если объект является ассетом. В рантайме все наши рабочие объекты должны не быть ассетами. Если где-то осталась ссылка на оригинальный SO и вы её модифицируете, это ошибка.

- JsonUtility ограничения: Попробуйте прямо сейчас выполнить JsonUtility.ToJson(someScriptableObject) – убедитесь, что, например, поля-словарики там не сохраняются. Если ваши runtime-модели содержат несериализуемые поля, подумайте, как их исключить или преобразовать. Например, Dictionary заменить на список пар ключ-значение при сохранении/загрузке. Лучше выявить и решить эти моменты заранее, написав простые тесты на сериализацию.

- Тест сериализации: Напишите EditMode юнит-тест: создайте программно объект GameState, заполните его несколькими значениями (например, занесите 2 значения в infectionGrid, балансы экономик). Преобразуйте в JSON и обратно, убедитесь, что полученные объекты равны исходным по данным. Особенно если используете [SerializeReference] для полиморфизма – проверьте, что JsonUtility восстанавливает подтипы корректно[25].

- Загрузка данных: Отладьте загрузку конфигов – выведите в лог количество загруженных тех же технологий, зданий и пр., сравните с числом ассетов в проекте. Все должны загрузиться.

- Integrity check: Если у TechDef были ссылки на prereq, убедитесь, что в runtime Tech эти prereq действительно сохранены (например, размер списков совпадает). При сложных связях (например, технология A требует B и C) – убедитесь, что ваши runtime-модели могут это выразить (возможно, хранением ID B и C).

- Частые проблемы: забыли пометить класс [Serializable] – тогда JsonUtility выдаст пустой JSON. Или, например, попытались сериализовать что-то вроде Dictionary – JSON выйдет пустой. Лечится заменой структур. Другая ошибка – сериализация больших структур (сетка 1000x1000) может быть медленной или громоздкой; но пока игра маленькая, это приемлемо.

- Адресация ассетов: Если применили Addressables, включите режим PlayMode (Use Existing Build или Simulate) и отследите, что после сцены, где вы загрузили ассеты, при выходе или переходе они выгружаются. Логи или профайлер памяти помогут заметить, не остались ли ассеты висеть (у Addressables есть профайл и EventViewer, но это за рамками базового плана).

#### Применение Codex GPT

- Создание классов: Используйте Codex, чтобы ускорить шаблонный код. Например, запрос: «Создай класс ScriptableObject InfectionParams с полями float baseInfectionRate, float spreadRadius». Помощник сгенерирует простой класс, вам останется только скорректировать названия/тип данных. Аналогично можно сгенерировать класс runtime-модели: «Напиши C# record InfectionSettings с такими же полями».

- Сбор загрузки: Если не уверены, как программно загрузить ассеты, спросите: «Как загрузить все ScriptableObject определённого типа в Unity?». Codex может подсказать про Resources.LoadAll или адресаблы.

- JSON сериализация: Попросите пример: «Пример использования JsonUtility для сохранения и загрузки класса GameState». Получив код, убедитесь, что он учитывает ToJson/FromJson. Codex может сразу показать, как записать файл через File.WriteAllText и прочитать через File.ReadAllText – можете скопировать и адаптировать под пути.

- Unit-тесты: Пусть Codex поможет написать юнит-тест: «Напиши NUnit-тест, который проверяет, что JsonUtility корректно сериализует и десериализует объект с полями X, Y». Результат поправьте под свои классы. Это избавит от необходимости вспоминать синтаксис Assertions.

- Поиск ошибок сериализации: Если при сохранении что-то не сохраняется, вы можете показать Codex JSON вывод и код GameState, спросив: «Почему поле X не появляется в JSON?». Часто он подскажет, что, к примеру, свойство не сериализуется (сериализуются только поля) или тип не поддерживается.

- Оптимизация данных: Codex способен объяснить и рекомендуемые практики. Например: «Почему Unity не сохраняет Dictionary в JSON и как это обойти?» – поможет понять и выбрать решение (конверсия или использование другой JSON библиотеки).

- Работа с Addressables: Можно даже спросить: «Пример кода загрузки ScriptableObject через Addressables и выгрузки» – AI-ассистент подскажет нужные методы (Addressables.LoadAssetAsync, Addressables.Release).

#### Тестирование и проверка результата

- Проверка загрузки конфигов: Запустите сцену и в консоли проверьте логи: должно выводиться, сколько объектов загружено и какие ID у них. Сравните с вашими созданными ассетами – все ли считаны. Если чего-то не хватает, убедитесь, что ассеты находятся в Resources или привязаны к сцене/ScriptableObject-реестру.

- Тест GameState Save/Load: Когда будет реализована базовая экономика и инфекция (после модулей 3 и 4), протестируйте полный цикл:

- Запустите игру, немного измените состояние (например, повысится заражение в нескольких клетках, изменятся балансы после каких-то трат).

- Нажмите кнопку Save (или вызовите метод через консоль/дебаг).

- Сбросьте состояние – например, перезапустите сцену или вызовите метод Load сразу после Save (имитируя загрузку).

- Сравните: совпадают ли ключевые показатели? Число заражённых клеток, значения балансов и т.п. должны быть такими же, как в момент сохранения.

- Юнит-тесты: Запустите написанные EditMode тесты. Они должны пройти, подтверждая, что (де)сериализация данных работает.

- Проверка данных в инспекторе: На время отладки можно сделать так, чтобы при загрузке GameState игра ставилась на паузу. Тогда можно в Unity Editor открыть объекты (например, InfectionSystem) и убедиться, что их поля соответствуют загруженному состоянию. Это ручной способ верификации, но наглядный.

- Перед переходом дальше: Убедитесь, что вы уверенно получаете нужные параметры из конфигов внутри кода – например, InfectionSystem может обратиться к infectionParams.baseInfectionRate и получить значение, которое вы задавали в ассете. Сохранение на этом этапе может быть не полностью реализовано (если, скажем, ещё нечего сохранять), но каркас должен быть готов. Критерии готовности: все ключевые игровые параметры берутся не из «магических чисел» в коде, а из конфигурационных объектов; изменение значения в ассете меняет поведение в игре. Сохраняемый GameState по крайней мере включает основные части (таймер, экономику, инфекцию) и может быть успешно выгружен/загружен без ошибок.

### Модуль 3: Экономическая система (двойное ВВП)

#### Краткое описание модуля

В этом модуле реализуем экономику игры, причём сразу в двух аспектах: экономика государства (ИИ) и экономика игрока. Концепция «двойного ВВП» предполагает, что у государства и игрока отдельные бюджеты и модели принятия решений[29]. Государственный ИИ собирает ресурсы (налоги, производство) и тратит их на стратегические нужды – оборону, карантины, исследования базового уровня. Игрок же распоряжается личным бюджетом, вкладывая его в критические исследования, постройки и поддержку, тем самым влияя точечно. Эти две экономики взаимодействуют (например, государство может субсидировать игрока, игрок – платить налоги, или штрафы за провалы).

Мы начнём с упрощённой модели: две независимых экономики, каждая со своим балансом и базовыми операциями – резервирование средств и окончательное списание при оплате действий. Затем можно наращивать сложность: добавить пассивный доход для гос-экономики, механизмы займов для игрока, контракты с KPI (если проект позволяет). Экономика интегрируется с другими системами: строительство объектов должно тратить деньги, ИИ – выбирать, на что потратить бюджет, и т.д.

#### Цели обучения

- Понять принципы построения финансовой системы в игре: учёт ресурсов, транзакции, инварианты (сохранение баланса).

- Создать интерфейс и реализацию экономики (IEconomy) с основными операциями (Balance, TryReserve, Commit, Tick)[30].

- Научиться обрабатывать ошибки транзакций (например, нехватка средств) и логировать их.

- Освоить написание модульных тестов для бизнес-логики (проверка инвариантов, корректности резервирования).

- Понять, как несколько экономических субъектов могут взаимодействовать, и подготовить почву для принятия решений ИИ на основе бюджетов.

- Интегрировать экономику в цикл симуляции (ежетиковые обновления, например начисление ресурсов).

- Освоить использование Codex для генерации шаблонного кода интерфейсов и тестов.

#### Основные задачи (по возрастанию сложности)

- Интерфейс экономики. Определите интерфейс IEconomy с необходимыми методами[30]:

- Свойство Balance (текущее количество ресурсов/денег).

- Метод bool TryReserve(float amount): попытка зарезервировать сумму. Логика: если на счету достаточно средств, зарезервировать их под будущую операцию и вернуть true; иначе вернуть false. На этом этапе можно реализовать резервирование просто как проверку баланса (и, например, временное уменьшение баланса или отдельный счетчик резерва).

- Метод void Commit(float amount): окончательно списывает ранее зарезервированные средства. Предполагается, что этот метод вызывается после успешного TryReserve, чтобы подтвердить трату денег.

- Метод void Tick(float dt): обновление экономики каждый тик. Пока можно оставить пустым или использовать для пассивного дохода/расхода.

- Создайте класс Economy реализующий IEconomy. В конструкторе или инициализации задавайте стартовый баланс. Реализуйте хранилища: например, храните balance и reserved суммы. На упрощённом этапе можно при TryReserve просто уменьшать balance сразу (имитируя мгновенное резервирование), а Commit не менять баланс (т.к. уже вычтено). Либо не уменьшать при резерве, а уменьшить при Commit – но тогда надо хранить сколько зарезервировано. Выберите подход и задокументируйте его, главное – после Commit общий баланс должен уменьшиться на сумму, а если TryReserve не был выполнен – баланс не меняется.

- Добавьте удобство: метод AddFunds(float amount) для пополнения (например, налоговые поступления), чтобы модифицировать баланс извне.

- Две реализации или два экземпляра. Решите, как отличить экономику государства и игрока:

- Более гибко: сделайте два класса, наследующие от IEconomy, например StateEconomy и PlayerEconomy, которые могут переопределять поведение Tick (например, в StateEconomy Tick начисляет доход от налогов, а в PlayerEconomy – нет либо начисляет проценты по кредитам). На первое время можно не усложнять и использовать один класс Economy для обоих, просто с разными настройками.

- Создайте в игре два объекта/сервиса: stateEconomy и playerEconomy. Их начальные балансы можно задать в конфиге (например, ScriptableObject с начальными финансами) или в коде (какими-нибудь значениями для теста).

- Убедитесь, что эти объекты доступны остальным системам: например, BuildService (будет позже) сможет получить ссылку на тот IEconomy, который оплачивает строительство (игрок или государство).

- Интеграция в SimulationLoop. Подключите экономику к циклу симуляции:

- Добавьте вызов stateEconomy.Tick(dt) и playerEconomy.Tick(dt) в метод SimulationLoop.Update, внутри цикла тиков[31]. На ранней стадии Tick может быть пустым, но позже вы добавите в него логику.

- Решите, нужна ли экономике более редкая частота обновления. В RTS часто экономика не обновляется каждый кадр: можно, например, прибавлять доход раз в 10 тиков. Если хотите, можете реализовать счетчик внутри Economy.Tick: суммировать dt и, скажем, раз в 1 секунду (если dt суммарно ≥1) добавлять доход. Либо просто каждый тик маленькую сумму (эквивалентно).

- Простейший пример: пусть StateEconomy каждую секунду получает +10 единиц (налоги), а PlayerEconomy не получает пассивного дохода. Тогда в Tick можно написать: накопить время и когда >=1, увеличить баланс.

- Убедитесь, что SimulationLoop передаёт dt правильно (будет фиксированное tick из вашего SimulationLoop, например 0.1).

- Логирование транзакций. Добавьте в методы TryReserve/Commit вывод в лог для важных случаев:

- При неудачном TryReserve логируйте предупреждение: "[Economy] ReserveFail: amount=..., balance=..., who=Player/State"[32]. Это поможет отлаживать ситуацию, когда что-то не строится из-за нехватки денег.

- Можно логировать и успешные транзакции для трассировки (но не перестарайтесь, чтобы лог не захлебнулся – возможно, только в режиме дебага).

- Если реализуете резервирование с задержкой: логируйте и Commit: например, "Commit: ... funds deducted".

- Если будут сложные кейсы (например, штрафы или возвраты), тоже логируйте.

- Unit-тесты инвариантов. Напишите тесты, чтобы убедиться в корректности работы экономики:

- Тест: после TryReserve (успешного) баланс не должен уменьшиться (если вы выбрали так) или уменьшился ровно на сумму (если списываете сразу) – зависит от вашей логики. Главное – после соответствующего Commit суммарное снижение равно сумме транзакции. Например: старт 100, TryReserve(30) -> balance либо 70 (если сразу списали), либо 100 (если пока держите на резервах), затем Commit(30) -> баланс 70 (во втором случае). В любом случае, деньги не должны исчезать или создаваться из ниоткуда – сумма списанная должна равняться сумме транзакции.

- Тест: если два раза зарезервировать по 50 при балансе 100, второй раз должен провалиться (если не было Commit между ними). Баланс после первого резерва (если вычитаете) будет 50, второй TryReserve(50) -> true, но третий TryReserve(10) должен уже вернуть false.

- Тест: Commit без предшествующего TryReserve – либо не вызывается, либо игнорируется. Можно написать, что Commit не должен делать отрицательный баланс, даже если вызвать напрямую.

- Дымовой тест: симулируйте 100 тиков, в каждом случайным образом тратьте что-то (если хватает средств). К концу проверьте, что баланс уменьшился на сумму всех успешных расходов минус доходы, и что ни один баланс не ушёл в минус. Это поможет выявить логические ошибки (например, двойное списание).

- Расширение механик (необязательно, продвинутые задачи):

- Приоритеты гос-бюджета: В будущем, когда будет ИИ, можно сделать распределение бюджета по статьям. Сейчас можно заложить структуру: например, StateEconomy хранит доли бюджета на оборону, карантин, исследования. Пока не используем, но архитектурно предусмотрите (например, поля-проценты).

- Займы и проценты: Для PlayerEconomy добавьте возможность уходить в отрицательный баланс (кредит) до определённого лимита, с тем чтобы каждую секунду начислялся процент и уменьшал баланс еще больше, если долг. Это сложнее, но если есть интерес – реализуйте в Tick логику: если balance < 0, balance -= balanceinterestRatedt (т.е. вычитание процента, который увеличивает долг).

- Контракты с KPI: Это совсем продвинуто – завести сущность "Контракт" (например, государство заключает контракт с игроком построить защиту в регионе за 100 ед., если игрок не справился – штраф). Если интересно, пропишите класс Contract с полями цель, награда, штраф, дедлайн. Но реализацию можно отложить до появления ИИ, сейчас просто учитывайте, что бюджетные механики могут включать штрафы и бонусы.

#### Пошаговые указания к реализации

- Создание IEconomy: В папке Scripts/Domain/Economy создайте интерфейс IEconomy и опишите сигнатуры методов[30]. Затем в Scripts/Application или где уместно – класс Economy : IEconomy.

- Реализация Economy: Решите схему с резервами:

- Вариант A (простой): при TryReserve(amount) сразу уменьшать balance на amount, если хватает, и возвращать true; если не хватает – возвращать false, ничего не меняя. А Commit(amount) в таком случае может вообще ничего не делать (или просто для симметрии, хотя можно оставить пустым). Этот вариант проще, но терминология "Reserve/Commit" теряет смысл – вы сразу тратите деньги на этапе резерва. Однако для начала так можно.

- Вариант B (двухфазный): TryReserve только проверяет и, допустим, добавляет в некоторую переменную reserved += amount (или ставит флаг, что столько-то зарезервировано), но не списывает. Commit уже уменьшает balance на фактически зарезервированную сумму. Тут надо быть осторожным: а если за время между TryReserve и Commit баланс изменился? Но в однопоточной игре между ними обычно ничего не вставляется, кроме, возможно, другого TryReserve. Можно не углубляться: предположим, что TryReserve и Commit вызываются подряд без других операций.

- Реализуйте один из вариантов. Прокомментируйте в коде, как оно работает.

- Два экземпляра: Создайте два объекта Economy:

- Либо через добавление двух полей в существующий MonoBehaviour GameManager, которые в инспекторе можно заполнить (но лучше создать их программно).

- Например, в GameDataLoader после загрузки конфигов: stateEconomy = new Economy(initialStateFunds); playerEconomy = new Economy(initialPlayerFunds);. Или напишите классы StateEconomy/PlayerEconomy, если хотите переопределить Tick: stateEconomy.Tick начисляет, скажем, +1 каждый тик (или +10 каждую секунду как выше).

- Подключите эти объекты к SimulationLoop: либо передайте SimulationLoop ссылки, либо сделайте их синглтонами. Самый простой путь: сделайте их статическими полями для начала (но это хуже для тестов). Либо храните в SimulationLoop ссылки на обе экономики, и заполняйте их при старте.

- Начисление дохода: В методе Tick у StateEconomy добавьте: incomeAccumulator += dt; if(incomeAccumulator >= 1) { incomeAccumulator -= 1; balance += incomePerSec; }. Так каждую игровую секунду (не зависимо от FPS) будет приходить фиксированная сумма. У игрока можно ничего не делать или аналогично (если есть, например, пассивный доход).

- Подготовка к тестам: Убедитесь, что можно создать Economy и вызывать ее методы вне Unity (сделайте конструктор без зависимостей UnityEngine). Тогда вы легко протестируете логику в EditMode тестах.

- Юнит-тесты: В папке Assets/Tests (или через Window → General → Test Runner) создайте EditMode тесты. Например, EconomyTests:

- Тест ReserveDoesNotChangeBalance (если вы выбрали вариант B): создайте экономику с балансом 100, вызовите TryReserve(30) – ожидайте, что возвращено true, а balance всё ещё 100 (если вы не списываете сразу). Commit(30) – после него balance 70. И второй кейс: если TryReserve(200) – должно вернуть false и balance остаться 100.

- Тест MultipleReservesAndCommits: например, TryReserve(50) x2. Если вы списываете сразу, то первый вернёт true и баланс 50, второй – true и баланс 0 (если позволили ровно занулить). Если не списываете, можно имитировать контракт: TryReserve(50) -> true, TryReserve(60) -> false (потому что зарезервировано уже 50 и больше нельзя).

- Тест NoNegativeBalance: манипуляциями убедитесь, что после любых операций Balance >= 0 (если конечно вы не допускаете кредиты).

- Логирование: Внутри Economy добавьте Debug.LogWarning или Log для отказов. Чтобы в лог было понятно, какая экономика, добавьте либо разный префикс (например, сделать свойство Name или передавать в конструктор "Player" vs "State"). Лог на успехи можно делать через Log с уровнем Developer (например, Debug.Log("[Economy:Player] -50 for building X")).

- Связь с другими системами: Продумайте наперёд: экономика должна взаимодействовать с системой строительства (Module 5) и ИИ (Module 6). Это значит, что там будет вызываться if(playerEconomy.TryReserve(cost)) ... Commit(cost). Чтобы это сделать, те системы должны знать о playerEconomy. Вы можете внедрить зависимости, например, передать Economy ссылку в конструктор BuildService или сделать BuildService методом внутри Economy (нежелательно). Пока можно оставить глобальные ссылки или синглтон GameManager, откуда статически доступ к экономике.

#### Логирование и отладка

- Unit-тесты: Запустите созданные тесты в Test Runner. Если что-то падает – исправьте логику. Например, частая проблема – забыли учесть граничные условия (ноль на счету, ровно равная сумма и т.п.).

- Интеграционный тест: Напишите короткий сценарий: пусть каждый тик государство получает +1, а игрок пытается тратить 0.2. Запустите 100 тиков и посмотрите на балансы:

- У государства должно прибавиться примерно +100*0.1 (если 10 тик/сек) * 1 ед./сек = +10 (зависит от реализации).

- У игрока если каждый тик тратит 0.2, то за 100 тиков потратит 20, если хватило. Проверьте, не ушёл ли он в минус. Если ушёл, значит дозволяете, либо ошибка в проверке.

- Логи отказов: Принудительно создайте ситуацию, где расходов больше, чем денег. Например, дайте игроку 10, а попытайтесь потратить 15. Должно в консоли появиться предупреждение [Economy] ReserveFail: amount=15, balance=10, who=Player[33]. Убедитесь, что сообщение информативно.

- Стресс-тест баланса: Если у государства много дохода и много расходов, не возникает ли багов? Попробуйте резко увеличить доход (например, 100 ед./сек) и одновременно тратить 50/сек, посмотрите в профайлер – не проседает ли (экономика код лёгкий, но вдруг). Заодно убедитесь, что нигде не появляется бесконечного роста памяти.

- Частые проблемы:

- Накопление ошибок округления: если dt=0.1, за 10 тиков incomeAccumulator = 1.0, все ок. Но если dt не точно 0.1 (что может быть, если accumulator работает с флотами), за N тиков может накопиться чуть больше 1.0 и дать лишний доход. Это не критично, но осознайте: такая погрешность возможна. В финансовой системе иногда используют целые числа (копейки, центы) или Decimal. В игре можно закрыть глаза или периодически нормализовать accumulator.

- Несоответствие Reserve/Commit: например, вызвали TryReserve, получили true, но забыли вызвать Commit – деньги как бы висят. В простом варианте A это сразу списано, нет проблемы. В варианте B важно, чтобы в коде, где резервируете, всегда был парный Commit (например, в BuildService).

- Data races нет (игра однопоточная), но логика может сталкиваться: например, одновременно ИИ и игрок пытаются резервировать гос-бюджет – этого у нас нет, т.к. бюджеты раздельные. Но вдруг решите сделать общий резерв – тогда нужны мьютексы или блокировки. В Unity MonoBehaviour контексте это редкость, но упомянуть полезно.

#### Применение Codex GPT

- Реализация интерфейса: Спросите Codex: «Напиши интерфейс IEconomy с методами GetBalance, TryReserve, Commit, Tick». Он может сгенерировать код, останется скопировать.

- Класс Economy: Запрос «Реализуй класс Economy, который реализует IEconomy с базовым функционалом (баланс, проверка средств)». Codex, вероятно, предложит простой вариант с if(balance >= amount) { balance -= amount; return true; } для TryReserve. Проанализируйте, подходит ли вам эта модель (это вариант A). Вы можете уточнить: «А как реализовать отдельно резервирование и списание?», чтобы получить идею для варианта B.

- Генерация тестов: Очень полезно – попросите: «Придумай несколько unit-тестов для класса Economy, который умеет резервировать и списывать баланс». AI поможет сформулировать проверки инвариантов. Используйте это как шаблон, заменив на синтаксис NUnit (Assert.AreEqual и пр.).

- Логирование: Если не помните синтаксис Debug.LogWarning, можно спросить: «Как в Unity вывести предупреждение в лог». Он подскажет про Debug.LogWarning("text").

- Советы по дизайну: Задайте помощнику вопрос: «Лучше сразу списывать деньги при TryReserve или при Commit? Какие плюсы-минусы?». Возможно, он объяснит про транзакционность. Полезно для принятия решения.

- Расширенные механики: Если вы решите реализовать займы или контракты, можно проконсультироваться у Codex: «Как реализовать систему займов с процентами для игровой экономики?» – он может накидати идею формул. Или «Как спланировать бюджет с категориями (оборона, исследования)?» – тоже выдаст идеи, как хранить и обновлять.

- Отладка: Если тесты не сходятся, скормите Codex свой метод TryReserve/Commit и тест, который падает, с вопросом: «Почему этот тест не проходит?». Помощник проанализирует код и вероятно поймёт (например, вычитание не там стоит или сравнение float).

- Документация: Можно попросить сгенерировать XML-комментарии для IEconomy методов, чтобы сразу было описание, что они делают – мелочь, но приятная: «Добавь комментарии к методам IEconomy, объясни их назначение».

#### Тестирование и проверка результата

- Unit-тесты: Убедитесь, что все разработанные тесты зелёные. Это формальный критерий, что базовая логика корректна. Попробуйте и негативные сценарии: искусственно вызвать Commit без TryReserve – ожидаете ли вы исключение или ничего? Если ничего – тоже хорошо, убедитесь, что так и есть.

- Интеграция с другими системами: Пока других систем мало, но хотя бы вручную попробуйте:

- Создайте временно кнопку UI, которая при клике пытается playerEconomy.TryReserve(50) и если true – playerEconomy.Commit(50). Запустите игру, нажмите. Посмотрите, баланс уменьшился ли на 50. Попробуйте ещё раз, пока не уйдёт в ноль и не начнёт отказывать. В логах должны быть сообщения об отказе после исчерпания средств.

- Если StateEconomy имеет пассивный доход, запустите игру без действий и посмотрите, растёт ли баланс гос-экономики с каждым тиком (при желании логируйте каждую секунду).

- Проверка в профайлере: Экономическая система сама по себе лёгкая, но гляньте профайлер – метод Economy.Tick должен занимать наносекунды. Важно, что он не генерирует сборок мусора каждый тик (не создаёт строки, списки и т.п. внутри цикла).

- Готовность к следующему модулю: К моменту завершения этого модуля, у вас должны быть:

- Два работающих объекта экономики (гос и игрок) с независимыми балансами.

- Возможность тратить из них деньги (методы TryReserve/Commit) и начислять доход (хотя бы у одного).

- Логи и тесты, подтверждающие, что деньги не пропадают бесследно и не появляются из воздуха.

- Эти объекты интегрированы в SimulationLoop.Tick (то есть каждый игровой тик экономика обновляется)[31].

- Важно: Понимание, как дальше экономика будет использована – например, в следующем модуле (инфекция) напрямую нет, но в будущем: строительство объектов, реагирование ИИ на лимит бюджета. У вас должен быть готов интерфейс для этих взаимодействий. Если всё так – двигайтесь к следующему этапу.

### Модуль 4: Система инфекции (модель заражения на сетке)

#### Краткое описание модуля

В данном модуле создадим систему распространения инфекции на игровой карте. Это ключевая механика симуляции – своего рода эпидемия, разливающаяся по клеточному полю. Мы реализуем упрощённую модель SIR (Susceptible-Infected-Recovered) или её вариацию, комбинируя её с клеточным автоматом на сетке. Каждая клетка может находиться в одном из состояний (восприимчивая, заражённая, иммунная) или иметь количественный уровень заражения[34]. На каждом шаге симуляции инфекция будет диффузно распространяться от заражённых клеток к здоровым соседям, с учётом некоторых параметров (например, базовая скорость заражения, плотность населения, возможно – наличие защитных сооружений).

Основной алгоритм: для каждой заражённой клетки повышаем уровень заражения соседних; если уровень превышает порог, соседние клетки переходят в заражённое состояние. Также учтём выздоровление/иммунитет: заражённые клетки со временем могут переходить в состояние R (Recovered) – что может означать иммунитет или вымирание инфекции там. Реализация будет двустадийной: сперва простая версия с полным перебором сетки, затем оптимизация – обновление только фронтира (границы заражения) и использование двойного буфера для корректности.

#### Цели обучения

- Освоить концепцию клеточного автомата на примере эпидемической модели (SIR).

- Реализовать обновление сетки клеток по соседям (соседство Moore или Von Neumann) и понять разницу.

- Научиться работать с 2D массивами, эффективно обходить их и избегать ошибок индексов.

- Понять важность двойного буферизации при обновлении состояний, чтобы результаты текущего шага не влияли на вычисление соседей в том же шаге.

- Научиться визуализировать и логировать состояние поля для отладки (например, через Gizmos или цветовую карту).

- Подготовиться к оптимизации: понять, как можно обновлять только изменившиеся области (frontier) и вынести вычисления в многопоточные Jobs при необходимости.

- Закрепить использование Codex для генерации алгоритмического кода (например, перебор соседей) и отладки логики.

#### Основные задачи (по возрастанию сложности)

- Структура данных для поля. Решите, как будете хранить состояние инфекции для каждой клетки карты:

- Если карта не слишком велика (например, 100x100), удобно завести двумерный массив или Grid<CellState>.

- Создайте enum InfectionState { Susceptible, Infected, Recovered } для состояния S/I/R.

- Создайте структуру CellInfection с полями: level (float от 0 до 1, степень заражённости) и state (тип InfectionState)[35]. В начале игры все клетки кроме, допустим, нескольких – Susceptible с level=0. Можно начальные очаги вручную задать или случайно.

- Для доступа к соседям понадобится способ итерировать вокруг клетки: определите набор смещений для выбранного типа соседства:

- Von Neumann (крест из 4 соседей): смещения (0,1), (0,-1), (1,0), (-1,0).

- Moore (все 8 вокруг): дополнительно диагонали (1,1), (1,-1), (-1,1), (-1,-1).

- Выберите один подход (например, Moore для более “круглого” распространения, или Von Neumann для более “крестообразного”). Зафиксируйте это и используйте везде одинаково[36].

- Создайте класс InfectionSystem с необходимыми полями: хранение сетки (например, CellInfection[,] grid), возможно ссылки на InfectionParams (порог, коэффициенты) из модуля 2.

- Инициализация инфекции. Добавьте в начало игры (например, в GameDataLoader или отдельном InfectionSystem.Start) логику заполнения сетки:

- Установите всем клеткам state = Susceptible, level = 0.

- Определите 1-3 начальных заражённых клетки для старта сценария. Можно хардкодом: центр карты, или случайно выбрать несколько координат. У этих клеток state = Infected, level = 1 (максимум).

- Возможно, при наличии PopulatonDensity или Mobility (из расширений) – пока опустим, сконцентрируемся на базовой модели.

- Подключите InfectionSystem к SimulationLoop: в каждом тик вызов InfectionSystem.Tick(dt)[7].

- Логика распространения (диффузия). Реализуйте метод Tick(float dt) в InfectionSystem:

- Используйте двойной буфер: заведите второй массив или такой же размер CellInfection[,] newGrid, чтобы вычислять новые значения на основе старых, не переписывая старый на лету[37]. После завершения расчёта, замените старую сетку новым (или скопируйте результаты).

- Алгоритм одного тика:

- Для каждой клетки (x,y) в старой сетке:

- Если клетка Infected (заражённая):

- Она сама может продолжать быть заражённой; можно реализовать выздоровление: например, уменьшить её уровень на небольшую величину (иммунизация, если хочется SEIR эффект). Либо оставить как есть, решив, что выздоровление дольше чем один тик – можно не делать тут, а делать по таймеру или отдельной фазой.

- Рассмотрим всех соседей этой клетки (по выбранной схеме). Для каждого соседа, если он Susceptible, увеличиваем в newGrid его level на некоторую величину, зависящую от уровня текущей клетки и коэффициентов. Простой вариант: newLevel = oldNeighbor.level + infectRate * dt. InfectRate возьмите из InfectionParams (например, 0.2).

- Если после увеличения newLevel >= 1 (или какой-то порог), то в newGrid помечаем соседа как Infected (state) и можно задать newLevel = 1.

- Если клетка Recovered: скорее всего, она не влияет на соседей (иммунная/пустая). Можно ничего не делать. Возможно, стоит слегка уменьшать уровень заражения (если осталось).

- Если клетка Susceptible: по умолчанию ничего не делает сама, но её уровень мог быть повышен соседями (см. выше). Если после обработки всех заражённых соседей уровень остался <1, она остаётся Susceptible на этот тик.

- Отдельно: можно вне цикла заразных соседей обработать выздоровление: для клеток Infected уменьшить уровень или, например, через какое-то время перевести в Recovered. Например, если клетка заражена X тиков, перевести её. Но для простоты: можете каждую заражённую понемногу снижать level, и если упадёт ниже 0.1 – перевести в Recovered.

- После полного прохода замените grid = newGrid (предварительно можно старую сетку сохранить или копировать, если нужно сравнивать).

- Логируйте суммарную статистику: например, посчитайте, сколько клеток стало Infected в этом тик, сколько выздоровело – выведите: "[Infection] Tick: newly infected N, recovered M, total infected K".

- Проверьте, что не выходим за границы массива при обращении к соседям (не забудьте условия if(nx >=0 && nx < width && ny>=0 && ny<height)).

- Визуализация и отладка поля. Чтобы понять, как распространяется инфекция, добавьте визуальные подсказки:

- Gizmos: В скрипте InfectionSystem (или отдельном MonoBehaviour) реализуйте OnDrawGizmos() или OnDrawGizmosSelected(). В ней проходите по grid и рисуйте, например, квадраты или точки:

- Gizmos.color = Color.Lerp(Color.green, Color.red, cell.level) для клетки, и Gizmos.DrawCube(position, new Vector3(1,0,1)) чтобы отобразить цветом. Однако Gizmos по умолчанию видны только в Scene View. Для отладки в редакторе это достаточно: вы будете видеть тепловую карту при запуске игры в окне Scene.

- Отметьте несколько клеток: например, выбранную клетку и её соседей другим цветом, чтобы отладить логику соседства[36]. Например, если нажать на клетку (можно хранить какую-то debugSelectedCell), выделите её соседей: Gizmos.color = Color.cyan и нарисуйте WireCube вокруг соседних координат. Так вы убедитесь, что соседние индексы вычисляются правильно.

- UI-оверлей: Более сложный вариант – отрисовать текстуру или Tilemap с цветовой заливкой поверх игрового поля. Если хотите, можете динамически обновлять цвет тайлов в зависимости от уровня заражения (Tilemap позволяет менять цвет отдельного тайла). Либо отрисовывать примитивы (например, Spawn sprite с прозрачным красным кружком в заражённых клетках). Это по желанию – можно ограничиться Gizmos, т.к. они уже дают картину в редакторе.

- Логи деталей: Для глубокой отладки можно временно логировать изменения конкретной клетки: например, если уровень клетки (5,5) прыгнул с 0.2 до 0.5, вывести это. Но таких логов очень много на всю сетку, поэтому лучше делать их условно (например, if(x==5 && y==5) Debug.Log(...)).

- Heatmap UI (опционально): если чувствуется уверенность, реализуйте в простейшем виде. Например, сделайте на Canvas картинку размером с карту, и манипулируйте её пикселями (Texture2D.SetPixel) по значениям level. Но это не обязательно.

- Оптимизация обновления (frontier). По мере роста карты, обход всех клеток каждый тик может стать узким местом. Внедрите идею “frontier update” – обновлять только область вокруг текущего фронта заражения:

- Поддерживайте список или набор координат, которые являются «активными» – где произошли изменения (например, недавно заражённые клетки, или клетки границы между заражёнными и здоровыми).

- В каждом тик вместо полного двойного цикла по всей сетке, итерируйтесь только по списку активных клеток и их соседям[38]. То есть, если заражённая область компактна, вы обновите только её окрестности, а не весь мир.

- Реализация: заведите List<(int x,int y)> frontierCells. Изначально – список начальных заражённых очагов. На каждом тик создайте новый список nextFrontier = []. Когда инфицируете соседей, добавляйте тех соседей, кто перешёл в Infected в этом тик, в nextFrontier (они станут фронтом на следующий шаг).

- Также можно добавлять соседей, у которых уровень заметно изменился, даже если не заразились – но это тонкости. Минимум – новые заражённые и, возможно, клетки, которые стали здоровыми опять.

- После обработки тик: frontierCells = nextFrontier.

- Не забудьте, что если инфекция стихает где-то, фронт там пропадёт и процесс прекратится для той области (и это хорошо – не тратим время на пустые места).

- Логируйте размер фронтира каждый тик и время обновления шага (можно замерять через Time.realtimeSinceStartup до/после Tick)[38].

- Проверьте, что если фронт пуст (никаких заражённых клеток) – то система не будет выполнять лишнюю работу (можно просто сразу выходить из Tick, инфекция закончилась).

- Дополнительные механики (продвинутые, опционально):

- Карантинные зоны: Позже, когда будет система строительства, можно предусмотреть, что определённые постройки (например, блокпосты) создают области, через которые заражение распространяется хуже или не распространяется вовсе. Реализовать это можно сейчас, если добавить в InfectionParams какой-нибудь коэффициент quarantineEffect, и в диффузии: если клетка сосед – карантинная (нужно знать, есть ли кордон на ней, а это значит, что система построек должна сообщать), то либо пропустить заражение, либо сильно ослабить (умножить на 0.1 например).

- Очаги и фронт: Можно определить, что если уровень заражения клетки > 0.8, она считается “очагом”. Это чисто для статистики или для AI, но вы можете помечать такие клетки и, например, даже изменять стратегию распространения (например, очаги быстрее заражают вокруг).

- Транспортные коридоры: если карта предусматривает дороги или порты – можно добавить, что некоторые клетки заражают дальние, не только соседей (например, вероятность переноса инфекции на большое расстояние). Но это уже усложнение, без которого модель тоже работает.

- Случайность (стохастика): вместо детерминированного прироста можно вносить рандом. Например, шанс заражения соседа = 1 - (1 - p)^(количество заражённых соседей). Но для начального шага deterministic проще отлаживать. Случайность можно добавить позднее, убедившись в правильности базы.

#### Пошаговые указания к реализации

- Создание InfectionSystem: В Scripts/Application создайте класс InfectionSystem. Он может не быть MonoBehaviour (можно делать обычный класс, который управляется SimulationLoop), либо MonoBehaviour без Update (раз вызывается вручную). В нём: поля ширины/высоты (можете взять из Tilemap size или зашить), двумерный массив CellInfection grid.

- Инициализация: В конструкторе или при первом вызове Tick проверьте, если grid не создан, то создайте массив нужного размера [width,height] и заполните Susceptible. Можно вынести в отдельный метод Initialize(width, height) и вызвать из GameManager при старте.

- Начальные очаги: Например, grid[50,50].state = Infected; grid[50,50].level = 1; frontierCells.Add((50,50)). Добавьте 2-3 таких для проверки, или сделайте функцию для заражения клетки (чтобы можно было и потом заражать искусственно).

- Tick реализация: Следуя описанному алгоритму, напишите двойной цикл. Можно оптимизировать, но сначала сделайте прямой полный обход, убедитесь, что работает.

- Создайте временный массив nextGrid того же размера. Лайфхак: можно копировать ссылки или MemberwiseClone, но проще пройтись по всем клеткам и скопировать. Либо изначально nextGrid = deep copy of grid, а потом изменять. В целях читаемости, сделайте двойной цикл: for x, for y – скопируйте значения. Затем ещё раз цикл – применяйте правила. (Или объедините, как удобнее, но следите, чтобы вы не перезаписывали, пока используете).

- Обход соседей: пропишите 4 или 8 проверок, или заведите массив neighbors = new int2[]{(1,0),(-1,0),(0,1),(0,-1), ...} и итерируйтесь по нему. Первый вариант явно длиннее код, второй – чище.

- Если используете frontierCells: тогда внешний цикл будет foreach(var (x,y) in frontierCells) и плюс возьмёте всех их соседей тоже. Но аккуратно: если у вас только заражённые клетки в фронтире, то соседи могут стать заражёнными – они войдут в nextFrontier. А что если заражённая клетка остаётся заражённой? Её тоже надо держать во фронте пока она имеет здоровых соседей. Так что, вероятно, и текущие заражённые тоже надо оставлять, пока вокруг них есть Susceptible.

- Простой подход: frontierCells хранит все заражённые клетки (Infected state) на границе с Susceptible. То есть, например, каждую симуляцию обновляйте frontier: собрать всех Infected, у которых есть хотя бы один сосед Susceptible. Это тоже допустимо, но требует сканировать соседей (но меньше, только вокруг заражённых).

- Начните без оптимизации (весь массив), убедитесь, что всё верно, потом добавьте frontier optimization: сравните результаты – они должны совпадать.

- Визуализация:

- Gizmos: override OnDrawGizmos in InfectionSystem (если не MonoBehaviour, можно сделать отдельный MonoBehaviour "InfectionVisualizer" и дать ему ссылку на InfectionSystem.grid). В Gizmos, делаете: for x,y => определяете цвет. Например,

- Color col;
switch(state):
  case Susceptible: col = new Color(0,1,0, 0.1f + level*0.5f); // зелёный, слегка краснеющий если уровень растёт
  case Infected: col = Color.Lerp(Color.yellow, Color.red, level); // желто-красный
  case Recovered: col = Color.gray;
Gizmos.color = col;
Gizmos.DrawCube(new Vector3(x, 0, y), new Vector3(1,0.1f,1));


- Это нарисует цветные кубики на сцене. Откройте сцену, включите Gizmos (в Game View Gizmos галочка, хотя лучше смотреть в Scene).

- Соседство отладка: если есть debugCellX, debugCellY (можно временно задать), выделите её Gizmos.color = Color.cyan, а всех соседей – Color.blue. Чтобы задать debugCell, можно, например, каждый тик брать первую заражённую клетку из frontier для анализа.

- UI overlay: если хотите, можете на Canvas вывести текст: количество заражённых, процент карты заражён. Либо, если реализовали debug menu, добавить туда переключатель отображения инфекции.

- Recovery: Добавьте простое правило: если клетка Infected, уменьшаем её level на, скажем, recoveryRate * dt (например, 0.1 * dt). Если level упало <= 0, или вы можете считать, что после 10 секунд заражения она переходит в Recovered. То есть, у вас может быть счётчик времени заражения. Но можно и проще: фиксированный шанс выздоровления. Чтобы сильно не усложнять – можете вообще не делать recovery, или сделать по таймеру: например, в CellInfection добавить поле infectionTime, в каждую Tick для Infected увеличивать его, и если > threshold, state = Recovered.

- Решите: Recovered клетки будут иметь level = 0? Или оставлять уровень как был? Наверное, лучше обнулить, или хранить, что они переболели (может влиять на AI).

- Межсистемная интеграция: Пока у нас нет эффекта экономики или построек на инфекцию, но имейте в виду: построенные игроком укрепления должны снижать распространение, требуя взаимодействия. Когда будет EventBus/BuildService, сделаем: при постройке, InfectionSystem узнает, что на клетке появился объект (например, фортификация), и меняет локально параметры (может, state = Recovered? или особый статус, или cell.protectionFactor).

- Подготовиться можно так: в CellInfection добавить поле hasFortification bool, и в распространении: если сосед.hasFortification, то либо пропустить заражение, либо умножить на фактор <1. Пока нигде не ставим true, но механика заложена.

#### Логирование и отладка

- Проверка модели SIR: Убедитесь, что базовая «физика» SIR соблюдается[39]. То есть если вы настроили параметры (например, infectionRate, recoveryRate), попробуйте в небольшом примере на бумаге или в таблице прикинуть, как S->I->R должно происходить. Запустите симуляцию на маленькой сетке 3x3 и проследите, как одна заражённая клетка заражает соседей. Если уровень накапливается плавно, все хорошо. Если сразу все стали заражены – значит infectionRate слишком высок или threshold низкий.

- Соседство: Очень важно, чтобы вы реализовали соседей точно и не упустили никого. Проведите тест: выберите одну заражённую клетку, логируйте список её соседей координат. Сравните с тем, что вы ожидаете (например, у угловой клетки на краю должно быть 3 соседа в Moore, или 2 в Von Neumann). Вы можете для уверенности ручной тест сделать: например, функция, которая возвращает список соседей, и unit-тест, что для центра возвращает 8 (в Moore) уникальных, а для угла – 3.

- Двойной буфер: Проведите мысленный эксперимент или даже тест: если нет двойного буфера, то если вы обновляете сетку на лету, одна заражённая клетка может заразить соседа, а потом этот сосед в этом же тик заразит других – эффект «волны за один тик», чего быть не должно. С double buffer этого не случается – инфекция распространяется максимум на 1 клетку за тик, как задумано. Убедитесь, что вы правильно меняете newGrid, а старый читаете. Чтобы проверить:

- Можно создать ситуацию: центр заражён, вокруг 8 клеток незаражены. За один тик с double buffer заразятся только соседние 8 (если достаточно уровня), но не дальше. За второй тик – их соседи и т.д. Если сделать ошибку и обновлять старый сразу, может за один тик пойти дальше.

- Напишите Debug.Log при заражении клетки: "Cell (x,y) infected this tick". Запустите, посмотрите, не бывает ли случаев, что она стала зараженной, и тут же в том же тик вы логируете заражение кого-то, кто не сосед исходной, а через клетку (если infectionRate не огромный). Если так – ошибка в буфере.

- Frontier: Если реализовали обновление по фронту, сравните с наивным полным обновлением на каком-то шаге. Например, отключите frontier и запустите 50 тиков, сохраните состояние. Затем откатитесь, включите frontier-логику, запустите те же 50 тиков – состояния должны совпасть (проверить на паре клеток, или глобально подсчитать, например, общую зараженность). Если равны – оптимизация корректна.

- Отладка времени шага: Вывели время выполнения InfectionSystem.Tick (через Time или Stopwatch)? На маленьких размерах будет миллисекунды или меньше, но на больших (>100k клеток) может быть уже ощутимо. Не стремитесь к нулю пока, но держите в уме.

- Heatmap визуально: Откройте Scene View во время игры. Должны видеть картинку заражения. Убедитесь, что:

- В самом начале только несколько клеток красные (очаги).

- Спустя какое-то время образуется «пятно» заражения, распространяющееся плавно. Если видите скачки (например, внезапно дальняя клетка стала зараженной без цепочки) – вероятно, баг с индексами или не учли dt.

- Посмотрите, как infection level меняется: может понадобиться правильно настроить скорость. Слишком быстро – всё краснеет мгновенно; слишком медленно – распространение незаметно.

- Логирование прогресса: Выводите периодически (например, раз в секунду или раз в 10 тиков) процент заражённых клеток или количество текущих Infected. Это поможет убедиться, что модель не взорвалась или не заглохла. В SIR-модели обычно график: сначала экспоненциальный рост, потом насыщение и спад. Ваша игра – не обязательно реальная эпидемия, но похожие тренды могут быть.

- Частые ошибки:

- Неправильное вычисление соседних индексов (например, перепутали X и Y, или сделали neighbors массив неправильно). Это сразу видно по рисунку распространения – он будет искажён.

- Условие заражения: если вы сделали порог 1.0, но infectionRate*dt никогда не достигает 1, может получиться, что level копится очень медленно и может не перейти в Infected статус (например, level=0.9 так и останется Susceptible). Чтобы этого избежать, можно порог сделать меньше, либо так: если level > 0, пусть это значит latent infection (еще S), пока <1. Но лучше: если достиг, сразу переводить state = Infected. Если не достиг, он сохранится и может накапливаться – это нормально.

- Не забыли ли обрабатывать Recovered? Иначе у вас никогда не убывает инфекция. Если recoveryRate=0, то Infected будут инфицировать вечно. Это ок, если игра про постоянную борьбу. Но если хотите реализовать спад, то нужно.

- Забытая проверка границ: если получаете IndexOutOfRange, добавьте проверки на краях.

- GC: Если каждый тик вы создаёте новый массив 100x100, это 10k objects GC может мусорить (на 60 FPS * 10000 = 600k alloc/sec – не супер страшно, но лучше избегать). Можно сделать массив полем и переиспользовать, или, лучше, перейти на NativeArray (будет в оптимизации). На данном этапе, можно смириться, а оптимизировать в модуле 8.

#### Применение Codex GPT

- Генерация кода распространения: Попробуйте запрос: «Алгоритм распространения инфекции на сетке 2D (Moore соседи) на C#». Codex может выдать псевдокод или даже близкий вариант. Используйте его идеи, но убедитесь, что код не содержит типичных ошибок (например, не обновляет сетку сразу).

- Двойной буфер: Спросите: «Почему нужен double-buffer при обновлении клеточного автомата?». Помощник объяснит и вы сможете убедиться, что делаете правильно.

- Работа с массивами: Если вам сложно с синтаксисом двумерных массивов или списков, Codex подскажет. «Как объявить двумерный массив 100x100 в C# и обойти его в цикле?» – это базово, но AI может быстро сгенерировать шаблон фор-циклов.

- Gizmos пример: Можно спросить: «Как через OnDrawGizmos нарисовать цветные кубики на каждой ячейке tilemap?». Codex, вероятно, выдаст пример использования Gizmos.DrawCube.

- Оптимизация frontier: Сформулируйте: «Как оптимизировать обновление клеточной автомата, обновляя только изменившиеся клетки?». Получите идеи насчёт frontiers. Вы можете даже попросить конкретно: «Напиши C# код, который хранит список изменённых клеток и обновляет только их соседей».

- Отладка: Если какая-то клетка ведёт себя странно (например, внезапно стала заражённой, хоть должна не сразу), можете описать ситуацию Codex: «У меня клеточный автомат, соседний алгоритм Moore. Заражённая клетка (5,5) за один шаг заразила (7,5), хотя между ними (6,5) не был заражён. Где искать ошибку?». Он может посоветовать проверить если вы не обновляете сетку по ходу (то есть укажет на double buffering).

- Визуализация: Если вы затрудняетесь с UI, можете спросить: «Как сделать тепловую карту заражения на Unity Tilemap?». AI подскажет про Tilemap.color или про Texture2D, это может дать идеи.

- Jobs/ECS на будущее: Codex можно спросить: «Как перенести обновление 2D grid в Unity Job System?». Он может дать пример использования IJobParallelFor по массиву – сохраните эту идею для модуля 8.

#### Тестирование и проверка результата

- Малый сценарий: Создайте крайне маленькую сетку, 5x5 например, и один очаг. Пройдите тик за тиком вручную:

- Первый тик – очаг заражает своих (на 5x5 много крайних случаев – возьмите очаг не на краю для чистоты). Должны заразиться (или повыситься уровень) у соседей. Проверьте консоль/визуализацию.

- Второй тик – теперь бывшие соседи может заразят своих. Если double buffer работает, через одну клетку инфекция пока не должна проскакивать.

- Третий – должно дальше пойти. Если всё соответствует ожиданиям, хорошо.

- Большая карта: Запустите на, скажем, 50x50 с несколькими очагами. Проверьте:

- Инфекция распространяется примерно равномерно во все стороны от каждого очага (если параметры одинаковы).

- Два фронта встретятся, соединятся – в итоге получится одна область.

- Если сделали recovery, убедитесь, что через какое-то время рост замедляется и число заражённых стабилизируется или снижается.

- Наблюдение статистики: Если вывели логи, посмотрите: число новых заражений сначала растёт, потом падает – классическая кривая эпидемии. Если у вас recovery=0, то число заражённых будет только расти пока все не заразятся.

- Граничные эффекты: Проверьте, что на границах карты инфекция не вызывает ошибок и нормально останавливается (нет соседа вне массива).

- Проверка frontier оптимизации: Если включили, сравните скорость:

- Без frontier: можно измерить, сколько мс занимает Tick, когда, например, заражена половина карты.

- С frontier: когда заражена половина карты, фронтир – это в основном периметр области (примерно периметр ~ 2sqrt(N) vs NN если всё заражено, но если вся карта заражена, фронтир будет пуст).

- Убедитесь, что при полной заражённости вы не продолжаете обход (frontier пуст, Tick сразу выходит).

- Сравните лог "время шага" – с frontier оно должно быть меньше особенно на начальных стадиях, когда заражено мало клеток.

- Перед следующим модулем: Система инфекции должна работать автономно и правильно:

- Критерии готовности: Инфекция распространяется, видимо и предсказуемо; можно регулировать скорость и радиус через параметры (infectionRate, neighbors type); нет бесконечных багов (утечек, ошибок); debug-инструменты позволяют видеть состояние (вы можете глазами понять, что происходит, и AI в будущем тоже сможет).

- Теперь у нас есть динамическая часть симуляции (инфекция) и статическая (экономика). Далее займёмся связывающими элементами – события, постройки, команды, а также подготовим почву для ИИ.

### Модуль 5: Событийная шина и команды, система строительства и сохранение игры

#### Краткое описание модуля

На этом этапе интегрируем механизм взаимодействия между различными частями игры с помощью EventBus (событийной шины) и системы команд. EventBus позволит рассылать сообщения о происходящих событиях (например, построен объект, начато исследование, произошёл всплеск инфекции) всем заинтересованным подсистемам без жёсткой связи между ними. Команды представляют собой действия, инициированные игроком или ИИ (например, команда построить башню обороны), которые можно логировать, откатывать или воспроизводить.

Мы реализуем простой шаблон EventBus с очередью и подписчиками[40]. Затем создадим пример использования: система строительства (BuildService) как реализация команды. BuildService будет проверять возможность постройки (с учётом денег, занятости клетки), резервировать средства через Economy и публиковать событие BuildOrder в EventBus[41]. Подписчики (например, система карты/строений) получат это событие и непосредственно создадут объект на карте.

Дополнительно доработаем систему сохранения: убедимся, что она вызывается в правильный момент (после всех событий за тик, чтобы состояние консистентно)[26]. Введём логирование команд для отладки (в будущем это поможет воспроизводить проблемы по логу).

#### Цели обучения

- Освоить шаблон паблишер-сабскрайбер (Publisher/Subscriber) через глобальную шину событий для decoupling систем.

- Научиться определять классы событий и подписываться на них в разных системах.

- Реализовать безопасную рассылку событий после основного цикла симуляции (с помощью очереди событий).

- Понять роль команд: объект, инкапсулирующий действие. Научиться создавать и обрабатывать команды (например, команду на строительство).

- Интегрировать экономику с командами: проверка средств, списание при выполнении команды.

- Доделать систему сохранения: убедиться, что сохранение происходит вне тика, когда все события уже обработаны (тиковый барьер).

- Укрепить навыки логирования: лог каждого события/команды для отладки.

- Использовать Codex для генерации шаблонного кода EventBus, примеров команд и поиска ошибок подписки.

#### Основные задачи (по возрастанию сложности)

- Реализация EventBus. Создайте статический класс EventBus с методами:

- Subscribe(object handler): регистрация подписчика. Подписчиком может быть любой объект, имеющий методы-обработчики событий. Проще всего – пусть подписчик реализует интерфейсы для событий или просто имеет публичные методы On(EventType e).

- Publish<T>(T eventData): публикация события (объекта любого типа)[40]. Реализуйте, чтобы событие складывалось в внутреннюю очередь q (Queue<object>).

- Flush(): обработка всех накопленных событий. Пока очередь не пуста, доставайте событие и передавайте его всем подписчикам:

- Самый простой вариант (из документа) – использовать dynamic: foreach(var h in subs) (h as dynamic).On((dynamic)e). Это позволит вызывать метод On у подписчика, соответствующий типу события. Например, если e типа BuildOrder, а подписчик имеет On(BuildOrder order), то dynamic-система найдёт его.

- Если dynamic кажется сложным, альтернативно: можно завести интерфейс IEventHandler<T> для разных типов, но это добавит шаблонности. Для начала, dynamic – быстр и понятен, просто не забывайте, что нет проверки на этапе компиляции.

- Храните списки подписчиков subs как List<object>[42].

- Добавьте защиту от исключений: если один подписчик кинет ошибку при обработке, лучше логировать, но продолжать остальные, чтобы EventBus не прервался.

- EventBus должен вызываться в SimulationLoop.Tick последним шагом (вы уже сделали это в модуле 1). То есть все события, опубликованные во время тика, скопятся и только после обновления всех систем разошлются.

- Подписка: вызовите EventBus.Subscribe(this) в Start/Awake тех систем, которые хотят слушать события. Например, BuildService может слушать команду строительства (хотя он сам её генерирует, здесь не нужно). А вот система, отвечающая за размещение зданий на карте (MapSystem) должна подписаться на BuildOrder события, чтобы создать объект.

- Класс команды и событие строительства. Определите класс события/команды для строительства:

- Например, public record BuildOrder(BuildingType Type, GridPos Position, Guid Who) – как в документе[41], где Who или какой-то идентификатор, кто заказал (может быть игрок или ИИ).

- Можно также добавить в BuildOrder поле результата (успешно/не успешно), но мы лучше будем публиковать только успешные заказы.

- Определите enum BuildingType (например, Tower, Wall, Hospital… или просто для теста).

- BuildService: создайте класс, реализующий интерфейс IBuildService[43]. В нём метод Place(BuildingType type, GridPos at, IEconomy whoPays):

- Проверяет CanPlace(type, at, whoPays). Можно реализовать CanPlace просто: возвращает true, если на этой клетке ещё нет здания (нужно знать состояние карты) и хватает денег (whoPays.Balance >= cost).

- Если нельзя, возвращает какой-то результат (можно сделать BuildOrder со статусом Failed или null).

- Если можно: вызывает whoPays.TryReserve(cost). Если false – значит денег не хватило (возвращаем Fail).

- Если резерв успешно: вызывает whoPays.Commit(cost) сразу (или можно публиковать событие и в подписчике списывать, но проще здесь).

- Создаёт объект BuildOrder (с нужными данными, можно добавить например ссылку на Economy or just type/pos).

- Публикует через EventBus: EventBus.Publish(order)[44].

- Возвращает order (может не очень нужно, но на будущее).

- Таким образом, BuildService отрабатывает синхронно при вызове Place, и реальный эффект (создание здания) произойдёт асинхронно, когда EventBus.Flush() доставит событие.

- Подписчик события: решите, кто будет создавать сам объект игры (например, спрайт башни на карте). Логично, чтобы это сделал, например, класс BuildingManager или сам MapSystem. Сделайте простой MonoBehaviour BuildingPlacer который подпишется на BuildOrder. В нём метод On(BuildOrder order): там вы, например, можете нарисовать на Tilemap специальный тайл в этой клетке, или создать GameObject с соответствующим спрайтом. Пока можно просто логировать: Debug.Log($"Building placed: {order.Type} at {order.Position}") чтобы убедиться, что цепочка работает.

- Хранение занятости клетки: Вам понадобится понимать, занята ли клетка уже зданием, чтобы CanPlace работал. Можно завести в InfectionSystem или отдельном GridManager флаг для клетки hasBuilding. Поскольку у нас Tilemap, можно использовать Tilemap to check (но лучше свой массив bool parallel to infectionGrid). На начальном этапе, можно хранить простейший Set<GridPos> occupiedBuildings.

- Обновляйте этот Set, когда строение построено (в On(BuildOrder) добавьте позицию).

- BuildService.CanPlace будет проверять, что !occupied.Contains(pos).

- Рассылка других событий (опционально): Подумайте, какие события могут быть полезны:

- Например, InfectionSpreadEvent: когда инфекция достигла определённого порога (скажем, новая область поражена). Вы можете публиковать событие, когда какая-то клетка заражается (но это много событий – лучше батчить, см. ниже).

- ResearchStartedEvent: если бы была система технологий, при начале исследования.

- BudgetChangedEvent: если экономика сильно изменилась (но обычно системы сами могут спросить).

- Для практики, можно реализовать, например, событие: если за тик заражено > X клеток, публиковать OutbreakEvent(region). Это может слушать стратегический ИИ, чтобы реагировать.

- Coalescing (склейка): Если много однотипных событий происходит одновременно, иногда их объединяют. Документ упоминает пример: "инфекция выросла в 50 клетках" – вместо 50 событий лучше одно с числом[45]. Если решите, реализуйте: собирать внутри InfectionSystem счетчик новых заражений, а после тик, если >0, публиковать один InfectionGrowthEvent(count) вместо множества.

- Но эти доп. события не обязательны сейчас – главное отладить на примере BuildOrder.

- Сохранение с учётом событий. Обновите логику сохранения (из модуля 2) так, чтобы:

- Сохранение происходило после завершения тика, когда все события обработаны. В SimulationLoop у нас вызов EventBus.Flush() последним[7]. Самый безопасный момент для сохранения – либо сразу после Flush (т.е. в конце Update()), либо вообще на паузе.

- Если вы делаете сохранение по кнопке, возможно, она ставит паузу и затем вызывает Save – это отлично.

- Главное: убедитесь, что вы не сохраняете в середине обработки событий или середине тика, иначе состояние может быть неполным (например, деньги списаны, а здание ещё не создано, или infectionGrid обновлён, а события о вспышках не разосланы).

- Добавьте проверку: если Save вызывается по событию (например, UI), то либо ставьте паузу перед вызовом, либо внутри SaveLoadService, если SimulationLoop.IsPaused == false, сначала сделайте SetPaused(true), потом Save, потом можно вернуть обратно (или требовать, чтобы игрок нажимал паузу).

- Тест: Постройте здание, в том же кадре сохраните, потом загрузите – здание должно присутствовать после загрузки. Если вы сохраняете до EventBus.Flush, то оно не будет записано (потому что ещё не создано). Значит, сохраняйте после flush.

- Можно реализовать, что SaveLoadService подписывается на какое-нибудь специальное событие RequestSaveEvent и обрабатывает его после flush, делая Save. Тогда UI может просто Publish RequestSave, а SaveLoadService сделает на своём On.

- Логирование и откладка команд. Для возможности анализа хода игры:

- Сделайте список или лог буфер для команд: например, List<object> commandLog в EventBus или GameManager, куда добавляете все опубликованные события-команды. Можно ограничивать длину, чтобы не рос бесконечно.

- Это поможет потом, если найдётся баг: посмотреть последовательность команд (например, игрок строил, строил, и что-то пошло не так).

- Откат команд (undo): В нашем RTS в реальном времени, откат не обязателен, но упоминался как удобный механизм[46]. Подумайте: вы можете реализовать, что каждая команда имеет метод Undo. Например, PlaceBuildingCmd.Undo мог бы снять здание и вернуть деньги. Пока это избыточно, но понимайте, что наличие команд логированых открывает эту возможность.

- Playback: Сохраняя командный лог, можно воспроизводить игру с начала для реплея или отладки. Это за рамками текущей задачи, просто знайте, что командный буфер такой опцией может стать.

- Логируйте EventBus.Flush: вы можете добавить в Flush вывод: [EventBus] Flushed (count=X)[47], где X – сколько событий было обработано. Это поможет видеть, что каждый тик flush работал и сколько событий в нём было.

- Логируйте каждое событие: возможно, не все, но важно, например, "[EventBus] BuildOrder processed for {Type} at {pos}" – либо в подписчике (BuildingPlacer) лог, либо в EventBus, когда доставляет (но лучше в подписчике, так виднее, кто обработал).

- Дополнительное – ECS event buffer: В документе упоминается, что в ECS вместо EventBus используются EntityCommandBuffer для структурных изменений[48]. Если решите потом частично перейти на ECS, вы будете подобный принцип использовать. Но сейчас не отвлекаемся, просто отметим: EventBus – аналог глобального посредника, в ECS – каждый систем имеет свой playback buffer.

#### Пошаговые указания к реализации

- EventBus: Код можно писать почти по документу[40].

- Поля: static Queue<object> q = new Queue<object>(); static List<object> subs = new();.

- Subscribe(object handler) { subs.Add(handler); } – желательно проверять на дубли или отписку, но пока можно без.

- Publish<T>(T e) { q.Enqueue(e); }.

- Flush() { while(q.Count > 0) { var e = q.Dequeue(); foreach(var h in subs) { try { (h as dynamic).On((dynamic)e); } catch(Exception ex) { Debug.LogError($"EventBus error: {ex}"); } } } }

- Вызывать EventBus.Flush() в конце каждого SimulationLoop.Update (после цикла while(acc>=tick) ) – мы уже вставили вызов в модуле 1, убедитесь, что так и осталось[7].

- BuildService и команда:

- Создайте класс (можно статический) BuildService с методом, или инстанс (если нужно хранить что-то, но вроде нет).

- Сделайте enum BuildingType { Tower, ... } и struct/record GridPos(x,y) или просто используйте Vector2Int.

- Стоимость строительства: определите, откуда брать. Можно хранить в ScriptableObject (например, BuildingDef) – но вы еще не сделали BuildingDef. Для теста можно сделать в коде словарь cost: Tower -> 50, Wall -> 20. Или если в Data/Buildings/BuildingDef (SO) у вас есть, можно использовать: тогда BuildService надо знать BuildingDef по типу. Если вы сделали ScriptableObject BuildingDef with Id = "Tower" cost=50, то можно сделать Dictionary<string,BuildingDef> from module 2 load. Допустим, у BuildService есть доступ к GameDataLoader.buildingDefs or something. Но чтоб не сложно: можно захардкодить пару значений.

- Implement IBuildService (from arch doc) so that interface has methods CanPlace and Place[43]. Use them as described.

- Where to call BuildService.Place? – Это будет вызвано, например, из UI (когда игрок нажимает кнопку постройки и указывает куда) или из AI (когда AI решит строить). Пока у нас ни UI строительства, ни IИ команды. Для теста можем вызывать BuildService.Place прямо в коде (например, после 10 тиков автоматически, или по клавише). Можно, например, сделать: на клавишу "B" строить Tower в случайной клетке (or fixed cell).

- So for demonstration: in Update (or better in a DeveloperConsole or InputSystem) – if(Input.GetKeyDown(KeyCode.B)) { buildService.Place(Tower, somePosition, playerEconomy); } – This simulate player command.

- Подписчик BuildingPlacer:

- Create BuildingPlacer MonoBehaviour, put on some GameObject (e.g., on the Tilemap or GameManager). In Awake: EventBus.Subscribe(this).

- Implement public void On(BuildOrder order) – in it, implement the actual placement:

- Mark the internal grid as occupied: occupiedBuildings.Add(order.Position).

- If you have a Tilemap and tile for building, you can do: tilemap.SetTile(order.Position, buildingTile). But that requires setting up tile in editor.

- For simplicity, instantiate a cube or sprite at that position: e.g., GameObject newTower = GameObject.CreatePrimitive(PrimitiveType.Cube); newTower.transform.position = new Vector3(x, 0, y); – That will show a cube where building is.

- Or if 2D, create a small sprite of a house and place it.

- If not comfortable with visuals, just log the placement.

- Also might want to inform other systems: for example, if building type influences infection (like fortification reduces infection spread in that cell), you could call infectionSystem.SetFortificationAt(order.Position, true) if you had such method. Could integrate: e.g., if order.Type is "Quarantine" or "Wall", you might reduce infection on neighbors. But that is advanced. For now, just note where building is so we don't allow another building same place.

- Saving buildings in GameState: Now that we introduced buildings, update GameState (from module 2) to include building data:

- E.g., have a list of built structures: List<BuildingData> where BuildingData has type and position.

- When saving, fill this list from your occupiedBuildings set.

- When loading, after restoring, you should recreate those buildings in the scene: e.g., call On(BuildOrder) for each or directly place them. Perhaps easier: after loading, loop through saved BuildingData and instantiate building objects (like how On would do).

- Alternatively, publish BuildOrder events during loading, but flush might need simulation loop – probably easier to directly place.

- Hook up Save/Load: If you have a UI, test saving after building something. Ensure load brings it back. If not, fix GameState to include necessary info (like building list).

- Testing event sequence:

- For thoroughness, simulate scenario: on same frame, player tries to build with insufficient funds:

- BuildService will fail (money not reserved) and return maybe BuildOrder.Failed or null. We didn't define BuildOrder for fail. We can handle: if TryReserve fails, we do not Publish anything and return null.

- So event not published, nothing happens – good.

- On success:

- BuildService publishes event, flush at end of tick calls On in BuildingPlacer, building created.

- Check money: playerEconomy should have been reduced by cost in BuildService at commit.

- So after building, money down by cost, building appears.

- If saving now, building is saved.

#### Логирование и отладка

- Проверка EventBus последовательности: Добавьте временно лог внутри Flush: "Flushing event: " + e.GetType().Name. Так вы увидите в консоли, когда и какие события обрабатываются.

- Однократная доставка: Убедитесь, что каждый опубликованный event доставляется ровно один раз всем подписчикам:

- Например, вызвали две постройки в одном кадре: два события в очереди. Flush должен обработать оба.

- Проверьте, что после Flush очередь пустая и события не остаются на следующий кадр (по коду видно, что нет).

- Подписка/Отписка: Если у вас есть перезагрузка сцены, EventBus.subs остается статическим. Тогда старые подписчики могут накопиться. Простое решение: при стартовой инициализации (например, в GameManager.Awake) вызовите EventBus.subs.Clear(). Или, лучше, не делать EventBus static global across play sessions – but likely it is static for whole runtime. Just be cautious if writing Editor tests etc., clear between runs.

- BuildService:

- Проверьте CanPlace: test scenario where you attempt to place on the same cell twice – second time should fail due to occupied. Try it, it should not allow and likely no event published second time.

- Money check: if cost > balance, TryReserve returns false, Place returns fail (or null) – no event, building not placed. In console ideally see ReserveFail warning from Economy. That's expected.

- Event order: If you publish events from within events (not our case yet, but imagine On(BuildOrder) publishes another event), note that flush processes queue fully. So if On(BuildOrder) publishes, that new event will be queued and processed in the same flush after current loop or next loop? Actually, our implementation: while(q.Count>0) so if On publishes, that event goes to queue, and current while will catch it and process it in the same tick flush. That's fine usually. But if you want to delay to next tick, you'd have to design differently.

- For now, fine. But be aware: events published while flush is running will be processed immediately after the current event finishes, before returning to SimulationLoop (i.e., still within this tick).

- Сохранение проверка:

- Save the game after some events. Then simulate load. If something was mid-process, might not appear after load.

- For example, if you saved right after calling BuildService.Place but before flush (if that happened, maybe because Save was triggered in same tick), then your saved game wouldn't have the building. But we ensure Save after flush on UI anyway. So do that: test saving via a UI button that calls Save. If you click it immediately after building, since flush happens end of frame, maybe the button event came next frame. Eh, likely flush already done by the time UI events processed. If not sure, implement a slight delay or requirement to pause then save.

- Alternatively, call Save in On(BuildOrder) after placing building (not recommended, but could).

- Coalescing events: If you did implement something like grouping infection events, test it: are multiple similar events combined as intended? If yes, ensure flush still picks them up properly.

- Командный лог и отладка:

- If you made a list of commands, after some gameplay, print it out or inspect via debugger to ensure it recorded all events. Possibly skip this if not needed.

- If something goes wrong (e.g., building not appearing but money gone), check logs: Did BuildOrder event publish? Did flush run? Did On(BuildOrder) get called? Perhaps a typo in method signature (On(BuildOrder order) must match exactly the event type).

- Dynamic dispatch issues: If On signature mismatches (like parameter type not exactly the class, maybe you used struct vs class?), dynamic might not find method. E.g., if BuildOrder is record (class by default) and you pass record instance, it should match On(BuildOrder).

- If doesn't call, consider using where T: class in Publish and (h as IEventHandler<T>) check. But dynamic is easier albeit less safe.

- Частые ошибки:

- Забыли подписать на EventBus: ensure BuildingPlacer does Subscribe(this). If not, no placement happens.

- EventBus not flushed: ensure SimulationLoop calls Flush at end even if game paused? Actually, if paused, flush won't be called (because in Update we return early). If the game is paused, might want flush events from before pausing. But likely you'd pause after flush anyway. It's a corner case: if an event triggered exactly at pause, might remain queued. Could handle in SetPaused(true): flush events first.

- Race conditions of save: as above, but if careful, fine.

- Not thread-safe: EventBus is not thread safe, but our game is single-thread (except jobs, but they won't publish events directly hopefully).

- Overloading On: If multiple On methods (overloads) in one class, dynamic chooses best match or might be ambiguous. Avoid having e.g., On(BuildOrder) and On(object) in same class, dynamic might call both or the more generic one. Keep it distinct.

#### Применение Codex GPT

- Генерация EventBus: Вы можете прямо запросить: «Реализуй класс EventBus на C# с методом Publish и Subscribe, использующий очередь для событий». AI наверняка выдаст нечто похожее на нужное.

- Использование dynamic: Если не уверены, спросите: «Как с помощью dynamic вызвать метод подписчика с подходящей сигнатурой?». Codex может объяснить или показать пример.

- Команда строительства: Попросите: «Напиши пример паттерна Command для строительства здания, с проверкой ресурсов». Возможно, получите код, аналогичный BuildService + команда.

- Взаимодействие с экономикой: Если сомневаетесь, правильно ли списываете деньги, спросите: «Как связать систему экономики и команду строительства в Unity?». Может подсказать, что вы уже сделали.

- Debugging: При сложных связях, можно описать Codex проблему: «Опубликовал событие, но подписчик не получает. Что проверить?». Он может подсказать проверить подписку, flush, method signature.

- Сохранение: «Как убедиться, что сохранение игры происходит после всех действий кадра?». Может предложить некоторые Unity patterns (like LateUpdate, etc., хотя EventBus flush already a kind of late update).

- Refactor: После всё работает, вы можете попросить AI улучшить код. «Предложи улучшения для EventBus реализации» – возможно, посоветует Generic approach. Но для учебных целей текущей хватит.

#### Тестирование и проверка результата

- Функциональный тест строительства: В игре (Play Mode), попытайтесь построить:

- С достаточным бюджетом: объект появляется, баланс уменьшается ровно на стоимость.

- С недостаточным: ничего не происходит, в консоли предупреждение об отказе, баланс неизменён.

- На занятом месте: второй раз на ту же клетку – должен отказать (можно лог "CanPlace returned false").

- Сценарий с последовательностью: Постройте 2-3 разных объекта (если реализовали разные types):

- Убедитесь, что каждый раз корректно: места заняты, баланс суммарно уменьшен, объекты присутствуют (например, 3 кубика на сцене).

- Попробуйте сохранить игру и перезапустить (если загрузка реализована): все постройки должны восстановиться.

- Если есть InfectionSystem effect (вы не делали, но если хотели) – например, если башня должна снизить инфекцию вокруг, проверьте, что InfectionSystem получил информацию (setFortification flag).

- Проверка событий:

- В логах должен быть виден порядок: например:

- TickStart
... systems update ...
TickEnd
[EventBus] Flushed (count=1)
[EventBus] BuildOrder processed for Tower at (10,5)

- Такого плана. Если flush count != events processed count, может значит, coalescing? But ideally one line per event from flush or subscriber.

- Нагрузите немного: publish 5 events in one tick (you can do that by calling BuildService.Place 5 times in one frame manually in code). Then flush should show count=5, and all 5 processed.

- Unit test approach: If possible, simulate events outside Unity:

- Write simple test where you create dummy subscriber class with On(SomeEvent) that sets a flag. Publish event, call Flush, see flag true. If works, EventBus is correct.

- Multi subscriber: Add two subscribers for BuildOrder (e.g., building placer and maybe another logger object with On(BuildOrder) that just logs). Ensure both get called (like see two logs).

- Profiling: EventBus is negligible overhead unless thousands events. But check GC: dynamic invocation might allocate some, but usually it's minor. Not a big worry in this context.

- Перед следующим модулем: Итак, на данный момент у нас:

- Стабильная симуляция (время),

- данные/сохранения,

- экономика,

- инфекция,

- базовый механизм взаимодействия (события, команды) и пример строительства,

- UI/Dev controls (пусть и примитивные) для управления паузой, скоростью, постройкой, сохранением.

Критерии готовности: Игра работает как маленький, но цельный цикл: можно поставить на паузу, изменить скорость, вспышки инфекции происходят, можно тратить бюджет на строительство объектов, которые отображаются. В логах видно, что всё происходит в правильном порядке и данные можно сохранить/загрузить.

Теперь мы переходим к мозгу игры – модуль искусственного интеллекта, который будет принимать решения на основе всего этого.

### Модуль 6: Система ИИ (стратегический и тактический интеллект)

#### Краткое описание модуля

Этот модуль посвящён разработке гибридной AI-системы для RTS, сочетающей несколько подходов: Utility AI для оценки приоритетов, GOAP (Goal-Oriented Action Planning) для планирования последовательностей действий и Behavior Trees для тактического поведения юнитов[49]. Такой гибрид позволит ИИ государства принимать осмысленные решения на стратегическом уровне (что важнее сейчас – сдерживать инфекцию, укреплять границы или инвестировать в исследования), выстраивать план для выбранной цели (например, для цели "сдержать очаг" – план из шагов: выделить бюджет, построить башни на периметре, отправить отряды) и управлять конкретными юнитами/отрядами на тактическом уровне (патрулирование, атака, ремонт).

Мы реализуем упрощённые версии этих систем: - Utility AI: набор критериев (considerations) с расчётом значимости разных возможных целей в виде нормализованных оценок 0..1[50]. Например, оценка "сдерживать очаг инфекции" зависит от размера текущих вспышек; "строить укрепления" – от наличия уязвимых точек; "исследовать технологию" – от дефицита средств против заражения и т.д. На каждом стратегическом интервале ИИ будет выбирать цель с наивысшим скором. - GOAP: определим несколько простых действий (Action) с предусловиями и эффектами[51], и одну-две цели (Goal). Построим план (можно вручную для простоты) или алгоритмически (поиск по состояниям) для выбранной цели. - Behavior Tree: смоделируем поведение отдельного юнита или группы. Используем простую структуру дерева решений: например, Selector с проверками угрозы, иначе патруль[52]. Реализуем узлы BT как классы или просто как методы с состояниями (Running/Success/Failure).

Важно: сделаем слой восприятия (Perception), откуда AI получает агрегированные данные о мире[53]. Создадим интерфейс IWorldState или набор функций, чтобы AI мог узнать уровень инфекции в регионе, силу обороны на клетке, наличие chokepoint и т.п. Для начала, реализуем только пару методов (например, InfectionAt(position) и HasFortification(position)).

#### Цели обучения

- Понять, как Utility AI помогает в выборе приоритета: научиться формулировать функции, оценивающие ситуацию и нормировать их на [0..1].

- Освоить принцип GOAP: задание целей, действий с предусловиями/эффектами, поиск плана. Даже если не полностью автоматизируем поиск, понять, как разбивать цель на действия.

- Разобраться в построении Behavior Tree: узлы-selector, последовательности, условия, действия. Научиться кодировать выполнение BT с сохранением состояния (какие ветки Running).

- Научиться соединять эти три подхода: Utility выбирает цель -> GOAP выдает план -> BT и/или скрипты выполняют конкретные шаги, плюс BT работает постоянно для реакции на окружение.

- Освоить техники логирования AI: печатать таблицу скорингов Utility[54], логировать сгенерированный план GOAP[55], выводить активные узлы Behavior Tree[56], и визуализировать influence maps (если используем).

- Использовать Codex для помощи в алгоритмах (например, поиск плана) и генерации шаблонных классов (для BT узлов).

- Уделить внимание производительности AI: тиканье не каждый кадр, разделение вычислений по времени (budgeted AI)[57].

#### Основные задачи (по возрастанию сложности)

- Utility AI – приоритеты стратегических задач. Определите 3–5 потенциальных целей для гос-ИИ:

- Примеры: ContainOutbreak (сдержать заражение в очаге), FortifyChokepoint (укрепить узкий проход/границу), ResearchVaccine (исследовать технологию лечения), SupportPlayer (помочь игроку ресурсами или юнитами).

- Для каждой цели разработайте функцию-оценку (Consideration), возвращающую значение 0..1 на основе текущего состояния мира:

- ContainOutbreak: например, берём максимальный уровень заражения среди всех регионов или количество заражённых клеток. Нормируем: 0 – нет инфекции, 1 – инфекция вышла из-под контроля. Можно: score = clamp((infectedCellsCount - threshold) / (maxCells - threshold), 0,1). Или проще: score = infectedCellsCount / totalCells (доля карты заражена).

- FortifyChokepoint: надо определить, есть ли "горлышки" (chokepoints). Можно грубо: если заражение близко к базе или к важной точке (например, столице) и там мало обороны. Определите условно, что если какой-то регион со стратегическим значением и он под угрозой, score высокий. Или просто наличие незакрытых проходов на границе безопасной зоны.

- ResearchVaccine: если инфекция растёт, а у вас нет технологий – повышается. Может зависеть от кол-ва доступных ресурсов (если ресурсов много, можно инвестировать).

- SupportPlayer: если у игрока мало денег или ситуация у игрока плохая (например, потерял много строений), гос-ИИ может помочь. Пока сложно симулировать, но можно: если playerEconomy balance << stateEconomy balance, то score для поддержки.

- Influence Maps: Создайте пару полей влияния для помощи в расчетах[58]:

- enemyPressure[x,y] – например, уровень инфекции или врагов в данной точке (можно взять infectionGrid normalized).

- friendlyStrength[x,y] – число оборонительных сооружений или юнитов (пока, скажем, 1 для каждой башни).

- Можно вычислить агрегаты: например, функция FriendlyStrengthIn(region) – считает количество башен в этом регионе. InfectionAt(pos) – уже есть в InfectionSystem.

- Реализуйте каждую Consideration как класс, реализующий интерфейс IConsideration с методом Score(IWorldState)[59]. Эти классы могут хранить параметры (например, порог threshold). Например, OutbreakPressureConsideration – см. документ пример.

- Создайте класс StrategicAI (можно MonoBehaviour, можно чистый), который хранит список целей и соответствующих Consideration. Например, можно просто хранить Dictionary<Goal, IConsideration>.

- Каждые N тиков (не каждый, чтобы не перегружать) – например, раз в 10 тиков – StrategicAI обновляет оценки:

- Для каждой цели вычисляет score = consideration.Score(worldState). Логирует эти значения (табличкой или JSON)[54].

- Выбирает цель с максимальным скором. Если она уже текущая цель и план по ней выполняется – можно оставаться. Если другая стала значительно выше – можно переключить цель (завершив предыдущую или прервав, в реальности).

- На данном этапе, для простоты, можно сразу переключать на новую топ-цель каждый интервал, чтобы посмотреть разные реакции.

- GOAP – планирование действий для выбранной цели. Определите набор Action (действий), которые ИИ может предпринять:

- Действия можно привязать к целям. Например, для цели "ContainOutbreak":

- Action1: AllocateBudget – увеличить резерв на оборону/карантин на X (предусловие: бюджет > X, эффект: оборонный ресурс увеличен).

- Action2: BuildTowers – построить Y башен на рубеже (предусловие: есть свободные позиции на фронте, есть бюджет, эффект: укрепления на фронте).

- Action3: DeployUnits – отправить отряд (если бы у нас были юниты).

- Для "ResearchVaccine":

- Action: StartResearch – потратить деньги и время на технологию (предусловие: есть нерешённая технология, эффект: технология начата/завершена).

- Для "SupportPlayer":

- Action: SendFunds – перевести часть бюджета игроку (предусловие: баланс гос > X, эффект: баланс игрока +X, баланс гос -X).

- Реализуйте интерфейс IAction с методами: Preconditions(IWorldState), Execute() (или Apply) и Cost()[51].

- Preconditions: проверяет, можно ли выполнить (например, для BuildTowers: есть ли незакрытые chokepoints).

- Execute: собственно, делает действие (в нашем случае, может быть: вызывает BuildService.PlaceTower на конкретной клетке, или просто publishes Event "DeployUnits").

- Cost: для планирования, можно возвращать ресурсную стоимость, или время. GOAP планер обычно ищет минимальный cost план. У нас небольшие деревья, можно не заморачиваться, просто возвращать, например, 1 для кажд. действия, или actual money cost.

- Planner: Для демонстрации, не обязательно писать универсальный A* planner. Можно захардкодить мини-план: например, если цель = ContainOutbreak, план = [AllocateBudget, BuildTowers]. Если цель = SupportPlayer, план = [SendFunds]. И т.п. Но лучше попробовать автоматический:

- Можно реализовать очень упрощённый поиск:

- Начальное состояние: текущий мир (например, availableBudget = X, towersBuilt = false, etc., abstract).

- Цель: условие, которое нужно достичь (например, infectionContained = true).

- У действий укажите эффекты (можно просто булевые, e.g., BuildTowers -> towersBuilt=true).

- Тогда планер (BFS/DFS) будет пытаться применить действия, удовлетворяющие предусловия, и смотреть, достигается ли цель.

- Для учебных целей, можно не погружаться глубоко: покажите концепцию – у вас есть цепочка действий, которые логируются как план.

- В StrategicAI, после выбора цели, вызывайте Planner.Plan(goal). Полученный список действий сохраните как текущий план.

- Логируйте план: например, [AI] Plan for ContainOutbreak: AllocateBudget -> BuildTowers -> ...[55].

- Выполнение плана: Можно выполнять по шагам:

- Завести, например, переменную currentActionIndex. Каждые N тиков (или каждый тик) проверять: если текущий план не пуст:

- Если предусловия текущего действия выполнены – выполняем (например, вызываем Execute()) и переходим к следующему.

- Если не выполнены – может, нужно сначала что-то (в реальном GOAP, порядок гарантирует, но если что-то поменялось, можно перепланировать).

- После выполнения последнего действия, цель считается достигнутой или цикл заново оценит Utility и выберет новую.

- Можно упростить: сразу выполнить все действия подряд (но если они должны распределяться по времени, лучше растянуть). Для стратегических – можно несколько тиков, но не критично.

- Привяжите реальные системы:

- Например, AllocateBudget – может просто log, т.к. у нас нет детализации бюджета по статьям (или можно уменьшить playerEconomy, но зачем). Можно skip actual effect, или simulate by storing a variable "defenseBudget += X".

- BuildTowers – здесь можно интегрироваться: найти позиции на фронте инфекции (можно взять пару клеток, где infection level just at border), и вызвать BuildService.Place(Tower, pos, stateEconomy). Это круто, если сработает: ИИ сам строит башни. Если денег хватит – Economy уже в системе.

- SendFunds – implement as: stateEconomy.TryReserve(X) and if true, playerEconomy.Commit(X) (basically transfer). Or simpler, directly do stateEconomy.Balance-=X; playerEconomy.Balance+=X. Also publish event for UI if any.

- StartResearch – if had techs, could toggle a tech as researched. For now, maybe skip actual effect.

- Behavior Trees – тактическая логика. Если у нас будут юниты (в RTS обычно есть), Behavior Tree управляет их действиями. Пока у нас нет реализованных юнитов, но можем смоделировать на примере ремонта башен или патруля:

- Допустим, у игрока/ИИ есть рабочий или солдат (представим один объект). Он может: патрулировать, чинить постройки, реагировать на угрозу.

- Построим BT:

- Selector
  ├─ If(ThreatNear) -> Sequence( MoveToThreat, Attack )
  ├─ If(DamagedBuildingExists) -> Sequence( MoveToBuilding, Repair )
  └─ Patrol

- В псевдокоде выше: проверяется, есть ли угроза рядом (например, инфекция прорвалась в безопасную зону). Если да – прервать рутину и "отправить отряд" (в игре: spawn unit or move existing), но у нас нет боёв, можно просто лог: "Unit would attack threat at X".

- Иначе, если есть повреждённое здание (для примера, представим, что заражение может "повреждать" постройки, или просто случайно сделаем здание нуждающимся в ремонте): тогда юнит идёт туда и "чинит".

- Иначе – патрулирует (можно лог или перемещать по маршруту).

- Как реализовать:

- Сделайте класс BehaviorTree с узлами. Узлы могут быть разными типами: Selector, Sequence, Condition, Action, etc.

- Для простоты, можно не делать целую иерархию, а в коде BehaviorTree.Tick() прописать логика:

- if(threatNear) {
    // perform attack sequence
    ...
    return;
}
if(damagedBuilding) {
    // perform move & repair
    ...
    return;
}
// else
patrol();

- Это не чистый BT с state though.

- Лучше: Implement Node base class, and composite classes for Selector, Sequence, etc.

- Each node has a method Execute() returning enum Status { Running, Success, Failure }.

- Selector: iterate children until one returns Success/Running.

- Sequence: iterate children until one fails (like typical BT).

- Condition node: returns Success if condition true else Failure (and often immediate).

- Action node: executes some action (like move or attack) and returns Success if done, Running if ongoing (like moving takes time).

- Memory for Running status: If an action is Running (e.g., unit moving, not finished in one tick), we need to preserve that state and call its Execute again next tick.

- Real BT frameworks have node state or the tree is ticked each frame and nodes maintain state in fields.

- We can simulate Running by e.g., splitting an action into multiple ticks or using a coroutine concept. But to keep it simple:

- For demonstration, we might not simulate actual long actions, just logs. Or we can simulate "movement" by a counter that counts ticks to reach target.

- If doing the structure is too heavy, we can fallback to simpler logic or pseudocode demonstration in logs.

- Attach BehaviorTree to some "unit" (maybe we consider the player has a mobile unit).

- Integrate with event system if possible: e.g., if threat appears, maybe publish an event that unit picks up. But let's keep it internal to BehaviorTree check for now.

- Logging:

- Each tick, log which branch executed (e.g., "Threat detected -> Attack sequence running" or "No threats -> patrolling")[56].

- If we had node IDs or names, log active path (some dev tool print).

- Keep logs minimal to not spam but enough to debug logic.

- For demonstration: you can simulate a scenario:

- Infect some area near base (set threatNear=true by checking if any infected cell within some radius of base coordinate).

- Then BehaviorTree should choose Attack branch (log it).

- If no infection, but we mark a building as damaged (simulate a building needing repair by a variable), then it should go repair branch.

- If neither, patrol (log "patrolling...").

- Though we do not have actual game objects moving, you can incorporate the idea. Maybe if time, instantiate a "unit" GameObject that moves (like moves one step per tick to target pos) to illustrate Running state.

- BehaviorTree tick frequency: likely every tick for unit AI, as tactical decisions can be quick. If worried performance, can do every couple ticks for heavy tasks, but a single unit is trivial.

- Перцепция и Influence maps. Implement part of IWorldState (or directly integrate in Utility) to provide the AI the info it needs:

- Provide methods in StrategicAI or a WorldState class:

- InfectionAt(GridPos p): returns infection level at that cell (this can just read from InfectionSystem grid)[53].

- HasFortification(GridPos p): check if there's a building/tower at p (we track occupiedBuildings)[53].

- FriendlyStrengthIn(Region r): If you define "region" (maybe chunk of map or around base), compute sum of friendly units/buildings. For now, maybe define one region "base" and count all towers or a constant if any tower present.

- IsChokePoint(GridPos p): we may not have calculation for that; but maybe we can set manually certain coordinates as chokepoints (like a narrow pass coordinate). Or simply, define a couple positions and pretend they are passes. Or don't use it to avoid complexity.

- Influence maps:

- If you want to be fancy: compute an array infectionInfluence[x,y] as some diffusion of infection presence (which might just be the infection levels themselves).

- But doc2 suggests incremental update of influence and caching, which is advanced. We might skip heavy computing and say influence = infection level or a blurred version.

- Friendly influence: maybe for towers, mark influence radius around them for defensive influence (like each tower influences nearby 5 cells).

- These influences can be used by Utility scorers (e.g., if a region shows high infection influence and low friendly influence, the score for contain outbreak is high).

- Implementation: you could do a pass on infection grid and create an influence map (like convolution).

- E.g., for each infected cell add value to neighbors at distance (maybe like a Gaussian blur).

- But if time short, you can skip actual calc and approximate with counting infected vs towers as we do in Utility.

- Ensure that what Utility or BT asks is provided by these worldstate functions (e.g., BehaviorTree threat detection: "threat near base" might mean check infectionInfluence at base > some threshold).

- Provide worldState to considerations (they implement Score(IWorldState)).

- This means StrategicAI should have or be IWorldState or have reference to systems to implement IWorldState methods.

- Could implement IWorldState in StrategicAI, where StrategicAI has references to InfectionSystem, building list, etc.

- Check that these queries are efficient: our map is not huge so fine, but in general would consider caching heavy ones.

- AI integration and execution. Tie everything together:

- Create an object StrategicAI (the state brain) and maybe a TacticalAI if separate (or incorporate BehaviorTree within StrategicAI for now).

- Tick frequency:

- Strategic decisions (Utility evaluation and GOAP planning) we do less often, e.g., once per second or every 10 ticks[57]. We can achieve by counting ticks in SimulationLoop or StrategicAI itself (like only act when tickCount % 10 == 0).

- Tactical Behavior we can run more frequently (maybe each tick or every 2 ticks).

- Document suggests making strategic layer tick less frequently than tactical[57].

- In SimulationLoop, add calls:

- e.g., every tick: TacticalAI.Tick(dt),

- every 10th tick: StrategicAI.Tick(dt) (which internally does Utility and possibly triggers actions).

- Or incorporate as separate MonoBehaviours scheduled differently. But easier to manage from SimulationLoop.

- Confirm orders:

- If StrategicAI triggers a BuildService.Place, that event flows through event bus and building appears (so AI physically builds stuff).

- If it triggers sending funds, that directly alters balances.

- If research or other, track logically.

- After setting up, run the simulation:

- Start with some infection scenario and some starting budgets.

- Let AI run through, see which goal picks:

- If infection present, likely ContainOutbreak highest, triggers plan to build towers (money permitting) etc.

- If infection small and base safe, maybe Research or something chosen.

- Without infection, perhaps picks SupportPlayer or idle if none triggered.

- Check logs for Utility scores, plan chosen, plan executed, Behavior tree acting possibly.

- See results: Are towers placed where needed? Are finances adjusting?

- Possibly you'll see multiple towers built (draining economy) if not regulated by cost or by plan stops after one.

- You could add that after building once, outbreak contained (score goes down next evaluation).

- Behavior Tree:

- Try simulate an infection approaching base to see if BT logs "attack threat".

- For building repair, if none integrated, you might simulate a building "damaged" by just marking a variable. Then see if BT picks it up.

- Debug overlays:

- If possible, use Unity Gizmos or UI to show influence maps:

- E.g., in OnDrawGizmos, draw heatmap of infectionInfluence in another color vs friendlyInfluence.

- Or at least draw lines or icons: could draw a blue sphere at position of highest infection (like marking outbreak).

- Or draw text above towers showing "HP" if any concept of damage.

- For BT, you could show a line from unit to target if moving to repair or attack (if we had actual coordinates).

- Possibly more advanced than needed, but helpful if you can illustrate e.g. which chokepoints considered or where towers built.

- Performance:

- Our AI logic is light due to small scale, but note:

- Utility evals reading some arrays - fine.

- GOAP planning trivial here.

- Behavior tree one unit trivial.

- But if many units, BT per unit could add up, one might budget them (like update different units in different ticks).

- Also utility can be split (some scorers this tick, others next) to avoid spike (that's the "budgeted AI" concept).

- We won't see performance issues at this scale, but log if you want how long Utility calc took. Possibly integrate with profiler for curiosity.

- Advanced improvements (optional):

- Incremental Utility: If some scores are heavy (like scanning whole map for infection count) every time, you could cache these results or update incrementally each tick (e.g., track infected count in InfectionSystem, then just use that number).

- Learning weights: Usually Utility can have weights or curves. We can assume all normalized and equally important for now. Or manually adjust if one always overshadow others (like if infection present, likely that always top).

- Communication: If we had multiple agents (like allied AI, or multiple factions), could have events or shared knowledge. Not needed here.

- Adapting to player: The SupportPlayer goal is a bit stand-in for something interactive (like if player struggling, AI help). Hard to simulate beyond just transferring money. Could skip if not meaningful now.

- Multiple units: If wanted to simulate a small squad, you could spawn few dummy units and each runs a copy of BehaviorTree with slightly different tasks (or one BehaviorTree controlling group).

- UI for AI: Perhaps final overlay showing current AI goal and plan ("AI currently focusing on Outbreak containment") etc. This can help debug but not required.

#### Пошаговые указания к реализации

- Utility Considerations:

- Create classes like ContainOutbreakConsideration, FortifyConsideration, etc., each deriving from IConsideration (with float Score(IWorldState)).

- Implement Score: you have worldState accessible. For ContainOutbreak: maybe float infectedRatio = worldState.TotalInfected() / worldState.TotalCells(); return Mathf.Clamp01((infectedRatio - 0.1f)/0.5f); as an example. Or simpler: return worldState.TotalInfected() > someThreshold ? 1 : worldState.TotalInfected()/threshold;.

- For Fortify: maybe check if any choke point (pretend we have one at some coordinates) is adjacent to infected area and no fortification there: if yes, return 1, else 0. This could be binary or gradually: if infection is within X distance of base and no towers in between, high score.

- For Research: maybe based on time or just default medium if others low.

- For SupportPlayer: if playerBalance < some threshold and stateBalance high, then moderate-high score.

- We'll likely tune by observation: the relative scales might cause one to always dominate. Possibly fine if infection always triggers that path, because that is logically pressing.

- After implement each, gather them in StrategicAI.

- StrategicAI:

- Fields: list of goals (could be just an enum or string names) and corresponding Consideration, and maybe an active plan.

- Possibly define a small class or struct for Goal: with name, maybe a target location if needed (like "fortify at (X)" if applicable).

- Actually, some goals naturally have target (outbreak location, chokepoint coordinate). We can incorporate in planning stage: e.g., if ContainOutbreak chosen, find coordinates of worst outbreak region and pass to plan actions (like build towers around that region).

- Could store that as part of goal selection: like maintain GridPos targetOutbreakCenter.

- For simplicity, perhaps pick the first infected cell or the one with highest level as target for containment. Determine that in Score function or after choosing goal.

- Implementation: maybe have worldState provide GetLargestOutbreakCenter() returning a pos. Then StrategicAI can pass that to BuildService or others.

- Method Tick:

- if tickCount % 10 !=0, maybe skip (so only do every 10).

- Compute all scores:

- float bestScore = -1; Goal bestGoal = null;
foreach(var (goal, consideration) in goals) {
   float s = consideration.Score(this /*assuming this implements IWorldState*/);
   Log($"[Utility] {goal.Name} score = {s:F2}");
   if(s > bestScore) { bestScore = s; bestGoal = goal; }
}

- If bestGoal != currentGoal or if no currentPlan or plan done:

- currentGoal = bestGoal.

- Plan plan = Planner.Plan(bestGoal).

- currentPlan = plan (list of actions).

- currentActionIndex = 0.

- Log ("Selected new goal: X, planned actions: ...").

- Else if bestGoal same as currentGoal, perhaps continue existing plan, unless replan needed (if something changed drastically, you could replan, but skip complexity).

- Then handle executing plan:

- If currentPlan not null:

- If currentActionIndex < plan.Count:

- var action = plan[currentActionIndex];

- If action.Preconditions(worldState) are met:

- Do action (some actions might be instantaneous like sending funds, some might involve waiting like building might take time but we treat as immediate after calling BuildService).

- Log action executed.

- currentActionIndex++.

- else:

- If precond fails (maybe world changed so plan invalid?), could replan or skip. For simplicity, re-check preconditions rarely fails since we planned on current world state. We might ignore this scenario or just replan entire goal if fails.

- If currentActionIndex >= plan.Count:

- Plan done. Possibly log "Goal achieved or plan completed".

- Could either set currentGoal = null to allow new selection, or keep it and rely on utility next tick to maybe switch (if still top, maybe have to come up with a new plan or maintain).

- Possibly some goals are continuous (like containOutbreak might never "finish" until infection gone). You could then plan again next time with maybe same actions if needed.

- We can set plan = null to force new utility evaluation next cycle (which happens anyway).

- It's possible multiple actions in plan should not all be done instantly in one tick (like building multiple towers might better do one per tick or so).

- We can choose to execute one action per strategic tick call. That might naturally spread by the tick frequency:

- Because if StrategicAI.Tick is only called every 10 ticks, then each call executes one action of plan. That spreads them out.

- But our plan likely short and one time actions, so either is fine.

- Let's choose to do at most 1 action per call to StrategicAI.Tick for realism. Use a loop break after one.

- That means a plan might take multiple cycles to complete, which is okay.

- Ensure to incorporate the effect:

- If BuildService called, event bus will handle building (so possibly by next tick towers exist).

- If multiple towers to build, plan might list action BuildTower three times. If we do one at a time per call, it will build one tower per 10 ticks for example.

- If find that too slow in demonstration, you can allow more frequent or multiple actions per tick for brevity.

- Planner:

- Could implement a trivial one:

- If goal == ContainOutbreak: plan = [ new BuildTowerAction(target= worldState.GetLargestOutbreakEdge()) ] (maybe allocate budget action if needed, but if economy handled cost anyway, not needed separate).

- If goal == FortifyChokepoint: plan = [ new BuildTowerAction(target = chokepointPos) ] (like identify one known chokepoint coordinate).

- If goal == SupportPlayer: plan = [ new SendFundsAction(amount = maybe some portion of stateEconomy.Balance ) ].

- If goal == Research: plan = [ new ResearchAction(tech = some pre-defined tech) ].

- If already built and research done, maybe do nothing next time.

- This is more like a rule-based plan than algorithmic GOAP, but given limited scenario, it's fine.

- If implementing generic:

- Make simple state representation:

- A state could have booleans like hasFortified, hasResearched, and values like money.

- Goals define desired booleans true.

- Actions define which booleans they set and what they require true/false.

- Then DFS until find all goal conditions satisfied (with some limit).

- But might be overkill. We'll do the rule approach to ensure something plausible happens.

- Action classes:

- For each action:

- e.g., BuildTowerAction : IAction:

- Has maybe a target GridPos or Region it will build in.

- Precondition: worldState.HasFortification(target) is false AND worldState.InfectionAt(target) > 0 maybe (meaning it's at frontier).

- Execute: call BuildService.Place(Tower, target, stateEconomy). If returns successful (BuildOrder event), consider it done.

- Could also directly place building if wanting immediate, but better to go through BuildService to use event flow and economy.

- This action might fail if not enough money (which BuildService would handle internally). Possibly we should check economy before calling or catch if returns fail (lack money).

- If fail, maybe mark precond false next tick or re-evaluate plan. But keep it simple: assume enough funds (we can ensure by not choosing to build if not money by Utility or by adding an AllocateBudget before).

- SendFundsAction : IAction:

- Precondition: stateEconomy.Balance >= X.

- Execute: stateEconomy.TryReserve(X) & Commit, playerEconomy.Commit(X). Or we could create an event and do it via EventBus, but direct is fine.

- It's effectively done immediately.

- ResearchAction : IAction:

- Precondition: some tech not researched.

- Execute: perhaps reduce economy balance by cost (like spending money) and mark tech done (set a bool).

- This action mainly to demonstrate could tie to an actual future effect like unlocking something, but here just conceptual.

- AllocateBudgetAction:

- Precondition: none (or maybe if we had internal budgets).

- Execute: simply log or adjust an internal field "defenseBudget += amount".

- This could be used if building towers needed to allocate money ahead, but since our economy is just one pool, not needed really. Possibly skip implementing this, or implement but it doesn't do anything real.

- Add these classes under StrategicAI or separate files accordingly.

- Behavior Tree Implementation:

- Suppose you have one unit to manage (maybe state or player unit).

- Create a class UnitAI with a BehaviorTree or equivalent logic in Update.

- If you want to simulate movement:

- For Attack: we don't have actual enemies, could simulate by printing "Engaging threat at (x,y)" and maybe after 3 ticks say "Threat neutralized".

- For Repair: if you want, you can mark a building "damaged" and then "repair it" by some action that could increase its HP. But since we don't simulate damage, perhaps have an event or trigger to simulate that.

- Actually, we could simulate building damage due to infection:

- If an infected cell is near a building, mark that building as damaged or destroyed after some time (just as scenario).

- Then BehaviorTree sees damaged building, goes to repair (which could just log "Repairing building at X, done").

- Patrol: maybe just log "Patrolling area" each time if nothing else to do.

- Implementation can be as simple as:

- if(threatNearBase) {
   // Attack sequence (simulate time maybe)
   if(not already moving/attacking) { Log "Unit heading to threat"; set state "attacking" and maybe store target; }
   else { // in progress
       // after a couple ticks, assume done:
       if(counter++ > someValue) { Log "Threat eliminated"; state = Idle; counter=0; }
   }
} else if(damagedBuildingExists) {
   if(state != "repair") { Log "Heading to repair building X"; state="repair"; }
   else {
       if(counter++ > someValue) { Log "Building repaired"; state = Idle; counter=0; mark building repaired; }
   }
} else {
   if(state != "patrol") { Log "Patrolling..."; state="patrol"; /*maybe set a random patrol point*/ }
   // we could toggle patrol state or just log repeatedly
}

- This is more state machine-like, but can mimic a BT's behaviour.

- Alternatively, code a simple BT structure:

- Define objects for conditions and actions:

- Condition threatNear: returns true if any infection within e.g., 10 tiles of base.

- Action AttackThreat: if not at threat location, "move" (increment a step), else "attack" (simulate done).

- With small environment, easier to stick to state machine approach as above.

- For demonstration clarity, a state machine is fine, as long as we log decisions similarly to BT logic (because conceptually it's same branches).

- If more ambition: implement Node classes and a root node that you tick:

- But due to time, the state machine approach is acceptable. If logs clearly show the fallback logic, it suffices.

- One more integration: Behavior tree could also be influenced by events:

- E.g., if EventBus published an AttackCommand, the unit would go attack. But here threat detection is automatic from environment.

- Or if building got an Event "BuildingDamaged", unit responds. That might be more realistic:

- Could do: when infection infects a cell with building, publish BuildingDamaged event. UnitAI subscribes and on event sets state to go repair that building. That would be interesting demonstration of event interplay.

- If time: possibly simulate that:

- in InfectionSystem, if an infected cell neighbors a tower, publish BuildingDamagedEvent(pos).

- UnitAI On(BuildingDamagedEvent e) => drop whatever and set target to e.position for repair.

- That would emulate reactive behaviour triggered by events, which is often how it can be done (subscribe to events in BT).

- But without actual infection damaging code, you could artificially fire such an event by pressing a key or at some time to test.

- This might complicate but adds show of event usage beyond building.

- Up to whether implement given time, but even just logging with check is fine.

- AI testing scenario:

- At start of game, maybe spawn an infection cluster not too far from a defined "base" area.

- Place maybe one initial tower (simulate base defense).

- Provide stateEconomy some funds (like 200).

- Provide playerEconomy maybe some too (like 50, though if support triggers they get more).

- Then run:

- Infect spreads, Utility likely picks ContainOutbreak with high score. Plan: build tower(s). Should call BuildService => towers appear around infection hopefully (depending how we pick location).

- If build location selection not implemented (we might default to just build at a preset position near outbreak).

- Could simply do: target = one of infected cell's coordinates for building. But building on infected cell not realistic, maybe a neighbor. But either is demonstration.

- Or do: find frontier cell (Susceptible neighbor to infected) and build there. But time may be short for that logic, can cheat by building at infected cell itself to show something built.

- After building, infection might be "contained" in a sense (no, it will still spread unless building had effect which we did not implement).

- We could incorporate an effect: if tower present at a cell, maybe infection doesn't spread beyond? If so, that's actual containment. But we didn't implement infection effect of fortifications. We could:

- Quick fix: in InfectionSystem.Tick, if a cell has tower (fortification), reduce neighbor spread by factor for those directions.

- For demonstration, maybe not needed, just building stands as if defense.

- If stateEconomy becomes low after building some towers, maybe SupportPlayer might take priority (if we gave a condition like if no outbreak or if they think player needs help).

- If infection ended or slowed, maybe support triggers. If not, support might always be lower because outbreak still pressing.

- Behavior Tree unit:

- if infection near base triggered, logs "attacking threat at (pos)" a few times then "threat eliminated".

- If we simulate building damage, see logs "repairing building at X".

- If nothing, "patrolling".

- Check that these transitions happen logically.

- Watch economy values after building: money should reduce accordingly.

- Possibly the AI might overspend and not have enough for further actions (like if towers are expensive). That's fine, then maybe plan actions will fail if no money (we should log if BuildService returns fail).

- Could add logic: if BuildService returned fail, log "Not enough funds, cannot execute BuildTower".

- Maybe next utility evaluation might then decide something else if can't build.

- Save/Load to ensure the new towers, any changes persist (though AI states may not fully persist in current design unless we saved internal states, but not needed if Save soon after building etc).

- Also verify our logs coverage:

- Utility scores printed occasionally,

- Plan logged,

- Each executed action logged,

- Behavior tree actions logged.

- That gives a nice trace of the AI's thinking and acting.

#### Логирование и отладка

- Utility scores table: Check that all scores appear and make sense. For example:

- [Utility] ContainOutbreak = 0.75
[Utility] FortifyChokepoint = 0.20
[Utility] ResearchVaccine = 0.10
[Utility] SupportPlayer = 0.05
Chosen goal: ContainOutbreak

- If any score is 0 or 1 constantly, might need adjusting calculation (maybe saturating).

- If always one goal is maxed, others never chosen (which might be fine if outbreak persists). But test scenario with no infection: do we then see research or support become top? If no infection, containOutbreak score should be 0, others might have some baseline.

- Possibly define baseline or default so AI just doesn't idle if no pressing issues: e.g., research could have baseline 0.2 always if not done. So in times of peace, it picks research.

- Plan log: After goal selection, you should see something like:

- [AI] Plan for ContainOutbreak: BuildTower(x=...,y=...) -> (maybe multiple if you did)

- Or if plan more than one action:

- [AI] Plan for SupportPlayer: SendFunds(50)

- Action execution: Each executed should log:

- [AI] Executing BuildTower at (10,12)

- Then separate logs from event system:

- [Economy] ReserveFail... (if fail)
[EventBus] Flushed (count=1)
[EventBus] BuildOrder processed for Tower at (10,12)

- So you can correlate AI's intent with actual outcome.

- Behavior logs:

- [UnitAI] Threat detected near base -> engaging
[UnitAI] Threat eliminated.

- or

- [UnitAI] Repairing tower at (8,8)
[UnitAI] Tower repaired.

- or "Patrolling...".

- Ensure the conditions trigger properly:

- Simulate threatNear by maybe setting one infection at base coordinates (like InfectSystem infect base, causing threshold cross).

- After "eliminated", maybe you remove that infection cell to simulate cleared.

- If building repair triggered by event or check, ensure you simulate a building's "health" status variable.

- If using event for building damage:

- Infect a cell adjacent to a tower position -> in InfectSystem you can check each infected cell, if any building within 1 tile, publish BuildingDamaged.

- That event triggers UnitAI On(BuildingDamagedEvent) which sets a target for repair.

- Then logs "Heading to repair ...".

- If multiple events, unit might get spam. Could handle only one at a time (e.g., ignore new if already busy).

- It's fine just to show one scenario.

- Timing:

- Confirm StrategicAI tick frequency working: you can print tick count in logs to see that it only prints scores every 10 ticks, not every tick (ensures we aren't doing heavy calc every tick).

- Behavior every tick likely, fine.

- Utility fragmentation: If one score needed heavy calc, could do e.g., compute outbreak data on tick5 and fortify on tick6 etc. But probably unnecessary now.

- Correctness:

- See that towers built by AI indeed at least attempt to be placed where needed.

- If plan had multiple towers but economy only enough for one, after first, economy might not allow second:

- If your plan tries second immediately, BuildService will fail (money).

- If one action per tick, then on second tick it fails, maybe you catch that and might re-evaluate plan next cycle (since likely containOutbreak still high but now it might plan differently or realize budget low).

- We didn't code adaptively for fail, but as long as logs note fail, it's okay. Could improve: if build fails due lack funds, maybe set some cooldown or reduce containOutbreak score (since can't do anyway without money).

- Not needed to fix, just acknowledge if appears in log.

- Edge conditions:

- If infection goes to 0 (like after some time in simulation if you manually clear it or in test scenario you stop it):

- Then containOutbreak score should drop to 0, AI picks next goal (maybe research).

- This switch should show in logs at next utility evaluation.

- If infection goes extremely high:

- Score saturates at 1, always picks that. That is fine, AI will keep trying same goal. Possibly building more and more towers until funds end.

- If that happens, might observe multiple towers placed. Good to see event bus coping with multiple events. Should be fine.

- Performance:

- With our small numbers, likely negligible. Just ensure no endless loops or something if plan logic had mistakes.

- If we attempt pathfinding later (module 7), note that if many path queries from AI could be heavy, but we haven't integrated pathfinding yet here.

#### Применение Codex GPT

- Utility & Scoring:

- Ask for advice: «Examples of Utility AI considerations for RTS?». Possibly get ideas like "if enemy units > threshold then defense score high", etc. Adapt to infection context.

- «How to normalize values for Utility AI scoring?» might yield formulas or best practices (like using logistic curves, etc.). For now, linear clamp is fine.

- GOAP:

- «Simple GOAP implementation in C#» may produce code. There are known examples. Ours is simplified but reading those could inspire how to structure.

- «GOAP FEAR Orkin summary» might give description which matches doc mention[60]. But we won't go that deep now.

- Behavior Tree:

- «C# Behavior Tree example» could produce an implementation outline. Useful if we wanted to implement classes Node, etc. Possibly too heavy to do fully correct now, but check:

- Actually, doc snippet suggests an example structure, but not an implementation. Codex might produce a quick BT code. Might be instructive but possibly too large to integrate completely now.

- We can still attempt for curiosity.

- If it's short and understandable, incorporate piece or two.

- E.g., «Implement a simple behavior tree with Selector and Sequence nodes in C#» - let's see what it suggests.

### Модуль 7: Поиск пути (Pathfinding) на карте

#### Краткое описание модуля

В реальном времени юниты или агенты игры должны уметь находить путь по сетке (тайловой карте) – обходить препятствия (например, заражённые зоны, горы, стены) и выбирать кратчайший маршрут. В этом модуле мы реализуем алгоритм A (A-star) – стандарт для поиска кратчайшего пути в сетках – и рассмотрим расширения: ускорение поиска через Jump Point Search (JPS) на сетке и идею иерархического поиска (HPA)** для больших карт[61].

Базовый A обеспечит корректный поиск пути, а JPS оптимизирует его на больших открытых областях за счёт пропуска промежуточных узлов. HPA (Hierarchical Pathfinding) – это продвинутый подход, где карта разбивается на кластеры, и поиск ведётся сначала между кластерами, затем уточняется внутри – он значительно ускоряет навигацию на огромных картах[61]. Мы реализуем A и, при желании, JPS; HPA опишем концептуально для понимания.

#### Цели обучения

- Научиться представлять игровое поле для алгоритмов pathfinding: задать проходимость клеток (walkable/blocked), веса (стоимость) и эвристику.

- Реализовать алгоритм A* поиска пути: работа с множествами open/closed, расчёт стоимости пути, эвристической функции (например, манхэттеново расстояние) и восстановление найденного маршрута.

- Понять ограничения A и области его оптимизации. Освоить Jump Point Search – улучшение A для равномерных сеток, уменьшающее количество проверяемых узлов за счёт «прыжков» по прямым линиям.

- Понять концепцию иерархического pathfinding (HPA*): научиться разбивать карту на области и прокладывать маршрут сначала на абстрактном уровне областей, а затем детализировать – хотя бы на уровне мысли, без полного кода.

- Научиться отлаживать алгоритмы поиска: визуализировать открытые/закрытые узлы, финальный путь, сравнивать длины путей от разных алгоритмов[62].

- Интегрировать поиск пути в игру: уметь вызывать функцию pathfinding для перемещения юнита или рассчитывать расстояния; если есть время – использовать pathfinding в поведении ИИ (например, чтобы тактический ИИ мог двигаться к цели).

- Освоить использование Codex для анализа сложного алгоритма: можно просить объяснить код A*, помочь оптимизировать его или найти ошибку (например, если путь странно прокладывается).

#### Основные задачи (по возрастанию сложности)

- Представление сетки и препятствий. Подготовьте структуру данных для карты:

- Если у вас уже есть Tilemap в Unity, можно использовать координаты тайлов. Заведите, например, двумерный массив bool walkable[width,height] или подобную структуру, где true означает, что по клетке можно пройти, а false – препятствие.

- Заполните этот массив на старте: отметьте границы карты как непроходимые, клетки с зданиями (башнями, стенами) как непроходимые. Можно также решить, считать ли заражённые клетки препятствиями: реалистично юниты могут через них проходить, но с риском. Для начала пометьте инфекцию как проходимую, но можно задать ей повышенную стоимость (например, чтобы путь через заражение был менее желателен). В простейшем случае используем бинарную сетку (проходимо/нет); усложнить можно позже добавлением весов.

- Определитесь с соседством для движения: обычно 8-смежное (включая диагонали) на сетке. A* на 8-соседях должен учитывать, что движение по диагонали чуть дороже (длина √2 ≈ 1.414). Для упрощения можно разрешить только 4 направления (вверх/вниз/влево/вправо) – тогда движение по диагонали возможно лишь в два хода. Мы выберем 8-направлений, но с учётом стоимости: по горизонтали/вертикали – 1, по диагонали – √2 (можно хранить эти значения как 10 и 14, если работаем с целыми для эффективности).

- Определите функцию эвристики для A*: обычно берут манхэттеновское расстояние (|dx|+|dy|) для 4-напр. движения или диагональную эвристику (которая учитывает и диагонали) для 8-направлений. Манхэттенская часто подходит и для 8 направлений, но слегка недооценивает путь; можно использовать h = 10 * max(|dx|, |dy|) если 10 — цена шага по горизонтали, тогда учитываем диагонали.

- Реализация алгоритма A*. Напишите функцию FindPath(start, goal) возвращающую список координат от старта до цели:

- Структуры данных: создайте класс/структуру Node с полями: координаты (x,y), gCost (стоимость от старта), hCost (эвристика до цели), fCost = g+h, а также ссылку parent (для восстановления маршрута). Также понадобится коллекция open set (например, List<Node> или лучше приоритетная очередь) и closed set (список или bool-массив отмечающий закрытые клетки).

- Инициализация: поместите стартовую клетку в open set (g=0, h рассчитан).

- Цикл поиска: пока open set не пуст:

- Взять узел с наименьшим fCost (и hCost при равенстве) из open set (вручную найти или использовать приоритетную очередь).

- Если это целевая клетка, нашли путь – выход.

- Переместить этот узел в closed set.

- Рассмотреть всех его соседей (до 8). Для каждого соседа:

- Если сосед вне границ или !walkable, пропустить.

- Если сосед уже в closed set, пропустить (значит, мы его уже оптимально обработали).

- Вычислить предполагаемую новую gCost = current.gCost + стоимость шага (10 или 14).

- Если сосед не в open set, или новая gCost меньше старой (нашли более короткий путь к соседу):

- Обновить параметры соседа: gCost = новая, hCost (по эвристике), fCost и parent = current node.

- Если соседа нет в open set, добавить его.

- Продолжать цикл.

- Если open set опустел до достижения цели – пути нет (цель недосягаема).

- Восстановление пути: когда достигли цели, пройдите от целевого Node по parent-ссылкам до стартового, собирая координаты. Затем инвертируйте список или добавляйте в обратном порядке – это и будет путь от старта к цели.

- Отладка: проверьте на простых примерах. Например, старт (0,0), цель (5,0) без препятствий: путь должен быть прямая линия. Добавьте препятствие на прямой – путь должен обходить. Попробуйте цель рядом со стартом через стену – убедитесь, что алгоритм обходит стену.

- Логируйте некоторые моменты, если трудно: например, выводите координаты узла, извлекаемого из open set, его fCost, или количество узлов проверенных. Чтобы не залить консоль, можно ограничиться отдельными тестами.

- Визуализация поиска. Добавьте в режиме разработки визуальные подсказки, чтобы видеть работу A*:

- В OnDrawGizmos() (в редакторе, когда игра на паузе) можно рисовать:

- Closed set: клетки, которые алгоритм уже посетил – отмечайте их, например, красными полупрозрачными квадратами.

- Open set: текущие пограничные клетки, которые алгоритм рассматривает – отметьте синими или зелёными квадратиками.

- Старт/Финиш: можно другим цветом (например, старт – зеленый, финиш – красный).

- Финальный путь: после поиска, сохраните путь и нарисуйте его – например, используя UnityEngine.LineRenderer для линии или Gizmos.DrawLine между последовательными точками[62].

- Для реализации, вы можете вызвать свою функцию FindPath в OnDrawGizmosSelected (так, чтобы каждый раз при выделении объекта в редакторе, прокладывался путь). Однако запускать поиск в Gizmos при большой карте может быть неэффективно. Лучше: запускайте поиск по какому-то триггеру (например, при нажатии клавиши в игре), храните результат и рисуйте его Gizmos до следующего обновления.

- Визуализация путей мгновенно выявляет ошибки. Например, вы увидите, если алгоритм лезет сквозь стену (значит, где-то walkable неправильно), или если open/closed распространяются странно. Tip: хороший признак правильной работы A* – фронт волны (open set) распространяется примерно кругом от старта, а закрытые тянутся «пучком» вдоль найденного оптимального пути.

- Тестирование A*. Создайте несколько сценариев:

- Прямой путь: старт и финиш без препятствий. Проверьте, что A* возвращает прямую (диагональную или прямую) в зависимости от расположения.

- Обход препятствия: поместите большой блок-стену между стартом и целью. Убедитесь, что путь огибает стену кратчайшим путём (если симметрично, любой из равноценный).

- Тупик: если цель окружена непроходимыми клетками, алгоритм должен вернуться с пустым путём (или null). Проверьте, что не происходит бесконечного цикла, open set станет пустым и вы обработаете это (например, возвращая пустой список).

- Проходимость заражения: если вы делали заражённые клетки проходимыми, можно вручную сравнить путь, проходящий через заражённую зону vs обход. Если желаете, попробуйте задать “стоимость” заражённой клетки выше: например, добавляйте +20 к gCost при входе в инфицированную клетку. Тогда A* будет обходить заражение, если путь сильно удлиняется – полезно для AI, чтобы они обходили опасные зоны. Протестируйте: цель внутри заражённой области – алгоритм пойдёт напрямую (придётся зайти в “красную” зону, иначе не достигнуть), а если цель за заражённой зоной, может обходить вокруг.

- С помощью профайлера определите, сколько миллисекунд занимает один поиск при разных размерах карты (например, 50x50, 100x100) – на маленьких картах время незначительное, а вот на очень больших (1000x1000) поиск может быть ощутимым. Это подготовит к оптимизациям.

- Jump Point Search (оптимизация A*). Реализация JPS значительно ускоряет поиск на больших открытых пространствах, но требует тонкого понимания:

- Идея: вместо шага от клетки к соседу, JPS позволяет “прыгать” по направлению, пока не потребуется сменить направление. Например, если вы двигаетесь на восток и ничто не мешает, JPS пропустит промежуточные клетки и сразу рассмотрит дальние “принудительные” точки (где появляется препятствие, заставляющее потенциально свернуть). Это сокращает количество рассмотренных узлов.

- Подход к реализации: вместо простого цикла по всем соседям, в A* модифицированном под JPS пишут рекурсивную функцию “jump(currentNode, direction)”, которая шагает по сетке в заданном направлении до тех пор, пока:

- либо достигнет цели,

- либо найдёт “forced neighbor” (препятствие по диагонали, заставляющее включить боковой сосед),

- либо упрётся в непроходимое.

- Каждая такая “принудительная точка” становится узлом, добавляемым в open set.

- Реализация JPS довольно сложна. Для начального освоения вы можете попробовать реализовать частично:

- Например, измените обход соседей: вместо добавления всех соседей current, добавляйте только “критические” соседи. В открытом поле JPS должно генерировать гораздо меньше узлов.

- Найдите в интернете псевдокод JPS (например, на ресурсах, упоминаемых в документе) и попытайтесь встроить его в свой A*.

- Проверка JPS: убедитесь, что JPS всегда находит путь той же длины, что и обычный A*, только быстрее. Сравните длины или набор шагов на нескольких примерах – они должны совпадать[63]. Если где-то JPS даёт иной (больший) путь, значит, ошибка в логике “прыжков” или пропущена “forced neighbor”.

- Логирование JPS: Для отладки выведите, как JPS “прыгает”. Например: “Jump from (2,2) to (5,2) direction East hit obstacle at (6,2), forced neighbor at (5,3)”. Такие логи помогут отследить, правильно ли определяются контрольные точки. В идеале – минимум узлов, все ключевые повороты на препятствиях.

- На небольшой карте разница может быть едва заметна по времени, но на большой открытой – JPS должен рассматривать на порядки меньше узлов (например, вместо тысячи – десятки). В профайлере или засечкой времени (Stopwatch) сравните время выполнения A* vs JPS на большой пустой карте: JPS будет быстрее.

- JPS – необязательная задача: если чувствуете, что A уже сложен, вы можете пропустить JPS в реализации. Главное – понять идею, прочитать о ней. Для углубления*: JPS+ и другие улучшения существуют, но выходят за рамки.

- Иерархический поиск (HPA*) – концепт. На огромных картах (сотни тысяч клеток) даже A с оптимизациями может быть медленным. HPA решает это, деля карту на регионы:

- Разбейте сетку на блоки, например 10x10. В каждом блоке выберите несколько “ворот” (portal) – клетки на границах блоков, через которые можно выйти.

- Постройте граф областей: узлы графа – регионы, ребро между регионами существует, если их порталы смежны и проходимы, вес ребра – расстояние между соответствующими порталами.

- Когда нужен путь:

- Определите, в каких регионах лежат старт и цель.

- Найдите путь на графе регионов (абстрактных) – этот поиск проходит через гораздо меньше узлов (например, десятки регионов вместо тысяч клеток).

- Затем, для входа и выхода каждого региона – проложите подробный путь внутри региона (на маленькой области) – можно обычным A*.

- Составьте из этих кусков финальный маршрут.

- HPA требует приличного кодирования (генерация порталов, сохранение промежуточных путей). Полной реализации в рамках квартала, возможно, не потребуется. Но знайте: этот метод даёт резкий* прирост производительности на больших мирах, особенно если структура карт изменяется нечасто (потому что можно кешировать пути между порталами)[61].

- Обновление при изменениях: Если на карте меняются препятствия (строятся здания, вводятся карантины), в HPA не нужно пересчитывать всё с нуля – достаточно инвалидировать* (пересчитать) те кластеры, которых касается изменение (например, обновить связь порталов только в затронутом регионе)[64]. Это намного дешевле, чем пересчитывать глобально.

- Вы можете не кодировать HPA, но изложите на бумаге/в комментариях, как разбили бы карту и сколько узлов графа получили. Это поможет оценить выигрыш: например, карта 1000x1000 (1,000,000 клеток) разбита на регионы 20x20 = 2500 регионов; поиск на графе из 2500 узлов + локальные A внутри пары десятков регионов вместо поиска по миллиону узлов.

- Интеграция pathfinding в проект. Теперь, когда есть функция FindPath, воспользуйтесь ей:

- Юнит-движение: Если у вас есть хотя бы один подвижный объект (например, в Behavior Tree модуля 6 мы предусмотрели “патруль/атака”), можно улучшить его логику: вместо мгновенного “телепорта” к цели, пусть он прокладывает путь и «идёт» по нему.

- Например, в узле Behavior Tree “MoveToTarget” вызовите path = Pathfinding.FindPath(currentPos, targetPos). Получив список точек, сохраните его. Далее, каждый тик берите следующий шаг из пути и двигайте объект немного в эту сторону. Как только достиг следующей точки, переходите к следующей, и так до конца пути.

- Отмечайте, если цель или окружение изменились в процессе (например, путь стал недействительным из-за нового препятствия) – тогда проложите путь заново.

- Это сложнее, поэтому можно сначала имитировать движение: например, сделать задержку Running состояния на N тиков, по окончании считать, что “дошёл”.

- AI принятие решений: AI может использовать длину пути как фактор. Например, при оценке Utility “поддержать игрока”, можно учесть расстояние между их базами (через pathfinding) – если слишком далеко, приоритет ниже. Или при планировании GOAP: если действие “отправить отряд в точку X” – вы можете заранее оценить время по длине пути.

- Ограничение запросов: Убедитесь, что не вызываете FindPath слишком часто. Pathfinding – дорогая операция. Если вы, скажем, каждые пару тиков вызываете A для 10 юнитов, это может нагрузить CPU. Оптимизации*:

- Кешируйте результаты: например, если десять юнитов идут в одну точку, им можно проложить один путь и копировать.

- Разносите запросы по времени: 10 юнитов – по 2 юнита в тик (чуть увеличится задержка реакции, но сгладит нагрузку).

- Используйте асинхронность: Unity Jobs идеально подходят – можно вынести поиск в IJob и выполнять параллельно, если у вас много путей. В этом случае один кадр может запускать несколько pathfinding-job’ов и ждать их окончания к нужному моменту.

- Если карта статична, рассмотрите предпосчёт: например, вычислить и кешировать кратчайшие расстояния между ключевыми точками (базами, регионами) и использовать их, не гоняя A* каждый раз.

- Логирование и отладка

- Визуализация проверки: С помощью Gizmos убедитесь, что A* корректен:

- Нарисованные open/closed узлы должны логически располагаться: closed образуют область от старта до цели по оптимальному пути, open – в основном по периметру этой области (волна). Если видите closed далеко в сторону, не имея отношения к кратчайшему пути, возможно, эвристика неадекватна (не информативна) или есть ошибка, что узлы не исключаются должным образом.

- Финальный путь – отрисуйте и проверьте, что он действительно самый короткий (можно прикинуть глазом или сравнить с альтернативными маршрутами).

- Корректность стоимости: Если используете диагонали с затратой 14, проверьте, что путь предпочитает 2 прямых шага (20) над одним диагональным+1 прямым (14+10=24). Если заметите, что предпочитается диагональный путь с чуть большей реальной дистанцией – возможно, ваша эвристика (например, манхэттен) недооценивает и приводит к тому, что алгоритм думает, что диагональ выгоднее. В таком случае скорректируйте эвристику (для 8 направлений лучше h = 10*max(|dx|,|dy|)).

- JPS тесты: Обязательно сравните длины путей A и JPS на нескольких случаях[63]. Они должны совпадать до клетки. Если нет – JPS упускает какой-то узел. Логируйте «forced neighbors» и сравните с теоретическим ожиданием: JPS должен останавливать прыжок, когда появляется препятствие по стороне движения или по диагонали (которое в обычном A породило бы альтернативный обход). Отладка JPS может быть нетривиальна, тут поможет внимательное чтение статьи/псевдокода и поэтапный вывод.

- HPA* обоснование: Если не реализовали HPA, ничего страшного. Но можно провести мысленный эксперимент: возьмите большую карту и прикиньте, через какие регионы пойдёт путь. Нарисуйте схему на бумаге, выделите порталы. Если видите, что путь пересекает много однотипных открытых клеток – ясно, что A тратит время на них, а HPA перепрыгнул бы регион целиком. Само это понимание помогает проектировать уровни (например, можно заранее планировать “узкие места” – тогда и без HPA AI решения принимает быстрее, потому что вариантов меньше).

- Производительность: Pathfinding – одна из самых тяжёлых подсистем, особенно когда юнитов или запросов много. Поэтому:

- Если у вас 100 юнитов, не запускайте всем путь в один кадр – распределите или делайте более грубые цели (неперекалиброванный AI, дергающий pathfinding каждый тик, может съесть всю CPU).

- Profiler: используйте профиль Unity – запустите сценарий с множеством запросов, посмотрите время функции pathfinding. Оптимизируйте: например, убедитесь, что не создаёте лишних объектов (Node) на каждую клетку – можно переиспользовать или хранить в массиве, сбрасывая значения. Сборщик мусора (GC) не должен работать на каждое построение пути.

- Отладка эвристики: Heuristic должна не переоценивать реальный путь, иначе A* теряет оптимальность. Если вдруг вы сделали эвристику, которая иногда больше фактического расстояния – алгоритм мог пропустить оптимальный путь. Обычно манхэттен или диагональная не переоценивают, они допустимы. Если сомневаетесь, тестируйте: любой найденный путь должен иметь длина ≤ h(start); если нашли случай, где найденный путь длиннее эвристики от старта – проблема.

- Частые баги:

- Неправильное восстановление пути (например, забыли инвертировать порядок – тогда получается от цели к старту).

- Ошибки с диагоналями через углы: разрешаете ли движение по диагонали между двумя препятствиями по углам “уголком”? Классически, если оба смежных по горизонтали и вертикали клетки от текущей – непреодолимы, то диагональ тоже должна быть запрещена (чтобы не “просачиваться сквозь угол”). Добавьте эту проверку: перед добавлением диагонального соседа убедитесь, что оба соседних прямых клетки свободны.

- Границы массива: убедитесь, что не выходите за пределы при проверке соседей (условия 0 <= nx < width, аналогично по y).

- Сравнение float/интов: лучше всю стоимость в целых (например, 10 и 14), чтобы избегать ошибок накопления и удобнее сравнивать fCost.

- Не забывайте закрывать узлы: если забыть помещать обработанный узел в closed, алгоритм может зациклиться или повторно его рассматривать. В итоге или зависание, или не оптимально.

- Не проводите поиск, если старт = цель: можно сразу вернуть путь нулевой длины.

- Codex для pathfinding: Не стесняйтесь попросить AI помочь:

- «Объясни, как работает A на сетке 2D»* – для уверенности.

- «Почему алгоритм A не находит путь, хотя должен»* – предоставьте свой код, AI может найти упущенное условие или баг.

- «Как реализовать Jump Point Search» – он может дать упрощённый псевдокод, по которому скорректировать свой.

- «Как улучшить производительность поиска пути» – может напомнить об асинхронности, кешировании, что мы уже обсудили.

- Воспользуйтесь Codex, чтобы написать, например, приоритетную очередь (binary heap) для open set: запрос «Реализуй бинарную кучу на C#» – и вставьте полученное, так поиск ускорится (List.Sort каждый раз – лишние затраты).

- С помощью AI протестируйте критические функции: попросите сгенерировать юнит-тест для FindPath на известной сетке (вы можете захардкодить небольшую карту в массив и вызвать функцию, проверить ожидаемый путь). Это убедит, что функция работает правильно в автономном режиме.

### Модуль 8: Оптимизация производительности и масштабирование

#### Краткое описание модуля

К этому моменту у нас множество систем: симуляция инфекции, экономика, AI, pathfinding и т.д. В небольших масштабах (десятки агентов, карта 100x100) они могут работать на MonoBehaviour без проблем. Но если игра разрастётся (сотни агентов, карта тысячники, большой ИИ), нам нужно подготовиться к оптимизации. В этом модуле мы разберём стратегии масштабирования: - Сначала профилируем и выявляем “горячие точки”. - Затем оптимизируем самые тяжёлые циклы, перенося их на многопоточные Jobs с Burst-компиляцией (нативный код) – это даст ускорение на многоядерных CPU. - Если и этого мало, посмотрим в сторону DOTS/ECS (Entity Component System) – кардинальная переделка под дата-ориентированную архитектуру, но позволяющая симулировать тысячи объектов с фиксированным шагом крайне эффективно. - Дополнительно, улучшим производительность рендеринга и загрузки: используем пуллинг объектов для частых созданий/уничтожений, настроим Tilemap для минимизации draw calls, и внедрим Addressables для управления памятью ассетов. - Цель: Научиться пошагово усиливать производительность по мере необходимости, не делая преждевременных оптимизаций, но и зная заранее узкие места архитектуры.

#### Цели обучения

- Понять, как использовать профайлер Unity и Frame Debugger для измерения производительности CPU, сборщика мусора (GC) и рендеринга. Уметь находить функции, которые потребляют много времени, и понимать, почему (например, большой цикл, частое выделение памяти, слишком много вызовов Update).

- Научиться переписывать вычислительно тяжёлый код под Jobs System Unity: разбивать работу на небольшие параллельные задачи (job’ы), использовать NativeArray для данных, применять [BurstCompile] для максимального ускорения. Понять ограничения (нельзя обращаться к Unity Object внутри job, нельзя выделять память в job, нужны безопасные контейнеры).

- Освоить базовые приёмы отладки job’ов: запускать без Burst (тогда можно ставить брейкпоинты), использовать Burst Debug режим.

- Понять, когда стоит перейти на ECS: при очень большом количестве однотипных объектов, где ООП-подход с MonoBehaviour начинает тормозить. Получить общее представление о компонентах, системах и группах ECS, о фиксированной группе симуляции и буферах команд (EntityCommandBuffer) для изменений.

- Научиться профилировать память: отслеживать утечки (например, неосвобождённые NativeArray), контролировать использование Addressables (правильно ли выгружаются ассеты, нет ли дублирования в памяти).

- Внедрить Object Pooling для часто создаваемых объектов (например, визуальные эффекты, пули), чтобы избежать лишних затрат на Instantiate/Destroy.

- Научиться эффективно использовать Codex для оптимизационных подсказок: просить проверить, где узкое место, или переписать метод с учетом многопоточности.

#### Основные задачи (по возрастанию сложности)

- Профилирование базовой игры. Прежде чем что-либо оптимизировать, измерьте:

- Запустите игру в наиболее “нагруженном” сценарии, который у вас сейчас есть. Например: максимальная площадь заражения, много построек, AI активно строит, юнит что-то патрулирует, несколько запросов pathfinding. Откройте Profiler (Window → Analysis → Profiler) и Frame Debugger.

- В профайлере обратите внимание на:

- Вкладку CPU Usage: какие методы/frame пожирают больше всего времени. Например, может оказаться, что InfectionSystem.Tick занимает 40% кадра (потому что там двойной цикл по большой сетке), или Pathfinding.FindPath скачет при вызове и отъедает 10 мс. Выпишите топ-3 самых тяжёлых места.

- GC Alloc: посмотрите, генерируется ли сборка мусора каждый кадр (желтые всплески). Если да – выясните, что создаётся. Часто причины: создание новых объектов/коллекций каждый Update. Например, if FindPath создает много new Node, их потом собирает GC. Или EventBus генерирует что-то. Зафиксируйте объем (в байтах). Задача – минимизировать частые аллокации, чтобы GC не мешал (идеально 0B per frame в стабильном состоянии).

- Timeline: переключитесь в режим Timeline, рассмотрите кадр. Видно ли, что какие-то системы можно выполнять параллельно (например, Infection и AI могли бы идти вразнобой)? Unity по умолчанию выполняет весь ваш код в одном потоке (Main Thread). Нам нужно выявить, какие куски можно вынести в job’ы.

- В Frame Debugger посмотрите рендер: сколько Draw Calls и SetPass. Возможно, Tilemap разбивает на чанки (и хорошо), но если вы использовали Tilemap с Individual mode, draw calls могут быть сотни. Отмечайте: хотим <100 draw calls в идеале для 2D, иначе GPU перегружается.

- Результат этого шага – понимание: что тормозит прямо сейчас? Например: “Система инфекции – 5 мс, Behaviour Tree – 2 мс, Pathfinding (при запросе) – 3 мс, отрисовка – 4 мс, GCAlloc – 0.5 KB/frame”. С такими данными можно решать, что оптимизировать.

- Вынос тяжёлых циклов в Jobs + Burst. На основе профайлера выберите самую затратную функцию – скорее всего, обновление инфекции (двойной цикл по всей сетке) или массовое вычисление influence-карт, или обработка сотен агентов. Попробуем оптимизировать на примере InfectionSystem:

- Подготовка данных: переводим нужные структуры в формат, пригодный для job. Например, у нас CellInfection[,] grid. В Unity Jobs нельзя directly использовать многомерный массив или List, но можно NativeArray<CellInfection> одномерный. Представим сетку как одномерный массив длины widthheight (с индексом idx = ywidth + x). Создайте NativeArray<CellInfection> gridNative и скопируйте данные туда. Либо создайте отдельный NativeArray<float> infectionLevels и NativeArray<int> infectionStates (если struct сложен).

- Определение Job: Напишите struct InfectionJob : IJobParallelFor (если хотите параллельно по индексу) или IJob (если будете внутри делать свой параллелизм). Например:

- [BurstCompile]
struct InfectionJob : IJobParallelFor {
   public NativeArray<CellInfection> current; 
   public NativeArray<CellInfection> next;
   public int width;
   public int height;
   public void Execute(int index) {
       int x = index % width;
       int y = index / width;
       // ... вычислить новый уровень и состояние на next[index] на основе current[...] соседей
   }
}

- Используйте подход с двумя массивами (текущий/следующий) как раньше. Можно даже оптимизировать: хранить только level отдельно, а состояние S/I/R хранить как byte для компактности.

- Внутри Execute нельзя обращаться к обычным полям/свойствам Unity или к managed-объектам. Поэтому все данные надо передать как простые значения или NativeArray. Также нельзя использовать List или Dictionary. Поэтому, если вам нужны, скажем, массив соседних индексов – можете вычислять на лету или заранее передать массив смещений соседей.

- BurstCompile: Атрибут [BurstCompile] перед классом job – заставит компилировать его в высокопроизводительный код, но есть ограничения: нельзя выводить в лог внутри bursted job (Debug.Log не поддерживается), нельзя использовать managed memory.

- Запуск Job: В SimulationLoop.Update, когда приходит время обновить инфекцию:

- Перед циклом while или где удобно, можно заполнить gridNative текущими данными. (Если gridNative у вас Persistent, вы можете его обновлять в OnEnable, а потом только перезаписывать изменённые значения).

- Создайте экземпляр InfectionJob job = new InfectionJob { current = gridNative, next = gridNextNative, width = w, height = h };

- Получите JobHandle handle = job.Schedule(width*height, 64); – это запустит параллельно на нескольких потоках, разбивая на группы по 64 индекса (подбирайте batchSize, 64 – начальный выбор).

- Синхронизация: вам нужно дождаться конца работы job прежде, чем использовать результат. В простом случае делаем handle.Complete(); – это блокирует главный поток, пока job не закончит. По сути, это аналог последовательного выполнения, но job выполняется параллельно, и Complete дождётся её (к этому времени часть Main Thread могла выполнять другие вещи, но в нашем случае после запуска infectionJob нам, возможно, нечего делать – но представьте, мы могли параллельно и AI считать).

- После Complete(), данные в gridNextNative заполнены. Скопируйте их обратно в обычную структуру (или, если вы полностью переходите на NativeArray как основное хранилище, можно хранить так). Например, можно иметь float[] infectionLevel для UI или отладки, или сразу перебирать NativeArray при визуализации.

- В конце, не забудьте: если NativeArray создан с Allocator.TempJob или Allocator.Persistent, нужно его .Dispose() когда он не нужен. Хорошо, если gridNative вы сделали полем и держите постоянно (Allocator.Persistent) – тогда нет аллокации каждый кадр, и Dispose сделаете в OnDestroy.

- Проверка результата: Убедитесь, что переход на job ничего не сломал. Лучший способ – оставить старую реализацию (MonoBehaviour цикл) и новую (job) и сравнить результаты на одном кадре:

- Например, на 10-м тик делайте и старый Tick, и новый (новый – не применяя к основному состоянию), и сравните nextGridOld vs gridNextNative. Если различия – есть баг в job.

- Если все ок, вы можете удалить старый код или оставить комментированным.

- Измерение эффекта: Запустите профайлер на том же сценарии. В Timeline вы теперь увидите, что на Main Thread выполнение InfectionJob занимает почти ноль (только подготовка), а основная работа происходит в Worker Threads параллельно. В идеале, например, вместо 5 мс на главном потоке, вы получите <1 мс на главном и, скажем, 2 мс на фоновых (которое не блокирует кадр, если у вас многоядерный CPU). Это ускорение. Если у вас 4 ядра, теоретически 5 мс могут превратиться ~в 1.3 мс (5/4), плюс накладные расходы.

- Частые ошибки при Jobs:

- Забыли Complete() – тогда игра пойдёт дальше, и вы начнёте использовать gridNextNative до того, как job завершился, что плохо (может быть исключение или неправильные данные). Можно вместо ручного Complete использовать механизм JobHandle: например, цепочку job’ов илиDependency injection, но это сложно – пока просто Complete.

- Неправильный Allocator: TempJob нужно освобождать через .Dispose() вручную или он автоматически освободится через короткое время, но лучше явно.

- Race conditions: если бы у нас, например, два job – нужно учитывать, не конфликтуют ли они. В Unity Jobs, если один job пишет, а другой читает один массив – надо указывать job.WithReadOnly(array) или разделять на Write/ReadDependency, но в простейшем случае, когда job один, это не нужно.

- Обращение вне массива: в параллельном коде это особенно опасно – будет сложно отладить. Убедитесь, что индексы верны. Добавьте защиту: например, проверка if (x < width-1) вокруг доступа к правому соседу и т.п.

- Debugging: Вы не можете просто Debug.Log внутри job (под Burst он игнорируется). В Unity Burst компиляторе есть опция Native Debug Mode, её можно включить в Burst меню – тогда job выполняется без оптимизаций, и можно хотя бы try-catch. Однако, чаще проще отлаживать job, запустив его без Burst (временно убрать [BurstCompile]) – тогда можно даже Debug.Log (медленно, но для теста) или attach-дебагер. После отладки вернуть [BurstCompile].

- Расширение: По аналогии с InfectionSystem, можно вынести и другие подсистемы:

- Influence Map: если вы вычисляете поле влияния врага/обороны каждый тик полным сканированием карты, сделайте job, параллельный по частям сетки.

- Pathfinding: можно выполнение одного поиска пути сделать job’ом, но больше выигрыш, если вы запускаете сразу пачку поисков. Например, 10 запросов – можно запустить 10 job’ов параллельно (или 1 IJobParallelFor, который в Execute(index) запускает маленький поиск на подкарте – но pathfinding не тривиально параллелится на уровне одного запроса). Unity предлагает NavMesh за нас, но если пишете свой – держите в голове.

- AI Utility: если Utility AI оценивает 5 целей, а ещё на 5 регионов – 25 оценок – можно распараллелить, но это мелочь. GOAP планирование – тоже скорее sequential (не стоит параллельно).

- Массовая физика или столкновения: у нас нет явно, но если бы были сотни пуль – их обновление/проверка столкновений – кандидат для jobs.

- Введение в ECS (Entities). Перенос всего проекта на ECS – дело трудоёмкое, но можно попробовать Proof-of-Concept на одной системе, например, на той же инфекции:

- Entities Setup: Подключите пакет Entities (если ещё нет, через Package Manager). Создайте компонент:

- struct InfectionComponent : IComponentData {
    public float level;
    public byte state;
}

- Под Entities ваша сетка превратится в множество сущностей – по одной на клетку. Это не всегда оптимально (1млн сущностей – тоже нагрузка), но ради примера.

- В OnCreate какого-то системного классa (например, InfectionSystem : SystemBase) – создайте все сущности:

- Entities.ForEach(...) // либо с EntityManager вручную

- Например,

- for(int y=0; y<height; y++){
   for(int x=0; x<width; x++){
      Entity e = entityManager.CreateEntity();
      entityManager.AddComponentData(e, new InfectionComponent { level = initialLevel, state = 0 });
      // Можно добавить компонент Position (или использовать Entity's index as position mapping)
   }
}

- Это разовое создание в начале (дорого, но раз).

- Infection System (ECS): Напишите системный класс:

- [UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]
public partial class InfectionUpdateSystem : SystemBase {
   protected override void OnUpdate() {
       float dt = ...; // получить deltaTime (в ECS fixed dt можно через Time.DeltaTime, если настроено)
       // Параллельный job:
       Entities
         .WithAll<InfectionComponent>()
         .ForEach((ref InfectionComponent inf) => {
            // простейшее: если state=1 (Infected) уменьшаем level
            if(inf.state == 1) { inf.level -= 0.1f * dt; if(inf.level <= 0) inf.state = 2; }
            // заражение соседей – сложнее: ECS хорош, когда можно в один проход
            // Здесь в ECS можно использовать 8 отдельных System, или 8-соседний подход через stencils.
         }).ScheduleParallel();
   }
}

- Мы пометили [UpdateInGroup(FixedStepSimulationSystemGroup)] – значит, система будет работать с фиксированным шагом (например, 10 тиков/сек), аналогично нашему SimulationLoop[65]. Unity сама позаботится, чтобы вызывался нужный Group с заданной периодичностью (можно настроить).

- Здесь Entities.ForEach – уже распараллеливает по сущностям. С Burst по умолчанию. Очень удобно, если работа локальная, но у нас проблема – нужно учитывать соседей. Как в ECS узнать соседние клетки?

- Либо через доп. компонент Position (тогда можно в ForEach внутри делать look-up соседей через ComponentDataFromEntity – но это плохо, random access, медленно).

- Либо, более ECS-way: сделать отдельную систему, которая, например, проходится по всем сущностям и если у сущности state=1, повышает уровень у соседей (в ECS можно хранить сетку как NativeArray и передавать в job).

- ECS не панацея для клеточных автоматов, unless вы пользуетесь их Grid/Physics/GridQuery API.

- Выигрыш ECS: В чём же профит? ECS + Jobs + Burst дает то же, что мы сделали вручную: параллельный код на C, но упакованный удобно. Преимущество в том, что Entities могут динамически создаваться, и ECS позаботится, чтобы это происходило безопасно – через EntityCommandBuffer (ECB).

- Например, если при достижении какого-то условия мы хотим создать новую сущность/объект, мы не можем прямо внутри job вызвать CreateEntity (это structural change). Нужно записать команду ecb.CreateEntity() и система исполняет её после завершения всех job данного этапа (тем самым избегая конфликтов)[65].

- Для нас, в инфекции, не особо нужно создавать/удалять сущности, только изменять данные (это разрешено напрямую).

- Когда переходить на ECS: Если ваш проект действительно требует симуляции тысяч агентов с физикой, рендерингом – ECS даст выигрыш. Но он потребует многому научиться (Data-Oriented Design, писать систему вместо методов). В рамках квартала вы, возможно, только чуть-чуть коснётесь ECS. Поэтому:

- POC: Реализуйте маленький кусочек (например, диффузию инфекции) и убедитесь, что оно работает, сравнив с основной системой. Запустите профайлер: ECS-система будет видна на вкладке Entities и будет тоже раскидываться на воркеры.

- Правила ECS: Помните – все структурные изменения через ECB (иначе sync point и потеря преимуществ)[65], фиксированный шаг через группу (как сделали), и не смешивайте MonoBehaviour логику с ECS на те же данные одновременно (можно, но аккуратно).

- Отладка ECS: Отслеживайте в Entities debugger (Window → Entities). Убедитесь, что ваша система в правильной группе (FixedStepSimulationSystemGroup) и что fixedDeltaTime соответствует SimulationLoop tick (можно настроить в World Time).

- Вывод: Попробовав ECS, решите, нужно ли внедрять его во всё. Возможно, вы ограничитесь job-ами на критичных местах, не переписывая всё на ECS – это нормально для малого проекта. Помните: “сначала сделать, чтобы работало; потом – оптимизировать”. У вас уже есть рабочие MonoBehaviour-системы, и вы точечно их ускоряете job’ами. Переписывать всё на ECS имеет смысл, если планируется действительно массовая масштабируемость (например, тысячи юнитов) или если вы изначально хотели освоить DOTS как цель.

- Другие оптимизации. Помимо CPU-вычислений, есть аспекты GPU и памяти:

- Объединение отрисовки: Проверьте настройки Tilemap. Если у вас несколько Tilemap-слоёв, старайтесь, чтобы большинство были в режиме Chunk – тогда Unity рисует их по блокам и меньше вызовов. Если есть особые слои (где нужны индивидуальные спрайты между, как указано в документе), используйте Sprite Atlas для них, чтобы Unity мог батчить и их[66]. Откройте Frame Debugger: он покажет, где батчинг прерывается (например, разные материалы – значит, атлас не используется, или разные слои – не избежать).

- Object Pooling: Если у вас появляются объекты во время игры (например, вы планировали снаряды, визуальные эффекты или даже те же башни строятся и уничтожаются часто), вместо Instantiate/Destroy каждый раз – сделайте пул:

- Например, пул List<GameObject> предварительно созданных снарядов (неактивных). При выстреле – берёте из пула (SetActive true, перемещаете), при попадании – отключаете и возвращаете в пул. Unity даже имеет ObjectPool<T> класс под эту задачу[67]. Это резко снижает нагрузку на GC и CPU при массовом появлении/удалении объектов.

- В вашем проекте, пул могли бы требовать разве что визуальные части (например, мигающие индикаторы, если бы вы ими спамили). Но знать стоит, т.к. RTS могут иметь эффекты (взрывы, пули).

- Addressables и память: Если вы загружаете ресурсы (например, решите подгружать спрайты, аудио) – используйте Addressables. Главное – соблюдайте пару правил:

- Загруженное -> освобожденное: каждая пара Addressables.LoadAsync -> Addressables.Release, чтобы не копились невидимые объекты в памяти[27].

- Группируйте адресуемые ассеты по тому, как будут использоваться (например, весь UI в одном груп, все большие спрайты в другом), так вы сможете подгружать/выгружать целыми группами.

- Проверьте Memory Profiler (есть отдельный пакет) или хотя бы профайлер вкладку Memory: посмотрите, нет ли всплеска памяти после, например, сцены загрузки/выгрузки. Addressables часто ловят на том, что загрузили, а Release забыли – тогда на каждый повтор загрузка дублируется в памяти.

- Расчёты AI: Если у вас сложный Utility или планер, убедитесь, что он не срабатывает слишком часто:

- Стратегический AI мы и так сделали раз в N тиков. Можно даже реже: например, цели пересматриваются раз в секунду, этого хватит.

- Tactical AI/Behavior Tree – работает каждый тик, но там дешёвые операции. Однако, если бы BT стал сложнее, тоже не стесняйтесь пореже делать тяжелые проверки.

- Разделение вычислений: когда невозможно распараллелить, попробуйте разнести по кадрам. Например, у вас 50 юнитов и сложный расчет для каждого – не делайте всех в один кадр. Делайте 10 юнитов в кадр (каждому обновление раз в 5 кадров). Для стратегических решений это вообще нормально.

- Планировщик задач: Можно внедрить простой менеджер, который будет распределять задачи по кадрам (например, у вас очередь pathfinding запросов, он берет по одному-два на кадр). Это несложно – написать обёртку над FindPath, которая либо сразу выполняет (если мало запросов), либо ставит их в очередь, а Update будет поштучно вызывать. Так вы избежите спайков.

- Кэширование результатов: Если один и тот же расчет повторяется с теми же входными данными – закэшируйте. Например, AI каждый тик запрашивает “сколько заражено клеток?” – посчитайте это в InfectionSystem один раз за тик и сохраните, а AI пусть берет готовое значение. Такие мелочи устраняют дублирование труда.

- Особенно актуально для GOAP: если несколько действий используют одно условие, лучше подсчитать его один раз и хранить.

- Выключение неиспользуемого: Unity тратит время на каждый активный Update(). Если у вас есть объекты/скрипты, которые сейчас ничего не делают – выключайте их (enabled=false) или уничтожайте, чтобы не занимали цикл.

- Пример: если у вас будет много снарядов, не делайте для каждого Update – лучше пусть PoolManager дергает их движение.

- Сейчас, в нашем проекте, вероятно, каждый скрипт выполняется, но их не так много – это не узкое место. Но на будущее: ограничить количество пустых Update.

- Логирование и отладка

- Profiler Iteration: Повторяйте процесс профилирования на каждом шаге оптимизации:

- Сохраняйте снимки профайлера (есть функция Save Profiler Data). Например, baseline и после внедрения job’ов.

- Сравнивайте: снизилось ли время на функцию X? Переместилась ли нагрузка на Worker Threads? Нет ли новых подозрительных всплесков (например, After job – GCAlloc уменьшился, но вдруг где-то стало больше, значит, возможно, мы создаём NativeArray каждый кадр и не освобождаем).

- GPU: Если были проблемы с количеством draw calls, после оптимизации Tilemap/атласа – стало ли меньше SetPass? Если да, FPS вырастет, если GPU была узким местом.

- Следите за Main Thread frame time – для 60 FPS он должен быть ~16 ms или ниже. Если у вас ранее было 30 ms, а после оптимизации стало 12 ms – цель достигнута.

- Ошибки Race Condition: При параллелизме легко не заметить ошибку, которая проявляется редко (например, два job записывают в одну переменную одновременно). Если сталкиваетесь со странными багами (нестабильные результаты) – возможно, гонка данных.

- Для отладки таких: временно отключите Burst и выполните job в однопоточном режиме, сравните результаты. Используйте Conditionals/Asserts: например, если два job считают сумму, можно после всех job сверить с однопоточным вычислением.

- Unity’s NativeArray имеют функцию .IsCreated – проверяйте и выбрасывайте предупреждение, если вдруг массив уже Disposed (значит, где-то двойное освобождение).

- Если работа с EntityCommandBuffer – убедитесь, что все создания/удаления сущностей делаются через него, а не напрямую EntityManager внутри job – иначе Unity выдаст исключение (ECS не позволит, кстати).

- Частые подводные камни:

- Неосвобождённые NativeArray – утечка памяти. Unity Editor предупредит в консоли (кажется, о TempJob утечках), но не всегда. Следите вручную. Если массив нужен постоянно, делайте Persistent и храните, переиспользуя.

- Burst не поддерживает обращение к классам/ссылкам – если очень надо, пометьте поле [NativeDisableParallelForRestriction] или [NativeDisableUnsafePtrRestriction] – но лучше перепроектировать. Обычно, если нужно что-то сложное (например, поиск пути) – оставьте на Main Thread или делайте отдельной одиночной job, а не параллельно клеткам.

- Попытка “параллелить то, что не параллелится” – иногда overhead job’ов перевесит выгоду. Например, если у вас всего 10 объектов и простой код – job может только усложнить. Всегда сопоставляйте цену разбивки: job-менеджер тоже тратит время на запуск. Поэтому оптимизируйте действительно большие задачи, а не всё подряд.

- Валидация: после оптимизации обязательно прогоните все игровые тесты, которые у вас были. Производительность – хорошо, но не ценой сломанной логики.

- Преждевременная оптимизация – зло: мы оптимизируем то, что профайлер показал существенным. Не тратьте время на job там, где и так <1% кадра. Лучше сосредоточиться на том, что было узким местом.

- Применение Codex:

- «Как преобразовать этот метод в Job?» – можете показать Codex кусок кода, он подскажет, как вынести.

- «Пример использования IJobParallelFor в Unity» – получив пример, сопоставьте со своей задачей.

- «Почему Burst не работает с моим кодом?» – если получили ошибку компиляции, AI может подсказать, что не так (например, использован недопустимый тип).

- «Как работает EntityCommandBuffer в Unity ECS?» – Codex может объяснить или дать шаблон, как правильно создавать сущности внутри системы.

- «Как правильно профилировать Unity игру» – AI может перечислить шаги, вдруг вы что-то забыли (например, отключить Deep Profile, если он не нужен, или включить Profile Editor).

- «Какие ещё способы оптимизации RTS?» – AI может упомянуть, например, fixed-point math вместо float (редко нужно), или специализированные структуры. Это даст идеи на будущее.

- Используйте AI для ревью: пусть посмотрит ваш оптимизированный код – «Не пропустил ли я Dispose где-нибудь?» – он часто может заметить, например, отсутствие Dispose.

- AI-друг поможет и с Addressables: «Как выгрузить Addressable после использования?» – подскажет про Addressables.Release и тонкости.

- Помните, что Codex – не панацея: оптимизация требует измерения, он может только общие вещи сказать. Но свериться с советами – полезно.

#### Перед переходом к итогам:

После проведённых оптимизаций, у вас игра должна: - Работать плавно в ожидаемых масштабах (проверено, например, 200 тиков на средней карте в 60 FPS держится). - Не быть замеченных утечек памяти (профайлер память стабилен, утечки NativeArray отсутствуют). - Критичные подсистемы (инфекция, массовые вычисления) – вынесены на job’ы, их вклад в загрузку кадра снизился. - Вы понимать, как дальше масштабировать: например, если завтра нужно добавить 1000 агентов, вы знаете, что их логику тоже можно распараллелить или перевести в ECS. - В процессе вы сохранили корректность (юнит-тесты и игровые тесты проходят). - Итог: Вы увидели, что архитектура, заложенная ранее (фиксированный тик, разделённые системы) очень способствует оптимизации: мы могли независимо ускорять InfectionSystem, AI и т.д., не переписывая всё. Это и есть преимущество грамотной архитектуры.

### Общие советы: эффективная работа с Codex и Visual Studio Code

Чтобы максимально использовать возможности AI-помощника (Codex GPT) и среды VS Code, вот несколько рекомендаций и приёмов:

- Установка и настройка: Убедитесь, что расширение Codex (например, CodeGPT) установленно и авторизовано. Часто требуется ввести API-ключ OpenAI или залогиниться. В VS Code обычно появляется боковая панель чата или команды в Command Palette.

- Обращение к Codex через чат: В VS Code, скорее всего, есть команда открыть чат CodeGPT. Вы можете задавать вопросы на любом языке (AI понимает и русский, и английский; технические термины лучше оставлять по-английски, чтобы избежать недопонимания).

- Контекст и файлы: Используйте возможность давать контекст. Например, расширение CodeGPT поддерживает упоминание файла или выделенного кода. Вы можете выделить фрагмент кода и вызвать команду Ask CodeGPT – AI увидит только этот фрагмент. Или в чате написать @MyClass.cs – тогда ассистент учтёт содержимое файла MyClass.cs[68]. Это очень полезно, когда вопрос касается конкретного кода – не нужно копировать вручную.

- Команды помощника: Многие расширения предлагают готовые команды (в CodeGPT чат-агенте используются префиксы):

- /Fix – автоматически найти и предложить исправление ошибок в выделенном коде[68]. Если у вас ошибка компиляции или логическая, можно выделить проблемный метод и набрать /Fix: AI попытается переписать код правильно. Пример: вылетает NullReferenceException – AI может заметить, что забыли проверку на null или перепутали порядок инициализации.

- /Refactor – улучшить код: привести к лучшему стилю, разбить на функции, убрать дублирование[69]. Полезно, если код работает, но выглядит громоздко – AI предложит более чистую версию. Всегда проверяйте результат, но зачастую он дельный.

- /Document – сгенерировать комментарии или описание для выделенного кода[68]. Можно использовать, чтобы получить понятное объяснение функции. Это и для себя полезно (лучше поймёте, что написали), и для практики написания doc-комментариев.

- /Unit Testing – сгенерировать шаблон юнит-тестов для выделенного кода[69]. Помощник может сразу придумать 2-3 тест-кейса. Вы можете их взять и доработать под свои нужды. Это ускоряет создание тестов.

- Команды могут отличаться в других расширениях, но идея одна: они экономят время на рутинных действиях.

- Примеры эффективных запросов:

- «Как мне оптимизировать обновление 1000 объектов в Unity?» – AI может предложить использовать Jobs или ECS, как мы обсуждали.

- «Почему метод X выдаёт ошибку Y?» – укажите конкретную ошибку/стек-трейс. Часто Codex сможет объяснить: например, NullReferenceException – подскажет, что возможно объект не присвоен в инспекторе или не инициализирован.

- «Не понимаю, как работает этот код» – выделите кусок кода, используйте /Document или спросите: «Расскажи пошагово, что делает этот метод». AI опишет своими словами. Это очень помогает, когда разбираетесь с чужим или старым кодом.

- «Приведи пример использования класса X из Unity API» – Codex может сгенерировать небольшой пример. Например: «Как использовать NavMeshAgent для перемещения?» – выдаст код с agent.SetDestination(). Проверяйте с документацией, но часто примеры корректны.

- «Составь запрос LINQ для фильтрации списка объектов по полю» – AI справляется с такими задачами, сэкономив вам время вспоминания синтаксиса.

- «Создай псевдокод для функции, выполняющей ...» – иногда полезно, прежде чем писать код, попросить AI набросать структуру. Вы получите план прямо в коде.

- Интеграция с VS Code при написании кода:

- Если у вас подключен GitHub Copilot или аналог авто-дополнения, он может дописывать строки, когда вы пишете комментарий или начало функции. Попробуйте: введите // функция, которая вычисляет фиксированный тик... (на русском Copilot тоже иногда реагирует) и несколько пустых строк – возможно, авто-дополнение предложит реализацию SimulationLoop. Такие инструменты работают на основе AI (Codex), только в инлайн-режиме.

- CodeGPT тоже может подсказывать, но чаще через чат. Вы можете сочетать: Copilot для автодополнения, CodeGPT для вопросов/отладки. Многие разработчики так и делают.

- VS Code полезные фишки:

- Автопереформатирование: нажмите Shift+Alt+F (или Configure Format Document) – код выровняется по стилю. Если подключен .editorconfig или Unity C# Extension, будет по стандарту Unity. Красивый код легче читать (и AI тоже).

- Мульти-курсор: Alt+клик в нескольких местах – можно писать одно и то же сразу в нескольких строках. Удобно, если нужно проставить что-то однотипное в ряде полей.

- Поиск по проекту: Ctrl+Shift+F – найти все упоминания, например, "TODO". Вы так не забудете части кода, которые помечали для доработки.

- Интеграция Unity: Установите расширение Unity Debugger для VS Code, если еще нет. Оно позволит ставить breakpoints и запускать игру из VS Code с остановкой в них. Запустите Unity в режиме debug (Assets → Open C# Project, затем в VS Code выберите attach to Unity Editor). Теперь, если, скажем, InfectionSystem работает не так – поставьте точку останова внутри Tick и запустите сцену. Игра приостановится на этой строке, а вы можете исследовать значения переменных в VS Code. Это незаменимо для сложной отладки.

- Unity-specific Snippets: Есть расширения, добавляющие сниппеты. Например, набираете for и два раза Tab – появляется шаблон цикла. Или prop – шаблон свойства. Используйте их, чтобы не писать шаблонный код вручную. AI тоже умеет делать сниппеты, но встроенные быстрее.

- Лучшие практики использования AI:

- Конкретизируйте запрос. Вместо: “помоги, не работает” – укажите, что ожидалось и что получилось. Например: “В функции InfectionSystem.Tick ожидал, что все Susceptible с уровнем >0.5 перейдут в Infected, но этого не происходит. Вот код... Что не так?” – такой подробный вопрос заставит AI анализировать именно вашу проблему.

- Проверьте несколько источников. Codex – не единственный ресурс. Изучайте официальную документацию Unity, блоги, форумы. AI иногда может ошибаться или устаревшую информацию дать (например, про старый API). Всегда сверяйте ответы с актуальной документацией.

- Не доверяйте слепо. Используйте AI как помощника, но ответственность на вас. Обязательно тестируйте код, сгенерированный AI, на простых примерах. Он ускоряет рутину, но может не знать всех нюансов вашего проекта.

- Учитесь у AI. Если Codex предложил оптимизированное решение, постарайтесь понять, почему оно лучше. Так вы растёте как разработчик. Например, AI показал LINQ-запрос вместо громоздкого цикла – разберите его, это обогатит ваш арсенал.

- Комбинируйте подходы. Иногда лучше спросить AI, иногда – просто подумать самому. Баланс приходит с опытом. Помните, что вы – разработчик, AI – инструмент. В итоге, важны ваши приобретённые знания.

- Пример рабочего процесса с Codex:

- Вы пишете код SimulationLoop. Не уверены, правильно ли сделали паузу. Вы спрашиваете: “Как правильно реализовать паузу в Unity с фиксированным шагом симуляции?”. AI отвечает, упоминая Time.timeScale и свой loop[6]. Вы сравниваете с вашим методом. Решаете, что ваш метод ок, но добавляете совет AI про Animator.updateMode = UnscaledTime для UI анимаций.

- Вы запускаете, но видите: при паузе один тик всё же проскакивает. Путём логов не можете найти причину. Вы копируете код Update и спрашиваете AI: “Почему при таком коде SimulationLoop может выполнить лишний тик при установке паузы?”. AI анализирует и подсказывает, что, возможно, acc не обнуляется правильно или pausing не мгновенно. Вы находите баг – например, нужно сбросить acc при паузе. Исправляете.

- Позже, вам нужно быстро добавить юнит-тесты для Economy. Вы пишете вручную пару, затем думаете – а все ли случаи покрыли? Пишете Codex: “Сгенерируй дополнительные unit-тесты на класс Economy (TryReserve/Commit)”. Он предлагает тест на отрицательные суммы, на последовательные транзакции. Вы некоторые берёте, некоторые адаптируете.

- Вы чувствовали, что не до конца понимаете GOAP. В свободное время спрашиваете: “Объясни принцип GOAP на простом примере”. AI рассказывает (или даже на C# пример). Вы лучше разбираетесь в теме, углубляете свой проект.

- В конце проекта вы хотите навести порядок. Выделяете код монолитного метода AI, применяете /Refactor. AI разбивает на несколько функций – вы проверяете, все ли работает. Стало чище, поддерживаемее.

- Заключение: VS Code + Codex GPT – мощная связка. VS Code предоставляет лёгкую и гибкую IDE с отличными средствам навигации и отладки, а Codex – ускоряет получение информации и написание кода. Вместе они позволяют решать проблемы быстрее и учиться эффективнее. Но всегда держите под контролем процесс: проверяйте выводы AI, экспериментируйте самостоятельно. Со временем вы привыкнете формулировать запросы так, что AI будет давать именно то, что нужно.

Следуя этим рекомендациям и плану модулей, через квартал у вас будет прочная база знаний и навыков. Вы последовательно, шаг за шагом, прошли от основ к сложным системам, научились отлаживать и оптимизировать. Не бойтесь продолжать экспериментировать, задавать вопросы (и AI, и сообществу разработчиков) и совершенствовать проект. Успехов в разработке вашего RTS-проекта!


[1] [2] [3] [4] [5] [6] [7] [8] [9] [18] [19] [20] [21] [29] [30] [31] [34] [35] [40] [41] [42] [43] [44] [46] [47] [49] [50] [51] [52] [53] [59] document.txt

file://file_000000003db061f4ab0ba4400c468bb3

[10] [17] [22] [27] [45] [48] [57] [58] [60] [61] [64] [66] [67] document-2.txt

file://file_00000000e2c461f4bb2cbf5057f4f2ac

[11] [12] [13] [14] [15] [16] [23] [24] [25] [26] [28] [32] [33] [36] [37] [38] [39] [54] [55] [56] [62] [63] [65] document-3.txt

file://file_0000000069fc624685d94f067e42a757

[68] [69]  CodeGPT: Chat & AI Agents - Visual Studio Marketplace

https://marketplace.visualstudio.com/items?itemName=DanielSanMedium.dscodegpt




## План разработки RTS-проекта (Unity 2D) – Полный Production Pipeline
Источник: План разработки RTS-проекта (Unity 2D) – Полный Production Pipeline.md

## План разработки RTS-проекта (Unity 2D) – Полный Production Pipeline

Цель: В течение квартала пошагово создать и отладить полный сквозной production-пайплайн для RTS-игры (Unity 2D) с упором на архитектуру и оптимизации. План предназначен для джуниор-разработчика и охватывает все ключевые подсистемы – от архитектурного каркаса проекта до геймплейных механик, AI, UI, производительности и CI/CD. Документ структурирован по подсистемам и этапам разработки, служит внутренней документацией и трекером прогресса.

### Модульная структура и архитектура проекта

Проект следует модульной архитектуре с четким разделением на слои (Domain, Data, Application, AI, Presentation, Infrastructure). Ниже приведена структура solution с пространствами имен:

/Game
  /Domain              // Чистые модели (POCO) и интерфейсы
    Economy/           // Экономика: бюджеты, производство, издержки
    Infection/         // Состояния клеток, параметры заражения
    Tech/              // Дерево технологий и эффекты
    Map/               // Координаты, графы смежности, зоны
    AI/                // Контракты AI (IStrategicPlanner, IUtilityScorer и др.)
    Common/            // Общие компоненты: EventBus, команды, результаты, время
  /Data                // ScriptableObject-конфиги (статические данные)
    Units/, Buildings/, Techs/, Factions/, InfectionParams/
  /Application         // Сервисы приложения: симуляция, тик, сохранения
    Simulation/, Saving/, Pathfinding/, Services/
  /AI                  // Реализация AI: Utility AI, GOAP, Behavior Trees
    Strategic/, Tactical/, Perception/
  /Presentation        // Презентация: MonoBehaviour для сцен, UI, визуальных эффектов
    UI/, VFX/, Audio/, Tilemaps/
  /Infrastructure      // Инфраструктура: доступ к данным, JSON, DI/Service Locator

Расширения модулей: По мере разработки добавляются детали в каждую подсистему. Например, в Domain/Economy следует разделить две ветви экономики – государственный бюджет и бюджет игрока – со своими подсистемами (налоги, приоритеты госзаказа, субсидии, займы, лимиты капитальных/операционных затрат)[1]. Вводятся сущности контрактов (строительство, исследование, карантин) с жизненным циклом и штрафами за невыполнение[1]. В Domain/Infection закладываются несколько слоев данных: уровень заражения, плотность населения, мобильность, санитарные кордоны, транспортные коридоры[2]. В Application/Pathfinding выносится система навигации (графы на сетке, регионы, узкие места) для тактического и стратегического ИИ[3]. В AI/Perception – кэши влияния (influence maps) и «карты давления» по фронту, чтобы AI читал готовые поля при вычислении приоритетов[3]. В Infrastructure – абстракция для сохранений (JSON или бинарные) с версионированием состояния[4].

Важно: В рантайме используются иммутабельные объекты C# (“тёплые” модели) на основе данных из ScriptableObject-конфигов. Сами ScriptableObject служат только статическими каталогами (юнитов, зданий, технологий и т.д.), не модифицируются на лету; при запуске они копируются в обычные объекты-модели[5][6]. Это предотвращает непредсказуемые изменения ассетов в Editor и обеспечивает сериализуемость моделей для сохранений.

### Цикл симуляции, пауза и фиксированный тик

Задача: сделать игровой цикл детерминированным и фиксированным по времени, независимым от FPS, с поддержкой паузы. Симуляция должна обновляться фиксированными шагами (например, 5–10 тиков в секунду), вне зависимости от просадок/скачков кадровой частоты[7]. При паузе останавливается только симуляция, тогда как UI и анимации интерфейса продолжают обновляться.

Реализация: создается собственный компонент SimulationLoop (MonoBehaviour) с интерфейсом времени IClock (например, содержит Delta и IsPaused). В Update() этот компонент накапливает время с помощью Time.unscaledDeltaTime и вызывает тик системы каждый раз, когда накоплен фиксированный интервал tick[8][9]. Например, при tick = 0.1 сек (10 тиков/сек) цикл выглядит так:

- Каждый кадр: если игра не на паузе, увеличить аккумулятор acc на unscaledDeltaTime[8].

- Пока acc >= tick: вычитать из него tick и последовательно вызывать методы Tick() у всех подсистем: InfectionSystem, EconomySystem, StrategicAI, TacticalAI и т.д., затем в самом конце тик-цикла вызывать EventBus.Flush() для обработки накопленных событий[10]. Таким образом соблюдается строгий порядок обновления и декомпозиция по подсистемам.

- Реализовать паузу: флаг IsPaused блокирует накопление времени – при паузе Delta = 0 и цикл тиков пропускается[8]. Метод SimulationLoop.SetPaused(bool) управляет этим флагом внешне (через UI или горячую клавишу)[11][12].

- Добавить поддержку изменения скорости: 0.5× / 1× / 2× / 4×. Проще всего вводить множитель времени, влияющий на длительность tick или на скорость накопления. Например, для ускорения 2× можно временно уменьшить tick вдвое, чтобы цикл шел чаще (UI останется на unscaled-времени и продолжит работать нормально)[13]. Альтернативно – увеличивать acc быстрее.

- Добавить режим «шаг за шагом»: отдельная кнопка или клавиша, которая при паузе выполняет ровно один тик симуляции. Это можно сделать либо вызвав цикл while(acc>=tick) один раз принудительно, либо напрямую вызвав Tick() всех систем по очереди и сразу остановившись. Желательно защититься через Assert, чтобы за один шаг действительно произошел только один тик[14].

Варианты паузы: Рекомендуется контролировать паузу явным кодом (как описано выше). Использование Time.timeScale = 0 также возможно для глобальной паузы, но тогда необходимо убедиться, что все, что должно продолжать работать (UI, меню, анимации интерфейса), переведено на работу с реальным временем. Например, компонент Animator в UI следует переключить в режим Unscaled Time, а таймеры – использовать Time.unscaledDeltaTime или WaitForSecondsRealtime[15]. Такой подход (UI на unscaled-времени при timeScale=0) считается каноническим паттерном в Unity[16].

💡 Совет по DOTS: Если проект перейдет на ECS, можно использовать встроенную группу FixedStepSimulationSystemGroup для фиксированного тика – она обеспечивает фиксированный шаг «из коробки» в ECS[17].

Отладка цикла: Добавьте в UI простой оверлей с отображением текущего номера тика и коэффициента скорости. Это поможет проверить, что тики идут стабильно и не пропускаются (например, индикатор «Tick: X» обновляется каждую итерацию)[18]. Логируйте начало и конец каждого тика в консоль (порядок вызова систем), чтобы убедиться, что последовательность всегда одна и та же[19]. При резком изменении FPS (включить/выключить VSync) тиковая частота должна оставаться постоянной – это ключевой тест корректности фиксированного цикла[20]. В профайлере (Window → Analysis → Profiler) следите за ровным временем на тик в разделе Scripts, отсутствие всплесков Garbage Collection[20].

### Данные, конфигурации и система сохранений

ScriptableObject → Runtime: Все игровые параметры и каталоги (юниты, здания, технологии, параметры инфекции и т.д.) хранятся в ScriptableObject-ассетах в папке Data. При старте игры они преобразуются в чистые C#-объекты (POCO-модели) внутри слоя Domain[5]. Это означает, что во время игры ассеты не мутируют вообще. Любые изменения состояния происходят только в runtime-объектах, что обеспечивает безопасность и легкую сериализацию состояния игры. Например, описание технологии TechDef (SO) при запуске конвертируется в иммутабельный объект Tech с теми же параметрами[21][22]. Такой подход сочетает удобство настройки баланса через инспектор Unity и надежность чистых моделей (отсутствие side-эффектов).

JSON-сохранения: Для сохранения состояния используется сериализация в JSON. На начальном этапе достаточно встроенного JsonUtility, однако важно учитывать его ограничения: он не поддерживает типы вроде Dictionary и полиморфные поля (наследники) без дополнительных атрибутов[23]. Поэтому схемы данных для сохранения планируются с учетом этих ограничений – например, вместо словарей применять списки пар ключ-значение или использовать простой собственный формат. Если проект потребует более гибкую сериализацию, можно перейти на System.Text.Json или сторонние библиотеки, но это увеличит сложность. Ранний этап включает простую реализацию сохранения/загрузки всего GameState в JSON и тест этого функционала (см. этапы разработки)[24].

Версионирование сейвов: В вводится система версий сохранений – например, поле SaveVersion в корне JSON-файла[25]. При загрузке игра читает версию и выполняет миграцию данных, если файл был сохранен на старой версии. Это важно для поддержки обратной совместимости по ходу развития проекта. Рекомендуется реализовать простую структуру: переключатель (switch) по версии, и в случае устаревшего формата – преобразовать данные (или сообщить об ошибке, если downgrade невозможен).

Addressables для ресурсов: Для управления игровыми ассетами (спрайты, звуки и прочее) планируется использовать Addressables. Это позволит подгружать ресурсы по запросу и выгружать их, уменьшая потребление памяти. Ключевой момент – дисциплина: на каждый Addressables.LoadAssetAsync должен приходиться соответствующий Addressables.Release, иначе будут утечки памяти[26]. В профилировщике памяти нужно отслеживать количество загруженных адресуемых объектов до и после сцен, а также вести логирование загрузок/выгрузок (например, через счетчик или debug-лог)[27].

Система сохранений и команда на уровне инфраструктуры: Подсистема Saving (в Application/Saving) предоставляет сервис сохранения игры. Сохранение выполняется только в безопасных точках – например, сразу после завершения тик-цикла, когда все события обработаны. Это предотвращает ситуацию, когда часть изменений применена, а часть – нет. Планируется внедрить буфер команд и событий: игра может логировать команды (например, строительство здания) и выполнять сохранение после полного применения команд в тик (барьер тика)[28][29].

Unit-тесты данных: Рекомендуется написать тесты, проверяющие модели данных и сериализацию. Например,Assert-тесты, что при сериализации/десериализации модели через JsonUtility все поля восстанавливаются правильно, включая подтипы (если используются SerializeReference)[30]. Отдельно проверить, что ни один ScriptableObject не поменялся во время игры: например, в Editor-режиме можно Assert-ить, что AssetDatabase.Contains(obj) возвращает false для любого runtime-объекта (то есть объект не является ассетом)[30].

### Экономика: двойная модель бюджета и ресурсы

Экономическая система включает две параллельных экономики – государственную (ИИ) и личную (игрока). Это реализовано двумя объектами, реализующими интерфейс IEconomy (например, StateEconomy и PlayerEconomy), каждый со своим балансом, доходами и расходами[31].

- Госбюджет (StateEconomy): формируется из налогов и базовых ресурсов. Тратится автоматически ИИ-государством по стратегическим приоритетам – оборона, карантинные мероприятия, базовые исследования и логистика[31][32]. ИИ перераспределяет бюджет между этими направлениями на основе Utility AI (см. раздел AI) – то есть автоматически оценивает, куда вложения сейчас важнее всего[33]. Например, при вспышке инфекции приоритет сместится на оборону и карантин. Гос-ИИ может также субсидировать игрока (например, в виде “контрактов” или целевых грантов).

- Бюджет игрока (PlayerEconomy): это своего рода личный ВВП игрока[31]. Игрок напрямую инвестирует эти средства в особые проекты – прорывные исследования, постройку фортификаций, поддержку операций ИИ. Игрок может брать краткосрочные займы под проценты, если не хватает средств[33]. В геймдизайне это отражает волевые усилия игрока, которые выходят за рамки бюрократической машины государства.

Обе экономики взаимодействуют. В проект вводится механика контрактов с KPI: например, если гос-ИИ берет на себя защиту определенной линии фронта, но терпит неудачу (прорыв инфекции), то часть госбюджета выплачивается как компенсация (штраф) – фактически переходит в распоряжение игрока или теряется[34]. Это стимулирует ИИ выполнять обязательства. Контракты (BuildOrder, ResearchOrder и т.д.) могут оформляться как отдельные объекты в системе, публикуемые через EventBus (пример команды строительства ниже) и отслеживающие свой статус.

Множественные ресурсы: Экономика усложняется введением четырех базовых ресурсов вместо абстрактных денег[35]. Предусмотрены: трудовые часы населения (LaborHours) – универсальный производственный ресурс, энергия (Power) – генерация/потребление электричества в день, материалы (Materials) – стройматериалы, детали, боекомплект (совмещенный ресурс), еда (Food) – снабжение населения и войск[35]. Бюджет игрока и государства оперируют этими ресурсами (в различных пропорциях).

Экономический цикл работает с суточным тиком – раз в игровой день происходит расчет экономики по фиксированным этапам[36]. Порядок суточного тика: 1. Рост населения: рассчитывается прирост мирного населения за день (CivGrowth) на основе базового процента и текущих условий[36]. Часть этого прироста может быть автоматически передана под управление ИИ (см. ниже). 2. Передача процентов ИИ: от общего суточного прироста и добытых ресурсов вычисляется доля, которая сразу уходит ИИ. Для каждого ресурса (включая прирост населения) на UI предусмотрен слайдер 0–100% – сколько % игрок автоматически отдаёт гос-ИИ[37][36]. Например, если игрок считает, что ИИ лучше управится с энергией, он может перенаправить 50% произведенной энергии в госбюджет каждый день. Передача вычисляется до поступления ресурсов на склады игрока, с округлением вниз до целых единиц[38]. 3. Базовое потребление: автоматически списывается еда на содержание населения, еда и материалы на содержание армии, энергия на работу построек, потери при хранении и прочие постоянные расходы[39]. 4. Производство зданий: генерируются ресурсы экономическими постройками (фермы производят еду, электростанции – энергию, шахты – материалы и т.д.), конвертируются трудовые часы населения в реальные товары[39]. 5. Очереди производства и обучения: обрабатываются очереди строительства зданий и подготовки военных юнитов. Например, казармы в день могут призвать ограниченное число новобранцев, превращая часть свободных гражданских (LaborHours) в военных за несколько дней обучения[40][41]. Для зданий – тратятся материалы/труд на прогресс строительства. В этом шаге уменьшаются запасы ресурсов согласно заявкам в очередях и увеличивается процент завершения проектов. 6. Логистика: обновляются статусы всех активных транспортных приказов (см. раздел логистики). Если какие-то подразделения или ресурсы должны были прибыть в этот день, они перемещаются в конечную точку; вычисляется время до прибытия оставшихся конвоев, проверяется пропускная способность коридоров[42]. 7. Фортификации: аналогично, продвигается прогресс возведения или ремонта фортификационных сооружений, учитывается износ временных укреплений со временем[43]. 8. Отчет и события: по итогам дня формируется сводный отчет (для экрана экономики) и генерируются события/оповещения: обнаружение дефицита ресурса, простаивание мощностей, перегруженность логистических узлов и т.п.[43].

Правило баланса: система не допускает отрицательных значений ресурсов – если расход превышает доступный запас, включаются механики понижения потребления и распределения дефицита[44]. Например, при нехватке энергии отключаются объекты по приоритетам (сначала наименее важные)[45], при нехватке еды – прирост населения падает до нуля, растет риск негативных событий (бунты, дезертирство), а при длительном голоде население начинает убывать[46]. Все автоматические сокращения происходят прозрачно: игрок видит, какие статьи урезаны, в суточном отчете не должно быть «скрытых» списаний[47].

Типы зданий и юнитов: Экономические постройки делятся на категории: экономические здания (фермы, электростанции, шахты, склады) – увеличивают производство или хранение ресурсов; исследовательские (лаборатории, университеты) – позволяют открывать улучшения и повышают эффективность производства; военные (производственные) – казармы, заводы техники, аэродромы, которые производят боевые единицы и требуют ресурсы на содержание[48]. У каждой постройки задана стоимость строительства, время постройки (в днях), потребление/производство ресурсов в работе и на обслуживание[49]. Военные здания также имеют параметр конверсии: сколько гражданских можно обучить в день, длительность подготовки одного солдата и стоимость на одного рекрута в еде, материалах, энергии и труде[41].

UI для экономики: Требуется реализовать экран суточного отчета экономики – на нем отображаются балансы ресурсов, прирост/убыль за день, выявленные узкие места и т.д.[50]. На отдельной панели – слайдеры передачи % ИИ для каждого ресурса (5 штук: труд, энергия, материалы, еда, прирост населения) с кнопкой сброса на 0%[50]. Это дает игроку наглядный контроль над тем, сколько ресурсов он отдает под управление ИИ ежедневно.

💡 Оптимизация экономики: Расчеты экономики можно проводить разреженно – нет нужды обновлять бюджеты каждый кадр. Достаточно раз в N тиков (например, раз в игровые сутки) применять формулы, а в остальные тики держать показатели неизменными. Также все агрегаты (общий доход, расход) стоит кешировать и обновлять инкрементно при изменениях, а не вычислять с нуля каждый раз[51]. Это позволит сэкономить на расчетах, особенно при большом числе объектов.

Unit-тесты экономики: Написать простые тесты-инварианты для бюджета: например, после серии операций TryReserve и Commit сумма денег не исчезает и не создается из воздуха (балансы сходятся)[52]. Смоделировать 100 тиков с хаотичными расходами и проверять, что итоговые балансы соответствуют ожидаемым (ни один не стал отрицательным и т.п.)[53]. Логировать отказы в расходах (например, ReserveFail с указанием суммы, баланса, источника) – это поможет выявить проблемы настроек[54].

### Модель заражения и инфекции (SIR/SEIR)

Основы модели: В игре реализуется гибрид эпидемиологической модели типа SIR/SEIR и клеточного автомата. Каждая клетка на карте имеет состояние заражения: Susceptible (восприимчивая), Infected (зараженная) или Recovered (выздоровевшая и иммунная); либо ведется непрерывный счет уровня инфекции 0..1[55]. Распространение болезни рассчитывается по соседям на сетке (соседство может быть выбранным Moore 8 направлений или Von Neumann 4 направления – важно зафиксировать и использовать единообразно)[56]. Вероятность заражения клетки зависит от доли зараженных соседей, плотности населения в клетке, мобильности населения и защитных факторов.

Расчет тика инфекции: Система InfectionSystem каждую итерацию симуляции делает несколько шагов[57]: (1) Диффузия вируса по соседям: для каждой клетки вычисляется влияние зараженных соседей и изменяется уровень инфекции/статус (S→I с некоторой вероятностью)[57]. (2) Учет укреплений и карантинов: если в клетке или на границах есть защитные постройки (стена, блокпост) или зона карантина, они понижают эффективность распространения (например, снижают вероятность передачи или скорость роста)[56]. (3) Лечение/иммунитет: зараженные могут переходить в состояние R (выздоровевшие) с некоторой скоростью, которая может повышаться, если на клетку направлены ресурсы (например, медпомощь). Таким образом реализуется S→I→R динамика. Параметры (базовая инфекционность, длительность болезни, процент иммунитета и т.д.) настраиваются в конфиге InfectionParams.

Дополнительные механики инфекции: - Очаги и фронт инфекции: Если уровень заражения в группе соседних клеток превышает порог, считается, что образовался очаг. Набор граничных клеток между зараженными и чистыми зонами образует фронт заражения, который гос-ИИ будет стремиться удерживать[58]. В системе вводится понятие frontier (граница распространения). - Карантинные зоны: Игрок или ИИ могут вводить карантин в определенных регионах, уменьшая там мобильность населения и вероятность передачи. Цена – падение производства в этих клетках (меньше рабочих рук, логистические перебои)[58]. - Транспорт и распространение: Болезнь может распространяться не только локально, но и через транспортные коридоры (дороги, авиа, железную дорогу). Поэтому инфекция может «перепрыгивать» на большие расстояния, особенно если логистика не контролируется. Это отражается дополнительными событиями (например, занесение инфекции в удаленный город через аэропорт).

Алгоритмические улучшения: Чтобы обновление сетки не деградировало при большом размере, внедряется обновление только активных клеток. То есть держится список «грязных» клеток, где произошли изменения или рядом есть инфекция, и на каждом тик-цикле пересчитываются только они[59]. Также реализуется двойной буфер: сначала рассчитываются новые значения в буфере (gridB), читая из старого (gridA), затем буферы меняются местами – это гарантирует, что внутри одного тика изменения не влияют на соседей до следующего шага[60]. Этот прием предотвращает искусственное ускорение распространения из-за последовательного обновления.

Оптимизация производительности инфекции: В будущем, когда число клеток велико, планируется вынести расчет диффузии инфекции в параллельные Job’ы с Burst-компиляцией. Например, можно реализовать IJobParallelFor, разбивающий сетку на чанки, и хранить поля заражения в NativeArray<float>[59]. Burst даст значительный выигрыш, особенно если убрать из цикла лишние выделения. При миграции на ECS инфекция может храниться как компонент на сущности-клетке; расчет выполняться системой в FixedStepSimulationSystemGroup (фиксированный шаг) – тогда даже Time.deltaTime не нужно вручную накапливать[61]. Такой подход использует преимущества DOTS: данные в плотных массивах, минимизация расходов на управление.

Unit-тесты инфекции: Проверить корректность базовой модели SIR: с заданными параметрами через N тиков доля S уменьшается, I растет и затем падает, R растет до стабилизации – то есть модель ведет себя правдоподобно[62]. Убедиться, что выбранное соседство (Moore или Von Neumann) соблюдается – можно сделать gizmos-отображение соседей выбранной клетки для визуальной проверки на сцене[63]. Протестировать механизм двойного буфера: в симуляции на 1 тик убедиться, что обновление клетки не влияет повторно на соседей в тот же тик. Также важно логировать размер frontier (количество активных клеток) и время шага, чтобы видеть эффективность оптимизации при разных масштабах[64].

### Искусственный интеллект: стратегический и тактический (Utility AI, GOAP, BT)

Подход: ИИ реализуется гибридно, сочетая три уровня: Utility AI для оценки приоритетов, GOAP для планирования действий и Behavior Trees для тактического исполнения[65]. Такая комбинация позволяет ИИ реагировать на ситуацию осмысленно на разных масштабах.

- Utility AI (утилитарный ИИ): быстрый слой оценки того, что сейчас наиболее важно. Реализуется набором функций-рассуждений (Considerations), каждая из которых возвращает рейтинг 0..1 для определенной цели[65]. Например, одна функция оценивает срочность сдерживания очага инфекции – чем больше заражение на границе и меньше доступных ресурсов, тем выше приоритет удержать линию[66]. Другая функция – важность закрыть узкое место (chokepoint) фортификацией, третья – вложиться в конкретное исследование вакцины, четвертая – поддержать действия игрока в горячей точке. Все оценки вычисляются на основе текущего мира (WorldState), который предоставляет необходимые метрики: уровень инфекции в точке, силы своих войск в регионе, наличие укреплений, узловые позиции и т.д.[67]. Пример: Consideration HoldLine возвращает высокий score, если на клетке-форпосте близок прорыв инфекции[68]. Utility AI регулярно (каждый N тиков) пересчитывает эти оценки и выбирает наиболее приоритетную цель для ИИ[69]. Этот подход очень легковесен, объясним (можно вывести, почему ИИ выбрал именно эту цель) и хорошо подходит для верхнеуровневого управления.

- GOAP (Goal-Oriented Action Planning): когда цель выбрана, стратегический ИИ строит план из последовательности действий для ее достижения[65]. Планировщик (Planner) берет набор возможных действий (Action) с пред- и постусловиями и ищет цепочку, ведущую к цели, похожим образом на планировщик STRIPS. Применение GOAP – на стратегическом уровне (“государственном” ИИ): например, цель “локализовать вспышку в регионе X” может выразиться планом: собрать ресурсы → исследовать технологию «Щит-I» (улучшение вакцины) → построить 3 турели на дуге вокруг региона X[65]. Каждое действие (IAction) имеет проверку Preconditions(IWorldState) и эффект Apply()[70]. Классический референс этой системы – AI игры F.E.A.R. (Jeff Orkin)[71], где GOAP впервые успешно применили для динамического планирования поведения врагов. Для нашего ИИ планировщик будет ограничен несколькими типами действий: строительство определенного здания, начало исследования, переброска войск, введение карантина и т.д. – этого достаточно, чтобы формировать осмысленные последовательности. GOAP-план обновляется реже, чем Utility (например, при смене цели или раз в несколько секунд). Ограничиваем глубину и время поиска плана, чтобы не было просадки производительности, и кешируем уже найденные краткие планы (если ситуация мало изменилась)[72].

- Behavior Trees (поведенческие деревья): на тактическом уровне (микро-ИИ отдельных отрядов) используется древовидная логика поведения[73]. BT хорошо подходят для реакций в реальном времени: патрулирования, атаки, отступления, ремонта объектов, локальной обороны и т.п. Например, дерево для солдат может быть: Selector( если есть угроза рядом → занять оборону, иначе если есть повреждения в районе → начать ремонт, иначе → патрулировать )[74]. Behavior Tree выполняется каждый тик (для активных юнитов) и реагирует на события (враги в зоне, получен урон, приказ). Мы стараемся, чтобы BT не занимались выбором глобальных целей – пусть этим ведает Utility/GOAP – а реализовывали именно последовательность действий для текущей задачи[75]. BT легко отлаживать и визуально представлять, поэтому они будут основой тактического ИИ в бою.

Influence Maps и восприятие: В компоненте AI/Perception будут формироваться специальные карты влияния. Influence Map – это двумерная матрица (grid), на которой числом выражено влияние той или иной силы на каждую клетку[76]. Классический пример: влияние войск – каждая своя единица добавляет +X влияния на клетки рядом, а враг – отрицательное влияние. Получается тепловая карта: области с высоким положительным значением контролируются игроком, с отрицательным – врагом. Такие карты позволяют AI быстро оценивать обстановку: например, видя распределение влияния, стратегический AI может определять направления, где оборона слаба или где враг сосредоточен[77]. В нашем проекте будут как минимум: карта заражения (где высок уровень инфекции – как “вражеское” влияние), карта дружеских сил (концентрация своих войск), карта укреплений/контроля. Utility AI как раз читает эти карты при расчете – вместо того, чтобы каждый раз сканировать все объекты, он получает заранее посчитанные метрики[3]. Influence Maps легко объяснимы геймдизайну и богаты на эвристики[78]. Их обновление происходит инкрементально: при каждом значимом изменении (перемещение войск, постройка, падение города) пересчитывается влияния в окрестностях, а не вся карта целиком[79]. В тяжелых случаях расчет тоже выносится в Job’ы.

Пример влияния: ИИ может иметь Consideration: «PressureToRetreat» – оценивает, насколько велика в данной точке сила врага относительно своих. Это можно вычислить, взяв значение influence map врага минус influence map своих на клетке, нормировать к [0..1]. Таким образом Utility AI получит высокий скор для отступления, если враг доминирует[76][77].

Частота обновления ИИ: В целях производительности стратегический AI будет работать на пониженной частоте. Например, Utility-оценки – раз в 0.5–1 секунду, а тактические BT – каждый тик[80][81]. Также тяжелые вычисления (например, много условий в Utility) можно разбивать по кадрам – считать по одной группе целей за тик, чтоб не все сразу (budgeted AI). Планировщик GOAP ограничивается, чтобы не планировать новый путь каждый кадр – достаточно перепланировать, когда изменились входные условия или раз в несколько секунд.

Отладка AI: Для понимания работы AI добавим логирование его решений. Каждые N тиков (скажем, раз в секунду) в Dev-режиме выводить таблицу Utility-скоров по целям: это покажет, какие приоритеты видит ИИ[82]. При построении GOAP-плана логировать шаги: например, [GOAP] Plan: Gather → Research[Shield-I] → Build[Turret×3][83]. Для Behavior Tree можно логировать активные ветки и статус листьев (Success/Fail/Running) каждый тик[75]. Кроме того, визуализируем планы: например, отображать на карте текущую цель стратегического ИИ, или рисовать линиями путь, который планировщик намерен пройти (последовательность действий), а для BT – подсвечивать текущую экшен-ноду. Influence Maps тоже можно визуально отладить – через оверлей-тепловую карту или изолинии на карте, показывающие границы контроля[82]. Это значительно упростит настройку и поиск ошибок в решениях AI.

### События, команды и система строительства

В архитектуре предусмотрен паттерн EventBus для обмена сообщениями между подсистемами. Он обеспечивает асинхронную рассылку событий через очередь, чтобы ослабить связь между, например, симуляцией и UI[84]. Любая система может опубликовать событие (EventBus.Publish(new SomethingHappened(...))), а заинтересованные слушатели, подписанные через Subscribe, получат его при следующем фрейме, когда EventBus выполнит Flush()[85]. Благодаря этому, игровые события (построено здание, начато исследование, вспышка инфекции) обрабатываются поштучно в конце тика, не вызывая немедленных побочных эффектов.

Команды (Commands): Это паттерн для действий, которые можно логировать, отменять или воспроизводить. В игре команды используются для ключевых изменений состояния: постройка здания, приказ юниту, распределение бюджета[84][86]. Каждая команда – иммутабельный объект (например, PlaceBuildingCmd с параметрами типа здания, координат, инициатора). Команда помещается в EventBus как событие и потребляется соответствующим сервисом, который ее исполняет. Такой подход упрощает отладку – можно хранить историю команд за последние X тиков и при необходимости откатывать их. В сохранении игры можно фиксировать список команд от прошлого сохранения как лог изменений.

Пример – строительство здания: Игрок кликает на карте для строительства. Создается команда PlaceBuildingCmd(BuildingType type, GridPos at, Guid who)[87], где who – ID инициатора (игрок или ИИ). Сервис строительства (BuildService) проверяет через CanPlace возможность строительства (достаточно ли средств на переданном бюджете IEconomy, свободна ли клетка)[87]. Если нельзя – возвращает BuildOrder.Failed. Если можно – списывает средства (money.Commit(cost)), создает объект заказа строительства BuildOrder и публикует его как событие через EventBus[88]. Сам физический процесс строительства будет обработан в системе строительства (например, добавит объект здания с прогрессом постройки). Этот механизм позволяет отделить инициацию действия (команду) от выполнения (событийное реагирование), а также легко логировать все постройки (для аналитики или сетевого реплея, если понадобится).

Coalescing событий: Если за один тик накапливается много однотипных событий, их можно “склеивать”. Например, вместо 50 отдельных событий роста инфекции по каждой клетке можно выпустить одно событие “инфекция выросла в 50 клетках” с соответствующими данными[89]. Это снизит нагрузку на обработчики и освободит лог от избыточных записей. Реализуется на уровне EventBus или в менеджере событий: перед Flush проверять очередь на батчи однотипных сообщений.

Сохранение и события: Важно сохранить правильный порядок – сохранение игры выполняется после завершения обработки команд и событий текущего тика. Для этого можно установить правило: сохранение можно инициировать (через команду SaveGame) только во время паузы или в конце тика, когда игровой цикл не в середине вычислений. В ECS-реализации то же правило обеспечивается использованием EntityCommandBuffer – структурные изменения (создание/удаление Entity) происходят одним пакетом в конце системы, что эквивалентно flush-событиям[90].

Отладка событий/команд: Проверить, что EventBus.Flush() всегда вызывается после тиков систем – иначе могут быть рассинхроны (например, UI показывает событие раньше, чем обновилось состояние)[91]. Логировать сам момент флаша: например, выводить [EventBus] Flushed (count=X) – сколько событий обработано за тик. Убедиться, что события действительно очищаются (очередь пуста) к началу следующего цикла. Для команд с откатом можно написать тест: выполнить команду, затем “откатить” (например, не списывать деньги) и проверить инварианты (балансы те же и т.п.). В многопоточной DOTS-окружении – следить, чтобы никакие EntityManager.AddComponent и т.п. не вызывались вне ECB, иначе будут непредвиденные sync point’ы[90].

### Логистика и транспортные коридоры

В игре реализуется непрямое управление логистикой. Игрок не таскает юниты вручную, а отдает приказы на переброску войск или ресурсов между узлами, а система логистики автоматически доставляет их, учитывая ограничения.

Логистические узлы и коридоры: На карте выделяются специальные узловые точки: города, склады, станции, порты, аэродромы и т.п. – места, где могут накапливаться войска и ресурсы[92]. Эти узлы соединены коридорами (дороги, железные дороги, авиамаршруты). У каждого коридора есть параметр пропускной способности (например, N единиц в день) и базовое время в пути по нему (например, 6 часов)[93][94].

Приказы переброски: Игрок через интерфейс логистики создает заказ: откуда, куда, что перебросить и с каким приоритетом[95]. Например: “Перебросить 10 солдат из города A на фронт N, высокая скорость”. После этого автоматизация: система логистики находит маршрут (возможно, несколько коридоров через промежуточные узлы), ставит юниты в очередь и начинает их транспорт. Юниты двигаются автоматически – игрок их непосредственно не контролирует во время перевозки[93].

Детали реализации: В каждый момент времени у коридора есть занятость/очередь. Алгоритм находит кратчайший по времени маршрут с учетом ёмкости (capacity) коридоров[96]. Если коридор перегружен, заказы ждут. Можно вводить режим Rush – повышенный приоритет: например, +50% скорость за цену +X% к потреблению топлива/материалов на транспорт[97]. Также, для удобства, игрок может задавать домашние узлы для армий – куда по умолчанию направлять подкрепления, чтобы не делать постоянно ручные заказы[98].

Резервирование транспорта: Если несколько заказов идут по одному маршруту, система бронирует места: чтобы не было ситуации, что низкоприоритетный конвой занял весь коридор. Высокоприоритетные могут перегнать, но с дополнительными затратами. В случае отмены/завершения заказов, освобождаются слоты и выстраивается очередь заново[93].

UI логистики: Предусмотрен экран логистики – список активных приказов с указанием откуда→куда, содержимого, статуса (в пути / ожидает / прибыл) и ETA прибытия[99]. Игрок может нажать “ускорить” на конкретном заказе, что переведет его в режим Rush (если готов потратить доп. ресурсы).

Отладка логистики: Проверить, что при переброске войска исчезают из исходного узла и появляются только по прибытию в целевой (никакого телепорта). Симулировать нагруженность: отправить больше, чем capacity, и убедиться, что лишние ждут и корректно переносятся на следующий день. Метрики, которые стоит логировать: средняя загрузка коридоров, время простоя грузов/войск на узлах, бутылочные горлышки (какой ресурс или узел чаще всего ограничивает скорость)[100].

### Фортификации и оборонительные сооружения

Игрок и ИИ могут строить фортификации на карте – это защитные сооружения, замедляющие распространение инфекции и облегчающие оборону. Строительство подразделяется на временные и постоянные укрепления[49].

- Временные: окопы, наблюдательные пункты, мешки с песком – возводятся быстро (часы), требуют мало ресурсов, дают лёгкое укрытие. Но они имеют высокую деградацию: со временем их эффективность падает, под натиском (обстрелом, заражением) разрушаются относительно быстро[101].

- Постоянные: ДОТы, бункеры, капониры, рвы – строятся долго (дни) и дорого, требуют много материалов и труда, иногда потребляют энергию, но дают серьёзную защиту и служат долго[49]. Постоянные укрепления могут поддерживаться ремонтом, их деградация медленная и они ремонтопригодны[101].

Параметры фортификаций: Каждому типу задана стоимость (в трудочасах, материалах, возможно энергии), время строительства, уровень защиты/укрытия (например, процент снижения урона или вероятности заражения за укреплением), требования обслуживания (нужно ли тратить что-то на поддержание)[49].

Строительство: Фортификации возводятся специальными инженерными юнитами. Игрок указывает что и где строить, а бригады инженеров начинают работу. Можно строить линейные объекты (например, окоп вдоль линии) – тогда стоимость масштабируется с длиной, и задача автоматически дробится между доступными бригадами[102]. Также можно строить узловые точки обороны – отдельные укрепления (башни, ДОТы). Возможны улучшения: временное укрепление можно модернизировать в постоянное без полного сноса, с частичным зачетом уже вложенных ресурсов[102].

Влияние на инфекцию: Фортификации выполняют двойную роль – как оборонительные сооружения от врагов (если бы они были) и как барьеры для инфекции. В терминах модели заражения они выступают как модификаторы, снижающие вероятность распространения через клетку или ребро сетки. Например, карантинный редут (санитарный кордон) может уменьшать шанс передачи инфекции в соседнюю область на X%. Это отражается в InfectionSystem.Tick (модификаторы в шаге диффузии)[57]. Также фортификации влияют на AI: защищенные регионы получают больший вес как “сдержанные” – Utility AI может снизить приоритет вкачивать ресурсы в уже хорошо укрепленный участок, переключаясь на более слабые места.

UI строительства фортификаций: В интерфейсе будет режим строительства: игрок выбирает тип (выпадающий список или панель с иконками: временные, постоянные)[50], затем кликом на карте ставит заказ. Для линий – возможно, рисует линию. Показываются требования (сколько материалов и времени потребуется) и, после заказа, он появляется в очереди задач строительства с указанием прогресса[103]. На экране фортификаций можно видеть все текущие стройки и ремонты.

Отладка фортификаций: Убедиться, что параллельность строительства соответствует числу бригад: если доступно 2 инженерных взвода, постройка идет в 2 раза быстрее или две сразу. Проверить, что улучшение (апгрейд) учитывает уже потраченные ресурсы (например, если окоп улучшать до бункера, часть работ уже сделана). Смоделировать деградацию: запустить время вперед (например, через debug) и увидеть, что эффективность временных сооружений падает, а сообщение «укрепление нуждается в ремонте» появляется.

### Pathfinding (пути юнитов) и карты пути

Юниты (например, военные или конвои) перемещаются по сетке с помощью алгоритмов поиска пути. Базовая реализация – алгоритм A. Однако, учитывая размеры карты, сразу закладываются оптимизации: Jump Point Search (JPS) и иерархический поиск HPA**.

- A: классический алгоритм поиска кратчайшего пути на grid-графе. Реализуем сначала его для корректности. В отладочном режиме делаем визуализацию: при запросе пути, рисуем на сцене* через Gizmos или LineRenderer открытые и закрытые узлы, а также итоговый путь[104]. Это моментально выявит проблемы с эвристикой или проходимостью (можно увидеть, где поиск буксует). Также сравниваем длину пути с эталоном (например, с прямой дистанцией * стоимость шага) – для сетки без препятствий разница должна быть минимальна.

- Jump Point Search (JPS): оптимизация над A, сокращающая поиск за счет пропуска симметричных путей. На равномерной сетке JPS ускоряет A* в разы, зачастую на порядок[105][106]. Он не требует предварительной подготовки данных и не расходует доп. память – алгоритм во время поиска “перепрыгивает” через последовательности тривиальных узлов. Мы интегрируем JPS в поиск: после отладки A включаем опцию JPS, убеждаемся, что найденные пути идентичны по длине (оптимальные) и что время поиска снизилось (например, логировать время или считать число рассмотренных узлов)[107]. Есть также улучшенная версия JPS+ (offline-оптимизации, как кэширование)[108], но на первом этапе достаточно базового JPS. Согласно исследованиям, JPS может ускорить поиск более чем в 10 раз на больших сетках[105][109], и часто не уступает сложным иерархическим техникам.

- HPA (Hierarchical Pathfinding A): для очень больших карт применяем иерархию. Суть: разбить карту на кластеры (блоки, например 10×10 клеток), внутри каждого заранее посчитать “внутренние” пути между входами, и построить граф кластеров[110][111]. Тогда поиск между далекими точками сначала идет на абстрактном графе кластеров, затем спускается внутрь. HPA дает резкое ускорение на огромных картах, уменьшая число узлов в разы[110][112]. В нашем плане HPA – опциональная оптимизация (можно реализовать, если карта действительно большая). Но мы закладываем ее возможность: код архитектуры разделяет поиск на слои (Application/Pathfinding), что облегчает внедрение HPA* при необходимости[3].

Дополнения к Pathfinding: После нахождения пути добавляется сглаживание (например, алгоритм string-pulling, чтобы убрать лишние зигзаги). Также проверяется, что маршрут не ведет через опасные зоны: если какие-то клетки сильно заражены (выше порога), pathfinding может увеличивать вес этих клеток или вообще их избегать (чтобы конвои не ехали через “красную зону”). Это интегрируется как дополнительная стоимость в графе (например, вес ребра += инфекция*большой коэффициент).

Асинхронный поиск: Запросы на путь можно выполнять во вторичном потоке, особенно если юнитов много. Unity Jobs позволяют запустить несколько параллельных поисков (batch pathfinding), чтобы на основном потоке лишь получать результаты[113]. Нужно обеспечить потокобезопасность (никаких обращений к UnityAPI внутри поиска, только данных).

Отладка поиска: Помимо визуализации узлов, сделать сравнение JPS vs A*: для нескольких типовых маршрутов логировать длину и время. Проверить частичные обновления: при строительстве нового здания, например, один кластер становится менее проходимым – убедиться, что HPA обновляет только затронутые кластеры, а не весь граф[113]. Кешировать популярные маршруты: если известно, что часто идет трафик между двумя конкретными регионами, можно сохранять последний успешный путь или хотя бы дистанцию (Goal Bounding).

### Оптимизация производительности и масштабирование

По мере роста сложности симуляции важно предусмотреть шаги оптимизации и инструменты профилирования.

Эскалация технологий: Наша стратегия – начать с MonoBehaviour и простых обновлений, затем по мере возникновения узких мест переносить тяжелые части на C# Jobs + Burst, и в крайнем случае – на DOTS/ECS[114][115]. Например, первоначально InfectionSystem и AI пишутся обычным образом; когда количество агентов/клеток растет и производительности не хватает, выносим расчеты распространения инфекции, влияние карт, массовые сканы в Jobs с использованием NativeArray и пометкой [BurstCompile][116][117]. Это даст прирост без кардинального переписывания логики. Если же и этого мало (например, карта огромна или 10000 агентов), «горячие» системы переносим на ECS: создаем соответствующие компоненты (Cell, Agent) и системы, работающие с ними параллельно, с фиксированным шагом[118]. В Entities важно строго использовать EntityCommandBuffer для создания/удаления сущностей, и выполнять их в конце кадра, чтобы избежать множественных sync-point’ов[119]. Мы планируем экспериментально проверить DOTS на подсистеме инфекции (POC, см. этапы разработки) – это даст опыт, насколько оправдан переход.

Профилирование с самого начала: Уже на 1-2 день подключаем Unity Profiler и Frame Debugger к проекту[120]. Проверяем базовые вещи: сколько отрисовок (draw calls) дает Tilemap, нет ли переполнения GC при запуске цикла, как ведут себя UI-элементы. Для Tilemap: используем режим Chunk для статичных слоев (минимум draw calls), а для слоев, где должны вставать спрайты между тайлами – режим Individual + Sprite Atlas, чтобы спрайты сортировались правильно[121]. Frame Debugger подтвердит, что батчинг работает (тайлы атласированы). Эти оптимизации по рендерингу сразу закладываем, чтобы потом не переделывать карту.

Pool-инг объектов: Часто создаваемые и уничтожаемые объекты (например, снаряды, эффекты выстрелов, всплывающие маркеры) нужно пуллить – то есть переиспользовать из заранее подготовленного пула, вместо постоянного Instantiate/Destroy. Unity предоставляет шаблон ObjectPool<T>, его используем для таких объектов[122]. Особенно актуально пуллить объекты, загружаемые через Addressables, т.к. их instantiation более тяжелое на главном потоке. Это предотвратит фризы при массовом создании эффектов.

Частота обновления систем: Оптимизируем за счет разрежения: стратегический AI обновляем реже (раз в N тиков, см. раздел AI), экономику – раз в игровой день. Тяжелые расчеты, которые все же остаются каждый тик, распараллеливаем или делим на части по разным кадрам (например, рассчитывать influence map не всю сразу, а по секторам, обновляя каждый сектор раз в несколько тиков). Такой подход “размазает” нагрузку и избегает спайков.

Unity Profiling Tools: Настраиваем профилировочные сценарии – например, отдельные режимы игры или debug-кнопки, которые нагружают систему: большая карта (чтобы увидеть поведение pathfinding), массовый пожар (много одновременных событий, проверка EventBus и логики) или волна инфекции (чтобы протестировать Jobs на инфекции)[123]. Прямо в dev-меню можно сделать кнопки, запускающие эти сценарии, и кнопку “Открыть Profiler/Frame Debugger”[124] для удобства. Это ускорит выявление узких мест.

Конкретные оптимизации (сводка): Использовать NativeArray и Burst в джобах для вычисления диффузии инфекции, генерации influence-карт, массовых выборок по сетке – это типичные задачи, где Burst легко дает ×5-10 к скорости[125]. В ECS использовать FixedStepSimulationSystemGroup для систем, критичных к фиксированному шагу (чтобы они не зависели от Time.deltaTime плавучего), как это сделано в DOTS-Physics[126]. Соблюдать баланс между системами: например, разделить группы обновления по фазам (Initialization, Simulation, Presentation) и проверять, что все системы в правильных группах, чтобы не было лишних sync точек[127]. Использовать потоковую запись логов осторожно: Debug.Log внутри tight loop джоба может сильно замедлить, поэтому для отладки Bursted-кода лучше временно отключать Burst или использовать Unity.Burst.BurstCompiler.EnableUnsafeStaticBlock для условного логирования[128].

Память: Следить за алокациями. В идеале, в горячих циклах (Tick) не должно быть вообще сборок мусора. Этого добиваемся использованием пулов, preallocate коллекций, и избегая LINQ/Alloc внутри Update. В профайлере режим Profile Editor (или Attach to Player) позволит увидеть, если какой-то метод генерирует GC Alloc каждый кадр. Такие места переписываем.

### Интерфейс и инструменты отладки

UI разрабатывается не только для игрока, но и для внутреннего дебага. В проекте будет специальное developer overlay-меню, показывающее техническую информацию и дающее контроль для тестирования.

Оверлей тиков и скорости: В углу экрана отображается текущий режим времени (пауза/×0.5/×1/×2/×4) и счетчик тиков симуляции[129][18]. Там же – кнопки управления: “Пауза/Продолжить”, “Шаг” (один тик), переключатели скорости. Это служебный UI для разработчиков, но и игроку можно часть оставить (управление скоростью часто присутствует в RTS).

Тепловые карты и графики: Для отладки сложных систем вводятся режимы визуализации. К примеру, переключатель “Показать инфекцию” раскрашивает тайлы градиентом от зеленого (0% заражения) к красному (100%)[130]. Так сразу видно очаги и помогает отследить, корректно ли работает распространение (где-то скачок цвета – возможно баг). Другой режим – “Карта влияния” по своим войскам и врагу: можно отладить, правильно ли считается influence AI (полезно при настройке Utility AI, чтобы убедиться, что, скажем, врагов ИИ “видит” как красные зоны и реагирует)[130]. Также режим “статус клеток” – текстово показывать на тайле основные данные (уровень заражения, население, укрепление). Эти инструменты ускоряют балансировку.

Визуализация AI-планов: По запросу (кнопка “Показать план ИИ”) на экране может появляться схематичная диаграмма или просто текст, отражающий текущий план GOAP стратегического ИИ (см. лог выше) и активную ветку Behavior Tree для выбранного юнита[83][75]. Например, выбрав инженера, разработчик увидит: “BT: Patrol → Repair (running)” – значит, сейчас ремонтирует. А стратегический план может показать: “Goal: Contain outbreak in Region 3 → Plan: Build Fortifications (75% done)”. Такая визуализация сильно помогает удостовериться, что AI делает то, что мы ожидаем.

Логирование событий: В dev-меню можно вывести окно Event Log, где показываются последние важные игровые события: “Day 30: Power deficit – shutting down Factory 1”, “New research completed: Vaccine I”, “Outbreak intensified in Sector B (40% infected)” и т.д. Это в основном для дизайнеров и тестеров, чтобы просматривать историю происходящего и замечать, если какое-то событие отсутствует или неправильно формируется. EventBus упрощает сбор такой ленты – достаточно подписать UI-лог на нужные типы событий.

Быстрый доступ к профилю: Dev-меню содержит кнопки: “Open Profiler” и “Open Frame Debugger”. Нажатие быстро активирует соответствующие Unity-инструменты (для редактора)[124]. Это не часть билда для игрока, но экономит время разработчикам при тестировании оптимизаций.

Unit Test Runner интеграция: Хотя это не UI игры, а инструментарий, упомянем: Unity Test Framework предоставляет окошко со списком тестов. Мы создадим категории EditMode и PlayMode тестов (подробности ниже). Важно интегрировать их в процесс – например, настроить, чтобы при каждом CI-билде они пробегали, и в самом Unity можно было в один клик запустить весь тестпак.

### Тестирование, отладка и CI/CD процесс

Автоматическое тестирование: В проекте будет набор юнит-тестов (Edit Mode) и интеграционных плейтестов (Play Mode) с помощью Unity Test Framework. - Edit Mode тесты запускаются прямо в редакторе (без сцены). Ими покрываем чистую логику: экономические расчеты (см. инварианты выше), модели заражения (например, что SIR модель с заданными параметрами дает ожидаемый исход), функции предусловий/эффектов GOAP (проверить, что Action действительно приводит WorldState к нужному эффекту)[83]. Эти тесты быстрые и могут гоняться часто (например, при каждом коммите). - Play Mode тесты запускаются во встроенном игроке или Editor с эмуляцией сцены. Например, можно сделать фикстуру: маленькая карта 10×10, один очаг инфекции, пара юнитов, один город – и проиграть 200 тиков симуляции, затем проверить итоговые инварианты (не вылез ли ресурс в отрицание, сохранилось ли равновесие, правильно ли сохраняется/грузится состояние)[131][132]. Также можно автоматически загружать/сохранять игру в тесте, сравнивать определенные поля до/после. Такой автотест выступает как “дымовой” интеграционный тест.

Unity позволяет запускать эти тесты на CI. Мы планируем настроить Continuous Integration/Delivery: каждый пуш в репозиторий будет вызывать автоматическую сборку проекта и прогоны тестов. Например, через GitHub Actions или Unity Cloud Build можно настроить выполнение EditMode и PlayMode тестов на headless-режиме Unity[133]. Это гарантирует, что при внесении новых изменений мы не ломаем существующую функциональность – тесты сразу поймают регресс.

Continuous Integration (CI): внедрение CI существенно повысит надежность. При каждом слиянии кода автоматическая сборка будет проверять, что проект компилируется и все тесты проходят[134]. Unity предоставляет инструменты для этого (например, пакет Test Runner можно запускать через командную строку). Преимущества CI – ошибки ловятся рано, команда всегда имеет рабочую версию проекта[134]. Мы придерживаемся принципа частых малых коммитов, чтобы интеграция шла постоянно, а не большими редкими кусками – это ускоряет выявление проблем.

Continuous Delivery (CD): настроим автоматическую сборку игровых билдов по расписанию (например, раз в неделю ночной билд) или по тегу релиза. Unity Cloud Build или Jenkins могут собирать проект под нужные платформы, прогонять тесты и выгружать сборку тестировщикам. Это позволит в конце квартала иметь не абстрактный код, а конкретный MVP билд игры, готовый к демонстрации. К концу данного плана ожидается MVP-срез (см. ниже критерии готовности).

DoD – критерии готовности: Все фичи, помеченные как MUST, должны быть реализованы и покрыты тестами (автотестами или сценариями)[135]. UI-интерфейсы (слайдеры %, экран отчета, логистика, строительство фортификаций) должны работать и отображать реальные данные из системы[135]. Проверка: ни один ресурс не уходит в минус без обработки, никакие расходы не скрыты от игрока, все критические события (дефицит, прорыв) генерируют уведомления. Если эти условия выполнены и тесты зелены – можно считать квартальный план успешно реализованным.

### Этапы разработки и контроль прогресса (3 месяца)

Процесс разбит на модули (спринты), каждый длится ~1–2 недели, с учебными целями и наращиванием сложности. Ниже представлен поэтапный план на ~12 недель:

- Недели 1–2: Инициализация проекта и базовый каркас

- Создать репозиторий, пустой Unity-проект и настроить структуру папок по архитектуре (Domain, Application, etc)[120]. Добавить базовую сцену с Tilemap и системами координат (конвертер мир↔сетка)[136].

- Реализовать SimulationLoop с фиксированным тиком и паузой[136]. Добавить интерфейс IClock и базовые интерфейсы/классы времени, EventBus (пока пустой шаблон).

- Проверка производительности ранняя: подключить Unity Profiler и Frame Debugger, проверить отрисовку Tilemap (Chunk vs Individual)[120]. Убедиться, что цикл тика работает стабильно при разных FPS (например, вручную ограничить/освободить FPS и посмотреть на счетчик тиков).

- Недели 3–4: Основы геймплея – экономика и инфекция v1, сохранение

- Создать ScriptableObject-дефы: Units, Buildings, Techs, InfectionParams (пустые объекты с полями, чтобы заполнить через инспектор)[137]. На их основе реализовать Runtime-модели (классы Domain) и первые системы: EconomySystem v1 и InfectionSystem v1. Экономика v1 – простая: один ресурс (например, материалы как совокупный бюджет) и 2 кошелька (гос и игрок) с возможностью TryReserve и Commit. Infection v1 – простейший клеточный автомат SIR: каждая клетка имеет state, в каждом тик соседние заражают с фиксированной вероятностью[137].

- Реализовать сохранение/загрузку состояния игры в JSON (используя JsonUtility). Учесть ограничения: например, вместо Dictionary в моделях использовать списки или сериализуемые классы[23]. Добавить поле версии в сохраняемые данные. Протестировать end-to-end: запустить игру, промотать несколько тиков, сохранить, загрузить – убедиться, что состояние идентично (балансы, статус клеток и т.д.)[138]. Этот тест можно автоматизировать (PlayMode тест: старт → несколько тиков → сейв → лоад → сравнение)[138].

- Недели 5–6: ИИ – базовые решения и влияние, расширение команд

- Добавить первые Utility-скоры (3–5 штук) для гос-ИИ: например, приоритет сдерживания инфекции, приоритет укрепления узкого прохода, приоритет инвестировать в конкретное исследование[139]. Пока можно захардкодить их возвращающие рандом или по простым формулам, главное – интегрировать структуру Utility AI. Сделать простой стратегический тикер: отдельный MonoBehaviour или часть SimulationLoop, который раз в N тиков выводит в лог выбранную цель ИИ на основе Utility.

- Сформировать первую Influence Map – карта заражения: массив float по тайлам, где 0 = чисто, 1 = полностью заражено. Каждый тик обновлять ее на основе InfectionSystem (или даже внутри InfectionSystem). Визуализировать эту карту через UI оверлей (см. UI раздел) – цветом или интенсивностью[140]. Добавить концепцию “линии фронта” – список клеток на границе заражения, и тоже отобразить (например, контуром).

- Внедрить EventBus полностью и добавить обработку базовых команд: например, команду PlaceBuilding (строительство) и StartResearch (начать исследование). Пока реализации могут быть упрощенными (PlaceBuilding сразу строит без времени, Research сразу завершается), но структура событий должна заработать[141]. Протестировать: при вызове команды через код или UI сообщение попадает в EventBus, исполняется сервисом и приводит к изменению состояния. Убедиться, что EventBus.Flush вызывается после тиков, как запланировано.

- Недели 7–8: Продвинутый AI и Pathfinding

- GOAP-планировщик v1: реализовать упрощенный планировщик с 2–3 типами действий и одной простой целью. Например, цель “улучшить медицину” может требовать действий: накопить X ресурсов → выполнить исследование вакцины[139]. Можно использовать брутфорс поиск по небольшому пространству действий. Подключить GOAP к стратегическому ИИ: Utility AI выбирает цель, GOAP планирует, потом в лог выводится план и начинается исполнение.

- Behavior Tree v1: разработать несколько узлов BT для тактических юнитов. Например, патруль по маршруту (циклическая последовательность точек), ремонт ближайшего строения, реагирование на врага (пока врагами может выступать инфекция как абстрактный враг). Построить небольшое дерево и навесить его на условный “инженерный юнит” или “солдата” для теста. Проверить, что BT корректно переключается между узлами (можно логировать активные ноды).

- Pathfinding: интегрировать A для юнитов. Сделать класс PathfindingService, который по запросу выдает путь (список координат). Протестировать на примере: разместить юнит и цель, вызвать поиск – отобразить линию пути через LineRenderer в сцене[104]. Затем включить оптимизацию JPS* для поиска на сетке. Убедиться, что путь не изменился (оптимальность сохранена), а скорость возросла (можно профилировать на длинных маршрутах). Включить поддержку пакетного поиска: например, несколько агентов запрашивают путь одновременно – продумать, как избежать подвисания (например, выполнять один путь за кадр, если нет срочности, или использовать Job на поиск)[113].

- Недели 9–10: Логистика, фортификации и расширенная экономика

- Многоресурсная экономика: расширить EconomySystem до 4 ресурсов (труд, энергия, материалы, еда). Реализовать суточный цикл экономики как описано: прирост населения, распределение % ИИ, потребление, производство, очереди строительства/обучения, отчеты[36]. Добавить новые здания из design-документа (ферма, электростанция, шахта, казармы и т.д.) с параметрами производства/потребления[142]. Сделать UI-экран экономики и слайдеры передачи ИИ[50]. Эта часть объемная, возможно ее реализация займет и 11-ю неделю.

- Логистика система: ввести класс LogisticsManager. Задать несколько узлов (например, City_A, Front_N) и соединить их дорогой. Реализовать упрощенно: игрок нажимает “перебросить 1 юнит из City_A в Front_N” – система телепортирует (для начала) юнита с задержкой в несколько тиков, симулируя дорогу. Затем усложнить: добавить расчет времени, ограничение пропускной способности, очередь. Протестировать на нескольких параллельных заказах. UI: простейший список текущих трансферов с прогрессом[99].

- Фортификации: добавить возможность строить фортификации. Например, в UI добавить кнопку “Построить окоп” – при выборе клетки создается постройка типа Fortification с временем строительства. Инженерные юниты (можно упростить – пусть строится само по себе за заданное время) через каждый тик уменьшают оставшиеся часы. По завершении – на клетке отмечается укрепление (можно поменять спрайт тайла или поставить объект). Интегрировать влияние на инфекцию: если клетка имеет фортификацию, снизить скорость заражения через нее. Добавить в EventBus событие FortificationBuilt для логов.

- Недели 11–12: Оптимизация, тестирование и финализация

- Jobs + Burst: профилировать самые тяжелые места (вероятно InfectionSystem, InfluenceMap расчет). Вынести одну-две такие задачи в джобы с Burst. Например, сделать Job для обновления infection grid frontier параллельно[59]. Сравнить время до/после в профайлере. Аналогично для influence map – IJobParallelFor пробегает по тайлам и суммирует влияния. Включить опцию Burst Debug (Native Debug Mode) и убедиться, что все джобы работают без ошибок[143].

- Адресация ассетов: если к этому моменту подключены реальные ассеты (спрайты большого размера и т.п.), перевести их загрузку на Addressables. Протестировать на слабых устройствах или в профайлере память: загружать сцену, потом выгружать – не осталось ли “висящих” объектов.

- UI и удобство: довести до ума интерфейс: все разработанные экраны (экономика, логистика, отчеты) связать с данными. Добавить всплывающие подсказки, финальные правки.

- Юнит-тестпак: дописать недостающие тесты, особенно на новые системы экономики (например, сценарий “энергетический голод” – отключения идут правильно по приоритетам)[100], на логику логистики (ETA считается корректно). Запустить весь тестпак – добиться зеленого статуса.

- CI/CD: настроить в репо действие CI: сборка проекта в headless и запуск тестов. Проверить, что при ошибке теста CI падает (чтобы не пропустить регресс). Также настроить nightly build на Unity Cloud Build или локальном CI – получить автономный build игры.

- MVP проверка: Собрать минимально жизнеспособный срез (MVP) по требованиям MUST[144]. Должно быть: суточный тик с 4 ресурсами, хотя бы одно экономическое здание (ферма) и одно военное (казармы) работают, передача % ИИ влияет на баланс, работает логистика на 1 маршруте, есть один вид временной (окоп) и постоянной (бункер) фортификации, UI отчета дня и слайдеры реализованы[145]. Провести внутреннее тестирование: сценарии на дефицит, мобилизацию, логистический перегруз[100]. Все выявленные проблемы – в багтрекер и исправить.

При соблюдении этого плана к концу квартала разработчик получит прочное понимание создания архитектуры RTS и оптимизации, а проект будет обладать всеми основными подсистемами и готовым пайплайном для дальнейшего развития. Далее возможна полировка, балансировка и добавление второстепенных фич, но фундамент (архитектура + production pipeline) уже будет заложен.


[1] [2] [3] [4] [6] [15] [16] [23] [25] [26] [28] [29] [32] [33] [34] [51] [56] [58] [59] [61] [69] [71] [72] [78] [79] [80] [81] [89] [90] [108] [113] [115] [116] [117] [119] [120] [121] [122] [123] [125] [126] [137] [138] [140] document-2.txt

file://file_00000000bea06243b50b33d9516a800b

[5] [7] [8] [9] [10] [11] [12] [17] [21] [22] [24] [31] [55] [57] [65] [66] [67] [68] [70] [73] [74] [84] [85] [86] [87] [88] [114] [118] [136] [139] [141] document.txt

file://file_00000000bdd462439d54689f98b935a3

[13] [14] [129] Квартальный план разработки RTS-проекта (Unity 2D) для начинающего.docx

file://file_0000000077706243ab98f6cd120afa5f

[18] [19] [20] [27] [30] [52] [53] [54] [60] [62] [63] [64] [75] [82] [83] [91] [104] [124] [127] [128] [130] [132] [143] document-3.txt

file://file_00000000a1386243b45d516491d7291b

[35] [36] [37] [38] [39] [40] [41] [42] [43] [44] [45] [46] [47] [48] [49] [50] [92] [93] [94] [95] [96] [97] [98] [99] [100] [101] [102] [103] [135] [142] [144] [145] document-4.txt

file://file_0000000004006243943cbb9888dd4b65

[76] [77] android - Help with Strategy-game AI - Game Development Stack Exchange

https://gamedev.stackexchange.com/questions/7251/help-with-strategy-game-ai

[105] [106] [109] Jump Point Search | Shortest Path

https://harablog.wordpress.com/2011/09/07/jump-point-search/

[107] Regarding Goal Bounding and Jump Point Search

https://jair.org/index.php/jair/article/view/12255

[110] [111] [112] cs.ru.nl

https://www.cs.ru.nl/bachelors-theses/2013/Linus_van_Elswijk___0710261___Hierarchical_Path-Finding_Theta_star_Combining_HPA_star_and_Theta_star.pdf

[131] Edit Mode vs. Play Mode tests | Test Framework - Unity - Manual

https://docs.unity3d.com/Packages/com.unity.test-framework@1.0/manual/edit-mode-vs-play-mode-tests.html

[133] Best Practices — 6 — CI/CD With Unity Buildalon | by Samuel Asher Rivello | Medium

https://samuel-asher-rivello.medium.com/best-practices-6-ci-cd-with-unity-buildalon-be3286f05274

[134] What is CI/CD? Continuous Integration & Delivery Explained | Unity

https://unity.com/topics/what-is-ci-cd




## Финальный технический план проекта (2D RTS на Unity)
Источник: Финальный технический план проекта (2D RTS на Unity).md

## Финальный технический план проекта (2D RTS на Unity)

### Архитектурные модули

- Domain (Доменная логика): Содержит основные игровые модели и правила – например, сущности юнитов, зданий, экономики, инфекции и пр., а также логику их взаимодействия. В Domain определяются правила боя, экономики (производство ресурсов, ограничения по ресурсам и т.д.), спред инфекции, и прочие механики, независимые от движка. Все вычисления (например, разрешение столкновений юнитов, рост/смертность населения, распространение инфекции) инкапсулированы здесь в виде Plain C# Object моделей. Пример: класс EconomyManager в Domain рассчитывает суточный тик производства ресурсов[1], не зная о UI, а класс CombatSimulator рассчитывает исход сражения на основе статов юнитов.

- Data (Данные и конфигурация): Отвечает за хранение и загрузку конфигураций и сохранений. Статические данные (баланс) хранятся в ScriptableObject ассетах (например, типы ресурсов, параметры зданий, таблицы заражения) – только для чтения, не мутируются на runtime[2]. При старте игры конфиги SO копируются в обычные объекты (POCO), и игра оперирует ими, обеспечивая иммутабельность исходных ассетов. Сохранения хранят состояние мира (включая все активные и агрегированные сектора) в формате JSON (с версией для миграции). Пример: GameConfig.asset – ScriptableObject со списком типов ресурсов и их свойств, SaveData – структура для сериализации текущего состояния экономики, логистики, позиций юнитов и пр.

- Application (Приложение): Слой координации, связывает Domain, AI, инфраструктуру и презентацию. Здесь располагается EventBus (централизованная шина событий) для реагирования на игровые события асинхронно и декуплинга модулей (отделяет момент отправки события от момента обработки[3][4]). Application реализует основной игровой цикл: фиксированный тик симуляции, последовательный вызов subsystems (например, Economy -> Infection -> AI -> и т.д.) и затем рассылку событий через EventBus (например, событие о постройке здания или заражении юнита)[5]. Также здесь находятся контроллеры случаев использования – например, сервис команд игрока: получение команды от UI, валидация и передача в Domain (паттерн Command). Пример: класс GameLoopController в каждом FixedUpdate вызывает SimulationTick(deltaTime), который обновляет экономику, инфекцию, AI и др., после чего вызывает eventBus.Flush() для обработки накопленных событий[6].

- AI (Искусственный интеллект): Отдельный модуль, реализующий поведение NPC и врагов. В проекте комбинируется Utility AI, GOAP и Behavior Trees[7]. Utility AI оценивает цели (например, захват базы, отступление) по скорам полезности, GOAP (Goal-Oriented Action Planning) планирует последовательность действий для выбранной цели, а Behavior Trees управляют помегнтовым исполнением действий (патрулирование, атака, строительство). AI-планирование учитывает стратегические данные (например, распределение ресурсов, состояние фронта) и умеет работать как с детализированной информацией видимых секторов, так и с агрегированными данными вне обзора (см. раздел про упрощённую симуляцию). Пример: AIPlanner генерирует план нападения, опираясь на агрегированные данные о слабой защите в соседнем секторе, а при входе в сектор в обзор – переключается на точное управление юнитами через BT. Для исключения тяжелых расчётов в каждом кадре, AI может обновлять оценки целей раз в N тиков и ограничивать частоту принятия решений для поведения низкого уровня[8].

- Presentation (Презентация): Отвечает за визуализацию и ввод. Состоит из MonoBehaviour-скриптов на сцене, UI экранов и эффектов. Presentation проецирует состояние Domain на экран: спрайты юнитов, анимации, эффекты боя, интерфейс игрока. Вся логика Presentation пассивна: она подписывается на события EventBus или наблюдает за моделями Domain. Например, UnitView : MonoBehaviour слушает события о перемещении юнита или изменении здоровья и воспроизводит анимацию. UI включает экран экономики/отчёта (показывает баланс ресурсов и статистику производства[9]), панели приказов логистики (переброска юнитов, ETA)[10], постройки фортификаций и т.д. Input (команды игрока) через UI или клики по карте преобразуется в события или команды в Application. Presentation также отвечает за отображение “фронтовой карты” – стратегического обзора всего мира: показываются сектора, уровень заражения, принадлежность территорий, чтобы игрок видел общую ситуацию. Эта карта обновляется из агрегированных данных Domain по секторам (даже если они вне обзора), например, меняет цвет сектора при его захвате врагом вне поля зрения.

- Infrastructure (Инфраструктура): Низкоуровневые детали Unity и вспомогательные системы. Здесь – менеджеры сцены, загрузка данных, файловая система для сохранений, а также интеграция Unity Jobs/ECS для оптимизации. Например, тяжёлые циклы (расчёт pathfinding, массовый апдейт инфекций) выносятся в многопоточные Jobs с Burst-компиляцией для максимального использования 12 потоков CPU AMD Ryzen 9 5900X. Возможно использование Unity ECS (Entity Component System) для отдельных подсистем: например, массовое обновление позиций снарядов или агентов инфекции через ECS- системы с фиксированным шагом[11]. Infrastructure предоставляет сервис Pathfinding: хранит данные сетки пути (grid-graph), кэширует поисковые структуры и может выполнять поиск маршрутов параллельно. Также инфраструктура отвечает за профилирование и сбор метрик – интеграция с Unity Profiler, сбор логов производительности, точек расширения для автотестов (например, режим детальной отладки, когда на N-м тике печатаются ключевые данные для сравнения с эталоном).

### Ключевые подсистемы

#### Экономика и ресурсы

Назначение: Моделирование производства и потребления ресурсов, рост населения, снабжение войск. Введены 4 базовых ресурса: трудочасы населения (LaborHours), энергия (Power), материалы (Materials) и еда (Food)[1]. Каждый день происходит суточный тик экономики – пересчёт всей экономики раз в игровой день[12]. Правила Domain-уровня не позволяют ресурсам уходить в минус; при дефиците автоматически урезаются низкоприоритетные расходы[13]. В экономическую модель входит рост населения (ежедневно на основе базы CivGrowth, добавляется в пул трудочасов) и конверсия в военных через специальные здания (казармы) – определён лимит обучения в день, стоимость в ресурсах и время подготовки[14]. Экономические здания (электростанции, фермы, шахты, склады и т.д.) дают приток ресурсов, потребляют трудочасы и энергию[15]. Реализация: В Domain существует модель ResourcePool с текущими запасами и методами TryConsume() и Produce(). Подсистема экономики (например, EconomySystem) каждый суточный тик проходит по списку зданий и юнитов, суммирует производство и потребление, выполняет балансировку (отключение потребителей при нехватке). Кроме того, реализована передача части прироста ресурсов союзному ИИ (% слайдеры для каждого ресурса)[16]. API пример: EconomyService.DoDailyTick() – применяет прирост/расход ко всем секторам, генерирует события типа ResourceBalanceUpdated.

Примечания производительности: Экономика обновляется сравнительно редко (раз в день игрового времени, что может соответствовать, например, раз в N секунд реального времени). Поэтому нагрузка низкая. Однако, вычисления сводятся в агрегированные формулы (суммы, произведения), что легко распараллеливается: при необходимости можно вынести расчёт экономики на Job, если секторов много. Использование ScriptableObject конфигов ускоряет доступ к постоянным параметрам (например, стоимость строительства, выход ресурсов) – они загружены в память и не требуют парсинга. Важна проверка стабильности: профилировать EconomySystem на 1000+ объектов (юнитов/зданий) и следить, чтобы сборка мусора не давала скачков (например, переиспользовать объекты для транзакций ресурсов). Юнит-тесты проверяют инварианты экономики: недопущение появления/пропажи ресурсов, корректность резервирования и списания[17].

#### Инфекция

Назначение: Симуляция распространения некой инфекции (например, зомби-вирус) среди населения и территории. Реализована гибридная модель SIR/SEIR (Susceptible, Exposed, Infected, Recovered) в сочетании с клеточным автоматом по сетке мира[18]. Каждая клетка/сектор имеет счётчики населения в разных состояниях (здоровые, заражённые, иммунные), инфекция распространяется с вероятностями, заданными параметрами SIR-модели. Передача может происходить между соседними клетками – тип соседства фиксирован (напр. по 8 направлениям, Moore)[19]. В Domain модуль InfectionSystem на каждом такте симуляции обновляет состояние: рассчитывает новые заражения, прогресс болезни (перевод I->R), потенциальные мутации. Инфекция влияет на экономику (заражённые не работают, умирающие снижают население) и на военные юниты (может конвертировать части армии во врагов). Реализация: Используется grid из ячеек, соответствующий разбиению карты на сектора. Внутри каждой ячейки – числовые показатели инфекции. В полном (детализированном) секторе инфекция может моделироваться даже поклеточно (на уровне позиций юнитов), а в упрощённом – агрегатно (только проценты заражённых). API пример: InfectionModel.TickCell(cell, dt) – обновляет одну ячейку по дифференциальным уравнениям SIR; InfectionModel.Spread(cell, neighborCell) – передача части заражённых соседней ячейке.

Примечания производительности: Расчёт инфекции потенциально массовый (охватывает всю карту). Для оптимизации: вне сектора игрока можно снижать частоту тиков (например, обновлять инфекцию в дальних регионах раз в несколько игровых часов). Кроме того, сам расчет SIR – простой, может быть выполнен в параллель для множества ячеек. Планируется вынести обновление большого массива клеток инфекции в Job (batch processing) либо ECS System (ECS хорош для однородных расчетов по сетке, поддерживает deterministic physics[20], что полезно для повторяемости симуляции). Также, для контроля корректности, предусмотрены отладочные визуализации: подсветка уровня заражения на карте, графики S/I/R по времени, и автотесты на корректность параметров модели (сходимость, соответствие ожидаемой эпидемиологической кривой)[21].

#### AI (логистика, боёвка и поведение)

Назначение: Управление противником (и союзным ИИ, если есть) – от стратегических решений до тактического манёвра юнитов. Стратегический уровень: AI анализирует экономику и фронтовую обстановку – решает, какие сектора атаковать или оборонять, куда отправить ресурсы. Используется Utility AI для выбора целей на основе множества факторов (значимость сектора, слабость обороны игрока, распространение инфекции и т.д.)[7]. Планировщик: после выбора цели AI строит план действий через GOAP – например, цель “захватить сектор X” раскладывается на план: построить армию → отправить армию в X → атаковать и уничтожить противника. Тактический уровень: конкретные юниты управляются через Behavior Trees (или похожий паттерн) – они обеспечивают реактивное поведение: поиск пути, атака ближайших целей, укрытие при низком здоровье и т.п. Behavior Tree узлы могут быть переиспользуемыми задачами (патрулирование области, ремонт построек, строительство фортификаций). Реализация: Модуль AI взаимодействует с Domain через команды и события – например, планировщик издаёт команду на производство юнитов, подписывается на событие UnitReady (когда производство завершено) и затем издаёт команду на марш-бросок. Локальный AI юнита – компонент UnitAI : MonoBehaviour, который получает команду “атаковать позицию” и реализует её через FSM или Behavior Tree. Логистика: отдельная подсистема, помогающая AI (и игроку) в перемещении войск. Используются логистические узлы и коридоры: узлы – ключевые точки (базы, города, станции), соединённые коридорами (дороги, ж/д)[10]. AI умеет автоматически резервировать транспорт и прокладывать маршрут через узлы (например, отправка подкреплений по железной дороге), рассчитывая время в пути и нагрузку.

Примечания производительности: Основные нагрузки AI – вычисление планов и pathfinding. Планировщик Utility/GOAP работает не каждый кадр; его можно обновлять раз в несколько секунд (с небольшим случайным смещением, чтобы разные ИИ не думают строго синхронно). Behavior Trees для множества юнитов могут выполняться в каждом тик – здесь важно оптимизировать: использовать пулл объектов для BT-нод, ограничивать глубину дерева, а для простых действий (движение по маршруту) – полагаться на готовый путь от Pathfinding-системы. Pathfinding: реализован на основе сетки (tile graph) с алгоритмом A, с возможным подключением оптимизаций JPS (Jump Point Search) или иерархического поиска HPA для масштабирования[22]. Расчёт путей – кандидат для вынесения в многопоточные Jobs; при большом числе запросов может быть реализован менеджер путей, распределяющий вычисления по кадрам (например, не более N узлов A* за кадр в главном потоке, либо полные расчёты в фоновых потоках с последующим возвратом результата). Важна детерминированность** AI при прочих равных условиях – для отладки и честности геймплея: при фиксированном состоянии мира и входных данных решения AI должны повторяться. Поэтому используются фиксированные случайные сиды для рандомизации действий и избегаются плавающие точки в логике Utility (нормализованные оценки хранятся с ограниченной точностью).

#### Фортификации

Назначение: Постройка оборонительных сооружений на карте. Разделены на временные (например, окопы, мешки с песком) и постоянные (ДОТы, бункеры, рвы) типы[23]. У каждой фортификации определены стоимость (в трудочасах, материалах, иногда энергии), время возведения, прочность и уровень защиты, а также требования обслуживания (возможно, постепенная деградация)[23]. Игрок через UI строительных инструментов может начертить линию траншеи или указать точки для постройки башен и т.д. (есть инструменты линейного строительства и узловых точек[24]). Постройка выполняется инженерными юнитами; скорость зависит от их количества и эффективности. Domain-слой фортификаций взаимодействует с экономикой (списание ресурсов на строительство) и с логистикой/юнитами (прикрепляет задачи к инженерным подразделениям). Реализация: Каждая фортификация – объект с состоянием (строится/готова/повреждена). В Domain существует FortificationSystem, который обрабатывает команды строительства: создает запись о новом объекте, помечает координаты, снижает ресурсы, и через EventBus оповещает Presentation (для отображения прогресса на карте). Инженерный юнит, получив задачу, периодически отправляет команду «строить Х», и FortificationSystem прогрессирует постройку. Готовые фортификации интегрируются в систему боя (дают бонус защиты союзникам внутри, задерживают заражённых и т.д.).

Примечания производительности: Количество фортификаций обычно не огромное (десятки-сотни), поэтому их влияние на производительность невелико. Однако, важно оптимизировать отрисовку длинных объектов (например, траншеи) – возможно, схлопывая сегменты в единый Mesh или используя SpriteShape для гладких линий. Физически фортификации могут представляться коллайдерами в Unity (для блокирования пути врагам), которые активны только в пределах активного сектора. Для упрощённой симуляции вне обзора нет необходимости эмулировать процесс строительства в реальном времени – можно сразу по истечении рассчитанного времени пометить фортификацию построенной. Поэтому FortificationSystem при работе в агрегированном секторе просто увеличивает таймер постройки и завершает её мгновенно, как только таймер вышел (генерируя событие о завершении без подробностей).

#### Pathfinding (Поиск пути)

Назначение: Построение маршрутов для юнитов по сетке карты с учётом препятствий (террейн, здания, фортификации). Базовый алгоритм – A по тайл-сетке[22]. Для ускорения на большом числе узлов рассматриваются улучшения: Jump Point Search (пропуск промежуточных узлов на прямых участках) и Hierarchical Pathfinding A (разбиение карты на кластеры с предварительным расчётом межкластерных путей)[22]. Pathfinding работает в связке с логистикой: учитывает скорость типов юнитов, загруженность дорог (например, может увеличивать вес ребра дороги при избытке юнитов на ней). Реализация: В Infrastructure модуль PathfindingService предоставляет асинхронный метод FindPath(start, goal, unitType). В режиме полной симуляции (сектор в поле зрения) результат – список точек маршрута, которые передаются юниту. В упрощённом режиме (вне обзора) детализация пути не нужна – используется агрегированное расстояние: например, время пути между узлами логистики по заранее просчитанному графу. PathfindingService может иметь два режима: детальный (для локальных движений в активном секторе) и стратегический (для межсекторных перемещений). API пример: PathfindingService.RequestPath(startCell, goalCell, callback) – добавляет задачу на поиск пути; если используется многопоточная реализация, задача помещается в очередь, результат потом приходит в callback в основном потоке.

Примечания производительности: Поиск пути – одна из самых затратных операций, особенно если много юнитов двигается одновременно. Поэтому важна кеширование и повторное использование путей: PathfindingService хранит последние рассчитанные маршруты, чтобы повторно использовать их для других юнитов (особенно для стратегических перемещений между одними и теми же узлами логистики). Также разумно ограничить частоту перестроения пути – юнит не будет перезапускать A каждый тик, а только если отклонение от пути велико или появился новый препятствие. Unity Jobs могут параллелить несколько поисков сразу, т.к. поиск по независимым графам (или разным целям) хорошо распараллеливается. На целевой платформе (5900X) можно одновременно считать десятки путей. В идеале, профилировать время выполнения FindPath при различных размерах карты и применять HPA для очень больших карт, чтобы уменьшить поиск до нескольких промежуточных точек. Автотесты для pathfinding должны проверять корректность построенного маршрута (нет прохода через стены), а нагрузочные тесты – время вычисления 1000 маршрутов и отсутствие существенных фризов в кадре.

#### События и команды (EventBus)

Назначение: Асинхронное взаимодействие между системами и обработка действий игрока. EventBus – глобальная шина, куда доменные подсистемы публикуют события (например, UnitDied, BuildingComplete, SectorLost). Другие системы подписываются на интересующие их события: UI – на обновление экономики (чтобы отрисовать новый баланс ресурсов), AI – на событие смерти юнита (чтобы, например, пересчитать силы), система сохранений – на событие "игра окончена" (для автосейва) и т.д. Паттерн «event queue» гарантирует, что отправка события отделена от немедленной обработки[3] – это важно для стабильности симуляции (например, чтобы экономика могла за один тик произвести ресурсы без немедленного расходования этими же системами до завершения расчёта цикла). В конце тика Application вызывает EventBus.Flush(), и все события обрабатываются в определённом порядке. Кроме событий, существует система Command для запросов на действия: команды от игрока (построить здание, переместить войска) или высокоуровневые команды AI. Они проходят через валидацию (например, проверка ресурсов) и затем вызывают соответствующие методы Domain. Реализация: EventBus – синглтон (или передаётся через зависимости), имеющий методы Publish(event) и Subscribe(eventType, handler). Команды представлены либо объектами (паттерн Command), либо простыми вызовами сервисов Domain (например, UnitService.OrderMove(unitId, targetPos)).

Примечания производительности: События – легковесные объекты (часто struct), их генерация не должна создавать мусора. Желательно использовать object pool для повторно возникающих событий (например, deaths, hits). Отлаживать EventBus нужно на предмет потенциальных массовых рассылок: например, убийство 100 юнитов за тик приведёт к 100 событиям UnitDied – нужно убедиться, что обработчики таких событий работают быстро и не вызывают каскада дорогостоящих операций. Также важно избегать «подписок-призраков» – отписывать слушатели при удалении объектов, иначе возможны утечки памяти или NullRef. В контексте упрощённой симуляции (см. ниже) EventBus также выступает связующим звеном: события, произошедшие вне поля зрения, могут ставиться в очередь и обрабатываться, когда игрок их «раскроет» (например, событие SectorInfected могло произойти в фоновой симуляции – UI получит его сразу, чтобы обновить стратегическую карту, даже если игрок не видел сам процесс заражения).

#### Сохранение игры

Назначение: Позволить сохранять и загружать состояние мира, включая все модули. Структура сохранения: JSON-файл, содержащий версии и разделы: экономика (запасы ресурсов, состояние зданий, прогресс строительства), население, инфекция (статистика SIR по секторам), позиции юнитов и их состояния, фортификации, состояния AI (возможно, только минимум – цели AI, т.к. планы можно перестроить при загрузке), а также данные упрощённой симуляции (агрегированные модели секторов вне обзора). Реализация: Слой Data имеет класс SaveManager с методами SaveGame(file) и LoadGame(file). Сохранение запрашивается через EventBus (например, при выходе или по таймеру автосейва). Иммутабельность конфигов: важно, что конфигурационные ScriptableObject не сериализуются в сейв – их загружают из ассетов, а сейв хранит только изменяющееся состояние. Перед сохранением система убеждается, что все данные приведены к сериализуемым формам (например, словари заменены на списки пар, ссылки на объекты – на идентификаторы)[25]. Версионирование: в JSON включается поле версии, при загрузке SaveManager выполняет миграцию старых версий (через переключатель или апдейтер). Пример содержимого: раздел “population” с численностью и приростом[26], “buildings” – список строений с их прогрессом[27], “logistics” – узлы и ссылки (для восстановления графа путей)[28].

Примечания производительности и надежности: Сохранение может быть объёмным, поэтому выполняется либо в отдельном потоке (через Async I/O) чтобы не мешать кадру, либо разбивается на части (например, сначала собрать JSON в памяти, а запись на диск – асинхронно). На платформе с 32 ГБ RAM объём памяти не критичен, но важно не допустить утечки – после сохранения чистить временные структуры. Автотесты для сохранений: сравнение состояния до сохранения и после загрузки (глубокое сравнение основных подсистем), тесты на совместимость версий (эмуляция загрузки старых сейвов), а также нагрузочные тесты (сохранение в стресс-тесте, например, на максимальном количестве объектов, чтобы проверить время выполнения и корректность).

#### Пользовательский интерфейс (UI)

Назначение: Обеспечивает управление и отображение информации игроку. Включает: стратегический экран/“фронтовую” карту, показывающий целиком ситуацию по секторам (под контролем игрока, врага, уровень заражения и т.п.); экраны экономики – отчёты о дневном балансе ресурсов, узких местах, настройках передачи ресурсов ИИ[9]; панели строительства и логистики – где игрок выдаёт приказы переброски (выбирает узел отправки и прибытия, приоритет)[10], заказывает строительство зданий или фортификаций (с отображением требуемых ресурсов и времени). Боевой UI: панель отрядов, здоровье юнитов, мини-карта. UI реализован на Canvas + Unity UI Toolkit (при необходимости для сложных элементов). UI элементы взаимодействуют с Application через события/команды: например, нажатие кнопки “Построить ферму” вызывает команду строительства, а результат (появление здания) приходит как событие, на которое UI реагирует (обновляет список построек). Реализация особенностей: фронтовая карта получает данные от Domain о каждом секторе (с периодическим опросом или через события типа SectorStatsUpdated). Она не отображает реальных моделей юнитов вне обзора, вместо этого – значки или агрегированные индикаторы (например, “отряд врага (~50 ед.)” без детализации). UI также предоставляет отладочные панели (в Dev-режиме): например, график производительности по тикам, режим слоёв отрисовки (экономика, инфекция, пути) для тестирования.

Примечания производительности: UI должен обновляться с использованием unscaled time для анимаций, чтобы пауза игры не останавливала анимации интерфейса[29]. На высокой нагрузке убедиться, что обновление UI не потребляет много CPU: использовать батчи рендеринга, избегать часто изменяемых Layout Group при больших списках (например, список юнитов лучше виртуализировать или обновлять диффом). Для профилирования: Unity Profiler (категории UI) и UI Toolkit Debugger помогут найти узкие места. UI не должна зависеть от частого опроса Domain – лучше пуш-модель (событие изменилось -> UI обновился). При тестировании важно проверить, что UI корректно реагирует на события даже из фоновой симуляции (например, если база уничтожена вне экрана, значок на фронтовой карте меняется).

#### Производительность и оптимизация

Общие подходы: Проект изначально проектируется с расчётом на высокую нагрузку (масштабные сражения, множество агентов инфекции, обширная экономика) на целевом железе (12-ядерный CPU, 32 GB RAM, 12 GB VRAM). Поэтому применены следующие решения: - Фиксированный тик симуляции: Используется собственный цикл с аккумулированием времени или Unity ECS FixedStepSimulationSystemGroup[11], что обеспечивает детерминированность шага и стабильность темпа симуляции (независимо от просадок FPS). Это упрощает отладку и делает результаты повторяемыми (важно для возврата с упрощённой симуляции – см. далее). - Разделение на активные/пассивные сектора: (подробно в следующем разделе) Ограничивает количество одновременно полносимулируемых объектов. Это главный приём оптимизации, позволяющий в большой игре не обрабатывать каждый объект каждый кадр. - Многопоточность: Критические по производительности системы (pathfinding, расчёт инфекции, может быть боевая логика) работают через C# Jobs, позволяя задействовать все ядра CPU. Burst-компиляция ускоряет математику в этих Jobs. Также, Background WorkerThreads могут использоваться для несрочных задач – сохранение на диск, генерация больших текстур карт и т.п. - Object Pooling: Активно используется пул объектов для юнитов, снарядов, эффектов – чтобы при массовом создании/уничтожении (например, взрыв породил десятки частиц или одноразовых объектов) не вызывались лишние аллокации. MonoBehaviour-объекты для юнитов берутся из пула при входе сектора в видимость, и возвращаются в пул при выгрузке. - LOD для графики и логики: Графические LOD – при отдалении камеры юниты могут отображаться упрощённо (меньше детализации спрайта или отключение эффектов). Логические LOD – собственно, упрощённая симуляция вне обзора (пониженная частота тиков, агрегированные расчёты)[30]. Также, для очень далёких областей можно вообще "заморозить" симуляцию до возвращения внимания, если это не критично для геймплея. - Память: 32 ГБ RAM достаточно, но следим за утечками. Особое внимание – на крупные структуры: граф путей, массивы клеток инфекции, историю событий для сейва. Используем Addressables или подгрузку по требованию для редких данных (например, спрайты юнитов могут подгружаться пакетом при начале боя и выгружаться после, чтобы не висеть в VRAM если бой далеко). - Профилирование: Регулярно проводятся профили в сценариях worst-case (максимум юнитов на экране, вспышка инфекции на всю карту, одновременные бои). Используется Unity Profiler (CPU, Rendering, Memory модули) и Profile Analyzers для сравнения результатов до/после оптимизаций. Для удобства, встроены маркеры профилировщика вокруг крупных операций (например, Job расчёта инфекции помечен Begin/EndSample, чтобы увидеть время). - Автотесты производительности: Пишутся на основе PerformanceTest Framework (если доступно) – сценарии: 1000 тиков симуляции с максимальной нагрузкой, замер среднего времени тика и отклонений. Цель – убедиться, что средний тик укладывается, например, в 16мс (60 FPS) при целевой нагрузке. Также тестируются переходы сектора в/из видимости на предмет отсутствия фризов.

### Упрощённая симуляция «жизни» вне обзора игрока

Задача: Реализовать механизм масштабирования симуляции мира, при котором полная детализация рассчитывается только в зоне, близкой к игроку, а на удалённых участках – упрощённая, агрегированная симуляция. Это позволит поддерживать ощущение живого мира (экономика, бои, инфекция продолжаются повсеместно), не расходуя ресурсы на тщательную покадровую симуляцию всего мира.

#### Разделение мира на сектора (ячейки карты)

Игровая карта делится на крупные сектора (квадраты) фиксированного размера – например, 256x256 тайлов каждый (конкретный размер зависит от масштаба мира). Сектора образуют сетку. Активный сектор – сектор, в котором находится камера игрока (поле зрения). Соседние сектора – все клетки, смежные по стороне или углу с активным (то есть 8 соседей). Эти области считаются зоной повышенной детализации. Все сектора, находящиеся дальше одной клетки от поля зрения, считаются дальними (off-screen) и обрабатываются упрощённо. Таким образом, в каждый момент максимум 9 секторов (активный + окружение) работают в полном режиме, а остальные – в агрегированном.

Полная симуляция (FullSim): В активных и соседних секторах игра работает на полную: каждый кадр/тик обновляются все юниты, физика, ИИ, анимации и т.д. Это гарантирует, что перед глазами игрока все происходит с полной достоверностью.

Упрощённая симуляция (SimplifiedSim): В далеких секторах время течёт более крупными шагами и без деталей: - Сниженная частота тиков: вместо, скажем, 60 тиков в секунду, дальний сектор может обновляться 1 раз в секунду (или реже, настраивается). Проще говоря, мы имитируем крупные шаги времени – за один упрощённый тик может пройти сразу несколько секунд/минут игрового времени. - Агрегированная боевая модель: Вместо покадрового просчёта каждого выстрела и перемещения, бои рассчитываются статистически. Например, если в секторе присутствуют две враждующие группировки, каждый упрощённый тик мы вычисляем потери с каждой стороны на основе суммарной мощи и численности. Используются формулы вроде законов Ланчестера или упрощённые вероятностные модели: столкновение статов → потери/эффекты. Например, сравниваем соотношение сил A и B, генерируем случайную вариацию (с фиксированным сидом для детерминизма) – результат: у A погибло X юнитов, у B – Y юнитов[30]. Таким образом, длительное сражение “схлопывается” в серии резких шагов, но сохраняет примерно тот же исход, что и подробная симуляция. - Производство и строительство вне экрана: продолжается по цифровой модели. Здания в далеком секторе все еще производят ресурсы, но без создания игровых объектов – просто увеличивают счётчики ресурсов сектора раз в упрощённый тик. Строительство происходит с учетом времени: например, ферма, требующая 3 дня, в упрощённой симуляции просто имеет таймер – каждые N упрощённых тиков уменьшаем оставшееся время строительства, и по истечении – помечаем здание построенным (даже если не наблюдали процесс анимации). Ничего не отрисовывается: нет спавна рабочих юнитов, моделируется только конечный результат (ресурсы списаны, через 3 дня объект добавлен). - Логистика: перемещения юнитов между дальними секторами рассчитываются по времени фактически телепортацией на крупные расстояния. Например, если приказано перебросить армию через 3 сектора, в упрощённой симуляции можно сразу задать, что она прибудет через 5 минут (сохраняя таймер). Юниты не будут покадрово перемещаться – их позиция обновится при входе в ближнюю зону или по завершении таймера. - Инфекция: в дальних секторах моделируется на уровне суммарных цифр населения. Например, вместо заражения каждого человека, мы используем уравнения SIR с большим шагом – сразу рассчитываем, что за час заразилось 30 новых, 5 умерло, 10 выздоровело. Пространственное распространение в упрощёненном режиме тоже может быть огрублено: например, заражение перекидывается на соседний сектор только раз в сутки и на основе среднего уровня заражённости. Таким образом, инфекция “ползет” не непрерывно, а скачкообразно, но с сохранением общего тренда.

Данные сектора вне обзора: Для каждого неактивного сектора хранится агрегированная модель состояния. Это может быть структура SectorState с полями: - troopCounts – словарь {фракция: примерно сколько юнитов}, - resourceStockpiles – ресурсы, накопленные в секторе, - productionRates – скорости производства ресурсов, - infectionLevel – процент/стадия заражения населения, - buildingsInProgress – список строек с оставшимся временем, - ongoingBattles – упрощённое представление боёв (например, параметры противоборствующих сторон), - и т.д.

Эти данные обновляются дискретно каждый упрощённый тик. Важно: Каждая такая симуляция должна быть детерминированной при одних и тех же начальных условиях. Это значит, что использование случайности должно основываться на сохранённом seed (например, привязанном к координатам сектора и глобальному времени), чтобы при повторном расчёте результаты не “скакали”. В SectorState можно хранить randomSeed для генератора случайных событий (вспышка инфекции, результат боя), чтобы после загрузки игры или повторного входа в сектор получить те же результаты.

#### Алгоритм перехода от упрощённой к полной симуляции

Когда сектор, ранее находившийся в упрощённой симуляции, попадает в поле зрения игрока (или в соседний с активным), необходимо плавно переключиться на полную симуляцию, не создавая нелогичных скачков. Алгоритм перехода: 1. Остановка упрощённого тика: как только сектор должен активироваться, его фоновые обновления приостанавливаются. Например, мы видим, что камера подошла к границе – соседний сектор будет в обзоре через секунду; система заранее останавливает дальнейшие агрегированные обновления этого сектора, зафиксировав его SectorState. 2. Генерация конкретного состояния: на основе агрегированных данных создаётся детализированная сцена. Это включает: - Спавн юнитов: Для каждой группы в troopCounts создаются реальные объекты юнитов (MonoBehaviour или ECS-entity). Их количество округляется до ближайшего целого (если агрегат хранил нецелые). Расположение: генерируется разумно – например, случайно по сектору, но с сохранением общей группировки (можно использовать алгоритм раскладки: войска обороны – вокруг базы, атакующие – на границе сектора, и т.п., исходя из контекста ongoingBattles). Уровень здоровья юнитов может быть снижен согласно потерям, понесённым в агрегатном бою. - События боя: Если ongoingBattles в секторе указывал, что шёл бой, то при активации можно создать ситуацию “две армии уже вступили в бой”. Например, разместить их на небольшом расстоянии друг от друга и сразу инициировать бой между ними. Таким образом, игрок, придя, увидит продолжающееся сражение, которое соответствует тому, что фоново считалось (с уже понесёнными потерями). - Обновление построек: Все строения, которые были построены или разрушены в упрощённом режиме, синхронно создаются или удаляются. Если строительство было частично завершено, в полном режиме мы можем создать незавершенное здание с соответствующим процентом прочности или стадии (например, недостроенный каркас). В Unity это может быть реализовано через несколько стадий префаба (фундамент, полуготовое, готовое). - Инфекция и население: Создаются объекты населения/гражданских, если они симулируются явно (возможно нет, если они абстрактны). Уровень заражения сектора переносится на отдельные юниты: например, если было 50% заражено, можно считать, что половина гражданских появляются как инфицированные NPC (или сам сектор имеет параметр “заражённость” для графических эффектов). Также применять эффекты – если в агрегате была вспышка (например, +100 заражённых за время вне экрана), при активации можно запустить соответствующую анимацию или просто отразить численно. - Логистика и транспорт: Все отложенные прибытия войск в сектор проверяются. Если по таймеру должно было прийти подкрепление через 2 минуты, то в полном режиме можно либо сразу создать их на краю карты с приказом идти в пункт назначения (если как раз “сейчас” время прибытия), либо запустить таймер в реальном времени на эти 2 минуты и по истечении – заспавнить (имитируя, что они пришли из-за края карты). 3. Синхронизация времени: убедиться, что локальное время сектора скорректировано. Например, если упрощённый тик сектора обновлялся раз в час, и сектор не был в фокусе 5 часов, то при активации мы “догнали” время в агрегате. Далее сектор переходит на мелкие тики, синхронные с глобальным игровым временем. Возможен короткий переходный период: первый секунды после активации могут быть потрачены на интерполяцию состояний. Например, если в агрегированном состоянии солдаты “должны” были находиться уже у середины сектора, мы можем при спавне сразу поместить их ближе к цели, чтобы не было рассинхрона во времени пути. 4. Рассылка событий и уведомлений: когда сектор становится активным, могут генерироваться события: SectorBecameVisible, DetailedSimStart(sectorId) – это сигнал для других систем. Например, EventBus уведомляет UI/Map, что теперь сектор в фокусе – можно, например, показать детальные иконки на миникарте вместо абстрактного значка. Также уведомляется AI: если ранее AI видел сектор агрегировано, теперь у него есть точные данные – AI может пересчитать планы с учётом точного состава сил.

Обратный процесс – деактивация сектора (уход из обзора) – тоже обрабатывается: 1. Все актуальные объекты (юниты, эффекты) сектора удаляются из сцены или отключаются и возвращаются в пул, чтобы не потреблять ресурсы. 2. Их состояние сворачивается обратно в SectorState. Например, если в момент ухода в секторе осталось 10 юнитов A и 5 юнитов B воюющих, мы заносим эти цифры в агрегат, помечаем бой продолжающимся. 3. Желательно сохранить достаточную информацию, чтобы при последующем возвращении воспроизвести по возможности ту же ситуацию. Например, фиксируем, что бой идет уже X минут, что такие-то здания горят и будут разрушены через Y минут если не починить, и т.п. 4. Запускается упрощённый симулятор для этого сектора (с учётом нового состояния) – либо сразу, либо со следующего условного “крупного” шага.

#### Ограничения и детали реализации

Иммутабельность и консистентность: При переключении туды/сюды важно избегать «рассыпания» симуляции. Это означает, что состояние мира должно остаться консистентным и не зависеть от того, смотрел ли на него игрок. Мы обеспечиваем это детерминизмом и хранением полного состояния: - Immutable модели: Агрегированное состояние сектора (SectorState) можно хранить как отдельную структуру, которая не изменяется из других систем напрямую, а только через специальный симулятор. Например, SectorState может быть реализован как иммутабельный снимок, который при каждом упрощённом тике заменяется новым (чтобы не было половинчатого обновления). Это упрощает откат или проверку – в любой момент SectorState либо до, либо после тик-шага, но не в процессе. - Граница кэширования: Нужно чётко определить границы, где данные должны храниться между режимами. Например, при деактивации сектора – сохраняем последние подробные объекты в агрегат. При активации – должны быть готовы мгновенно породить детали. Чтобы не делать это синхронно в один кадр (что может вызвать фриз), можно подготовить кэш перехода: за несколько секунд до входа в обзор начать создавать объекты в неактивном состоянии. Unity позволяет создать объекты вне экрана (деактивированными) заранее. Например, если игрок быстро скроллит, мы можем предвосхитить, что соседний сектор возможно понадобится, и подгрузить его содержимое заранее (заготовить пул юнитов нужного типа, прогрузить текстуры). Граница кэширования может быть как раз соседние сектора: они всегда подгружены наперёд. Дальние же не имеют объектов, только данные. - Триггеры событий: События, происходящие в упрощённой симуляции, должны учитываться. Однако, часть событий имеет смысл генерировать только при детализации. Например, событие UnitDied – в далеком секторе не будет вызываться для каждой смерти (их там может быть десятки за шаг), вместо этого можно генерировать агрегированное событие BattleResults с итоговыми потерями. Но если игрок потом входит и видит тела – ему не нужны ретроспективные события о каждой смерти, достаточно того, что бой был. Поэтому некоторые события «приглушаются» вне обзора. С другой стороны, глобально важные – всё равно генерируются: напр. уничтожение базы игрока в off-screen секторе сразу вызывает PlayerBaseLost событие, даже если игрок этого не видел непосредственно. - Сохранение состояния: В файле сохранения храним все SectorState для упрощённых секторов. Также храним, какие секторы активны. При загрузке, те что неактивны, запускаются сразу в упрощённом режиме (можно даже не создавать их объекты, а просто планировать события, например, если по сохранению через 2 часа должен пасть сектор – после загрузки запланировать это через (2 часа - уже прошедшее время)). Сохранение/загрузка должны быть аккуратны: например, сохранить randomSeed секторов, чтобы продолжить ту же детерминированную последовательность.

#### Влияние на EventBus, AI и карту фронта

EventBus: нужно учитывать, что события из фоновой симуляции могут поступать реже и более агрегировано. Реализация: может быть два канала событий – локальные события (для конкретных секторов, детальные) и глобальные события (агрегированные). Например, вместо множества UnitDied в секторе X (который off-screen) отправляется одно событие SectorBattleUpdate(X, потериA, потериB). Подписчики AI или UI, которые отслеживают ход войны, обрабатывают его, обновляя состояние фронтовой карты. Когда сектор становится видимым, EventBus может переключить тип событий: теперь снова идут индивидуальные UnitDied, BuildingComplete и т.д. Для подписчиков это прозрачно, если они изначально умеют обрабатывать оба режима. Важный момент – не задваивать события: если база была разрушена вне экрана и это отразилось в событии SectorLost, то при входе в сектор мы не должны снова генерировать BuildingDestroyed (уже было учтено). Нужно либо помечать такие события как уже обработанные, либо подавлять их генерацию при переходе.

Система сохранений: При сохранении игры в середине упрощённой симуляции все агрегированные данные уже находятся в SectorState и будут записаны. Но нужно также сохранить, что, например, в секторе шёл бой с такими-то участниками. Чтобы при загрузке и немедленном открытии сектора не получить “статичных” мирных юнитов вместо ожидающегося боя. То есть, часть агрегированной динамики должна сохраниться: либо в виде событий (в сейве хранить «pending events» типа “бой в секторе N продолжается”), либо просто через состояние (например, флаг sectorState.isBattleOngoing = true, и списки участников). Это позволит правильно инициализировать полный режим после загрузки.

AI-планирование: AI должен уметь принимать решения, опираясь на неполные данные. Обычно AI «знает» о враге только то, что видит игрок (fog of war). Но если AI контролирует дальние сектора (например, вражеская база вне обзора), то для него эти сектора всё равно симулируются, просто с пониженной точностью. Стратегический AI будет работать с агрегированными данными: например, решает атаковать сектор игрока, зная, что у него там ~50 солдат (агрегировано). Он может отправить 60 своих – и эта отправка происходит через упрощённую логистику (например, отметится, что через 10 минут прибудет армия). AI также получает информацию с той же периодичностью: если в off-screen секторе произошли изменения (потери, строительство турелей), AI узнает об этом через глобальные события или через прямой доступ к SectorState (если считаем, что ИИ “всеведущ” для своих территорий). Главное – планы AI должны быть стабильны: если AI решил что-то, уход игрока не должен сбросить планы. К примеру, AI осадил город игрока, игрок ушёл – бой продолжился упрощённо. AI не должен внезапно передумать, получив слегка другие цифры – для этого можно вводить гистерезис: AI решения не пересчитывает каждую секунду в off-screen, а держится курса, пока не произойдёт крупное событие. На тактическом уровне, когда сектор активен, AI переходит к детальному управлению (исполняет Behavior Tree для каждого юнита). При деактивации AI может освобождать тактические контроллеры и вернуть управление стратегическому симулятору.

“Фронтовая” карта: Эта стратегическая карта напрямую питается от упрощённой симуляции. Каждому сектору на карте соответствуют агрегированные данные, и цвет/значки на карте обновляются соответственно: - Если сектор вне обзора, карта показывает его состояние из SectorState: напр., численность сил врага (можно округленно, “??” если информация неизвестна игроку), уровень заражения (например, индикатор 30%), наличие боёв (иконка перекрещенных мечей, если идет бой). - Если сектор в поле зрения, карта может показать более точную информацию или отметить, что игрок “наблюдает” там. Переход сектора в полный режим должен плавно отразиться: например, значок “бой” может замениться конкретными юнитами на тактическом мини-экране. Важно: фронтовая карта – инструмент игрока, поэтому она должна быть согласованной с реальностью. Упрощённая симуляция обеспечивает, что даже если игрок не смотрит, на карте все равно будет отражаться приближение фронта (например, красная зона инфекции распространяется). При возврате в сектор никаких ретконавтов: состояние на карте соответствует тому, что игрок увидит глазами.

#### Стабильность и детерминированность симуляции

Чтобы мир вел себя правдоподобно, необходимо, чтобы при повторном входе в сектор состояние не “случайно” отличалось. Для этого: - Все генераторы случайности в упрощённой симуляции используют фиксированные seeds, как упомянуто. Можно даже привязать seed к глобальному времени: напр., каждый день для боёв генерируется одна случайная серия, чтобы при сохранении/загрузке в середине боя результаты не менялись. - Агрегированные формулы отлаживаются против полного симулятора: проводится тест, когда тот же сценарий прогоняется двумя способами – (A) полностью, (B) выключив сектор на час и вернув. Результаты (потери, оставшиеся ресурсы) должны совпадать или быть очень близкими. Если расхождения сильны, корректируем модели. Возможно, придется хранить дополнительные данные, чтобы при детализации скорректировать. Например, упрощённый бой не учитывал положение юнитов, и при активации они начнут стрелять сразу – это может удваивать потери по сравнению с расчетом. Решение: при активации временно уменьшить меткость или дать им время на сближение, чтобы компенсировать. - Идемпотентность переходов: многократное включение/выключение сектора за короткое время не должно сильно влиять на результат. Если игрок дергает камеру туда-сюда, мы должны предотвращать эксплойты (например, “пока не смотрю – мои войска не умирают” или наоборот). Для этого можно вводить задержку на переключение: сектор считается активным, если он был в зоне обзора более X секунд, и деактивируется с небольшим лагом. Это сгладит частые переключения. Также, при быстром уходе и возврате, можно частично сохранить детальные объекты (не уничтожать их мгновенно, а через некоторое время) – чтобы если вернулись, не создавать заново. - Согласованность времени: фиксированный глобальный тик помогает: даже если сектор обновляется раз в секунду, он делает это по меткам глобального времени. Значит, если игрок вернулся ровно на 12:00, а на 11:59 там был последний апдейт, то между 11:59 и 12:00 может быть короткий “догоняющий” период, но потом полная симуляция идет синхронно с остальными. - Тестирование: Понадобятся тщательные тесты: сценарии, где игрок покидает бой и возвращается к его окончанию – убедиться, что исход логичен и воспроизводим. Тесты, где строится здание: начать стройку, уйти, вернуться после предполагаемого завершения – здание должно стоять готовое. На автоматическом уровне можно скриптом: сравнить мир, эмулированный полностью 10 минут, и мир, где 5 мин был off-screen, 5 мин on-screen – разницы нет в ключевых метриках.

#### Профилирование и автотесты поведения упрощённой симуляции

Профилирование: Необходимо измерять выгоду и накладные расходы введения SimplifiedSim. С помощью Unity Profiler оцениваем: - Время обновления 1 сектора FullSim vs десятка секторов SimplifiedSim в сумме. Ожидание: упрощённый на порядки дешевле. Если выяснится, что агрегированные расчёты тоже тяжелы (например, огромные формулы или много аллокаций), их оптимизируем (кэшируем результаты, упрощаем модель). - Спайки при переходе: включаем Deep Profile или инструмент измерения времени при активации сектора. Проверяем, нет ли больших фризов при спавне объектов. Если есть, внедряем поэтапную подгрузку: как говорилось, создавать объекты постепенно. Можно распределить создание юнитов на несколько кадров (например, 100 юнитов спавнить по 20 в кадр). Также использовать профилировщик памяти – убедиться, что переход не приводит к неожиданному всплеску (например, повторная загрузка тех же текстур – это нужно предотвратить, держа их в памяти). - Тест производительности на масштабируемость: увеличить размер активной зоны (например, 5х5 секторов full) и проверить, держит ли движок нагрузку. Цель – выявить, что даже без упрощения всё ок на небольших областях, а с упрощением – линейное масштабирование по количеству секторов.

Автотесты и QA: Для такого механизма будут написаны специальные сценарии тестирования: - Consistency Test: как описано, сравнение полного vs смешанного симулирования. Это можно автоматизировать: запустить игру в режиме “всё активно” на X минут, сохранить state. Потом перезапустить, но отключать сектор (телепортировать камеру прочь) на некоторое время, потом возвращать – и снова сохранить state. Сравнить ключевые показатели (ресурсы, кто контролирует сектор, численность юнитов, уровень инфекции). Разрешены небольшие отклонения, но не драматические. Эти тесты должны проходить перед релизом каждого баланса изменения. - Edge Case Test: ситуации, когда на границе видимости происходят события. Например, юнит пересекает границу активного сектора: он не должен исчезнуть или подвиснуть. Пишем тест: отправить юнита из видимого сектора в соседний невидимый и обратно – убедиться, что при выходе он корректно передан в агрегат (возможно, мы мгновенно переключаем его под управление SimplifiedSim), а при возвращении – вновь появился. - Determinism Test: запускаем один и тот же сценарий несколько раз (с фиксированным seed) и проверяем, что статистика по окончании совпадает. Особенно касается боёв: 10 авто-битв оффскрин с одних условий дают один и тот же результат. - Performance Test: скрипт, который перемещает камеру по маршруту, охватывающему множество секторов, в течении, например, часа игрового времени. В конце смотрим лог профилировщика или метрики: средний FPS, максимальные задержки на переходах. Эти тесты могут запускаться на разных конфигурациях (PC, target hardware) чтобы убедиться, что нет проблем. В частности, на заявленном железе 5900X + 32GB + 12GB GPU ожидается, что фриз при самом тяжёлом переключении (например, город с 200 юнитами становится видимым) не превышает допустимого (например, <50 мс). Если больше – оптимизировать (предзагрузка, уменьшение объектов и т.д.).

В итоге, данный механизм упрощённой симуляции интегрирован во все слои архитектуры (Domain: логика LOD, Data: хранение состояния, Application: переключение режимов, AI: адаптация к агрегатам, Presentation: стратегическая карта и отсутствие визуала оффскрин, Infrastructure: много потоков для бэкграунда). Он не отключаем – это фундаментальный элемент оптимизации под масштаб. На целевой платформе система обеспечивает правдоподобную активность мира и одновременно высокую производительность, создавая иллюзию, что “жизнь продолжается” повсюду, хотя на самом деле вычислительные ресурсы тратятся только там, где это нужно[30].


[1] [9] [10] [12] [13] [14] [15] [16] [23] [24] [26] [27] [28] document-4.txt

file://file_0000000049b062438e06b107048784b7

[2] [5] [6] [7] [8] [11] [17] [18] [19] [21] [22] [25] [29] document-3.txt

file://file_000000001f0461f4847b90af8dfa8700

[3] [4] Event Queue · Decoupling Patterns · Game Programming Patterns

https://gameprogrammingpatterns.com/event-queue.html

[20] Design philosophy | Unity Physics | 1.0.16 - Unity - Manual

https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/design.html

[30] architecture - Elegant way to simulate large amounts of entities within a game world - Game Development Stack Exchange

https://gamedev.stackexchange.com/questions/3090/elegant-way-to-simulate-large-amounts-of-entities-within-a-game-world



