# Project Decisions (active)

## Решения, принятые в текущей итерации

- Input Handling
  - Поддерживаем и New Input System, и Legacy Input через компиляционные флаги; при необходимости в Player Settings использовать `Active Input Handling = Both`.
  - Статус: accepted.
- Persistence
  - В рамках S1 используем `JsonUtility`; расширили сохранение до позиций и активных целей юнитов; переход на `System.Text.Json` рассмотрим позже.
  - Статус: accepted (temporary).
- UI (Prototype)
  - HUD реализован через IMGUI (`OnGUI`); клики над HUD не передаются игровым системам. Плановая миграция на uGUI в следующих спринтах.
  - Статус: accepted (temporary).
- Build (минимальный цикл)
  - Размещение постройки валидируется по стоимости (`BuildingConfig.Cost`), при успехе ресурсы списываются из `EconomyState`; при нехватке возвращается shortfall.
  - Статус: accepted.

Выбранные решения для ускорения прототипа. Ссылки указывают на строки в OPEN_QUESTIONS.md.

## Economy
- Decision: Единица времени — tick по Time.deltaTime; расчёт раз в Update
- Decision: Начальные запасы: 0; отрицательные запасы запрещены
- Decision: События/подписки для уведомления UI при изменении запасов
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:6 — 6) Профилирование: `Window → Analysis → Profiler` (Ctrl+7) и треки `Scripts`/`UI`. Смотри консистентное время тика, нет ли всплесков по GC. citeturn0search12 [defer]
- Ref: docs/OPEN_QUESTIONS.md:15 — - Вычитайте из аккумулятора величину tick и затем вызывайте обновление всех систем игры в определённом порядке. Пока системы (экономика, инфекция, ИИ и др.) не реализованы, можете временно вызывать заглушки или логировать вызов тикov для каждой подсистемы. Позже, по мере прохождения модулей, сюда будут добавляться реальные вызовы: InfectionSystem.Tick(tick), EconomySystem.Tick(tick) и т.д.. Сейчас достаточно вывести в лог, например, "Tick X processed", где X – номер тика [defer]
- Ref: docs/OPEN_QUESTIONS.md:16 — - Реализуйте возможность паузы: флаг IsPaused. В начале Update() проверяйте: если игра на паузе, не накапливайте время и сразу возвращайтесь (пропуская логику тика). В интерфейсе IClock сделайте Delta = IsPaused ? 0 : tick для удобства (или просто используйте флаг) [defer]
- Ref: docs/OPEN_QUESTIONS.md:18 — - Скорости ×0.5, ×1, ×2, ×4: Введите множитель времени (например, timeMultiplier), который будет влиять на скорость симуляции. Можно просто делить/умножать значение tick или накапливаемое время. Например, для ускорения ×2 уменьшайте tick вдвое (или увеличивайте accumulator в 2 раза быстрее). Учтите, что UI и анимации должны продолжать работать с нормальной скоростью (они и так на unscaled время, так что изменение нашего tick не затронет UI) [defer]
- Ref: docs/OPEN_QUESTIONS.md:19 — - Одиночный тик (Step): Реализуйте отдельную функцию или кнопку, по нажатию которой симуляция выполняет ровно один тик и снова останавливается. Для этого можно: если игра на паузе, принудительно вызвать один цикл while(acc >= tick) либо вызвать методы Tick() всех систем один раз вручную. Сделайте проверку (Assert), что при одном нажатии выполняется не более одного тика [defer]
- Ref: docs/OPEN_QUESTIONS.md:21 — - Счётчик тиков: Добавьте на экран простой текстовый индикатор (например, в углу UI) или Debug.Log вывод, который увеличивается каждый раз, когда происходит тик. Это поможет отследить, что тики идут регулярно и не пропускаются. Можно хранить счётчик tickCount в SimulationLoop и обновлять его в цикле [defer]
- Ref: docs/OPEN_QUESTIONS.md:23 — - Удостоверьтесь, что GC не генерируется каждый тик из-за ваших операций. Например, если логируете каждую итерацию while, это может создавать сборки мусора из-за конкатенации строк. В продакшн-коде постоянный лог внутри цикла следует отключить или обернуть условием if (Debug.isDebugBuild) [defer]
- Ref: docs/OPEN_QUESTIONS.md:24 — - Индикатор тиков: Проверьте, что UI-индикатор или лог счётчика тиков увеличивается равномерно и без пропусков. Если при паузе он останавливается, а при изменении скорости – меняет темп, всё правильно [defer]
- Ref: docs/OPEN_QUESTIONS.md:25 — - Одиночный шаг: Нажатие кнопки «Step» должно приводить к выполнению ровно одного цикла while(acc>=tick). После шага цикл не должен сразу продолжаться, иначе это признак, что неправильно контролируется пауза или accumulator. Проверьте через Assert, что за один вызов Step производится не более 1 тика [defer]
- Ref: docs/OPEN_QUESTIONS.md:27 — - Типичные ошибки: Если замечаете, что тики «плавают» или идут быстрее/медленнее заявленного – проверьте сброс аккумулятора в цикле while. Нередко ошибка – не полностью вычитать tick из acc, что приводит к ускорению или замедлению цикла. Другой частый баг – забыть вызвать EventBus.Flush() в конце тика (пока EventBus не работает, это не влияет, но позже будет критично). Также убедитесь, что симуляционное время отделено от времени UI: не используйте Time.deltaTime там, где нужен unscaledDeltaTime [defer]
- Ref: docs/OPEN_QUESTIONS.md:28 — - Исправление ошибок: Если цикл работает не так, как ожидалось (например, ticks пропускаются или идут неритмично), скопируйте свой код и запросите: «Найди ошибку в логике фиксированного цикла». Расширение Codex может подсветить проблемные места (например, неправильный сброс acc или использование deltaTime вместо unscaledDeltaTime) [defer]
- Ref: docs/OPEN_QUESTIONS.md:29 — - Пояснение кода: Если какие-то конструкции непонятны (например, Time.unscaledDeltaTime или работа while цикла), можно спросить: «Объясни, как работает этот код строчка за строчкой». Это поможет глубже понять шаблон фиксированного тика [defer]

## Build/Research
- Decision: Данные построек/исследований — ScriptableObject с ResourceAmount[]
- Decision: Размещение построек по сетке; проверка стоимости и коллизий в Domain/Application
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:9 — - **Линейное строительство** (траншеи по полилинии) [defer]
- Ref: docs/OPEN_QUESTIONS.md:58 — - Адресация ассетов: Если применили Addressables, включите режим PlayMode (Use Existing Build или Simulate) и отследите, что после сцены, где вы загрузили ассеты, при выходе или переходе они выгружаются. Логи или профайлер памяти помогут заметить, не остались ли ассеты висеть (у Addressables есть профайл и EventViewer, но это за рамками базового плана) [defer]
- Ref: docs/OPEN_QUESTIONS.md:75 — - Убедитесь, что эти объекты доступны остальным системам: например, BuildService (будет позже) сможет получить ссылку на тот IEconomy, который оплачивает строительство (игрок или государство) [defer]
- Ref: docs/OPEN_QUESTIONS.md:92 — - Несоответствие Reserve/Commit: например, вызвали TryReserve, получили true, но забыли вызвать Commit – деньги как бы висят. В простом варианте A это сразу списано, нет проблемы. В варианте B важно, чтобы в коде, где резервируете, всегда был парный Commit (например, в BuildService) [defer]
- Ref: docs/OPEN_QUESTIONS.md:120 — - Карантинные зоны: Позже, когда будет система строительства, можно предусмотреть, что определённые постройки (например, блокпосты) создают области, через которые заражение распространяется хуже или не распространяется вовсе. Реализовать это можно сейчас, если добавить в InfectionParams какой-нибудь коэффициент quarantineEffect, и в диффузии: если клетка сосед – карантинная (нужно знать, есть ли кордон на ней, а это значит, что система построек должна сообщать), то либо пропустить заражение, либо сильно ослабить (умножить на 0.1 например) [defer]
- Ref: docs/OPEN_QUESTIONS.md:132 — - Проверка модели SIR: Убедитесь, что базовая «физика» SIR соблюдается. То есть если вы настроили параметры (например, infectionRate, recoveryRate), попробуйте в небольшом примере на бумаге или в таблице прикинуть, как S->I->R должно происходить. Запустите симуляцию на маленькой сетке 3x3 и проследите, как одна заражённая клетка заражает соседей. Если уровень накапливается плавно, все хорошо. Если сразу все стали заражены – значит infectionRate слишком высок или threshold низкий [defer]
- Ref: docs/OPEN_QUESTIONS.md:156 — - Самый простой вариант (из документа) – использовать dynamic: foreach(var h in subs) (h as dynamic).On((dynamic)e). Это позволит вызывать метод On у подписчика, соответствующий типу события. Например, если e типа BuildOrder, а подписчик имеет On(BuildOrder order), то dynamic-система найдёт его [defer]
- Ref: docs/OPEN_QUESTIONS.md:159 — - Если нельзя, возвращает какой-то результат (можно сделать BuildOrder со статусом Failed или null) [defer]
- Ref: docs/OPEN_QUESTIONS.md:169 — - Создайте класс (можно статический) BuildService с методом, или инстанс (если нужно хранить что-то, но вроде нет) [defer]
- Ref: docs/OPEN_QUESTIONS.md:196 — - Execute: собственно, делает действие (в нашем случае, может быть: вызывает BuildService.PlaceTower на конкретной клетке, или просто publishes Event "DeployUnits") [defer]
- Ref: docs/OPEN_QUESTIONS.md:202 — - Допустим, у игрока/ИИ есть рабочий или солдат (представим один объект). Он может: патрулировать, чинить постройки, реагировать на угрозу [defer]
- Ref: docs/OPEN_QUESTIONS.md:203 — - Иначе, если есть повреждённое здание (для примера, представим, что заражение может "повреждать" постройки, или просто случайно сделаем здание нуждающимся в ремонте): тогда юнит идёт туда и "чинит" [defer]

## UI/HUD
- Decision: Производственный UI — uGUI; OnGUI оставить как временный для прототипа
- Decision: Модель: Presenter (Application) -> View (MonoBehaviour) через события/биндинги
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:17 — - Добавьте метод SetPaused(bool) для изменения состояния паузы. Его будем вызывать из UI или горячей клавиши [defer]
- Ref: docs/OPEN_QUESTIONS.md:20 — - Добавьте UI-контролы или горячие клавиши для управления скоростью и паузой. Например, кнопки «Пауза/Продолжить», «Шаг», а также переключатели скорости. Эти элементы можно разместить в простом Overlay-меню для разработчика [defer]
- Ref: docs/OPEN_QUESTIONS.md:48 — - Добавьте счётчики или логи сколько ассетов загружено/выгружено, используя events или отладочный UI, чтобы убедиться, что нет избыточно висящих в памяти объектов [defer]
- Ref: docs/OPEN_QUESTIONS.md:79 — - Создание IEconomy: В папке Scripts/Domain/Economy создайте интерфейс IEconomy и опишите сигнатуры методов. Затем в Scripts/Application или где уместно – класс Economy : IEconomy [defer]
- Ref: docs/OPEN_QUESTIONS.md:148 — - Визуализация: Если вы затрудняетесь с UI, можете спросить: «Как сделать тепловую карту заражения на Unity Tilemap?». AI подскажет про Tilemap.color или про Texture2D, это может дать идеи [defer]
- Ref: docs/OPEN_QUESTIONS.md:155 — - Subscribe(object handler): регистрация подписчика. Подписчиком может быть любой объект, имеющий методы-обработчики событий. Проще всего – пусть подписчик реализует интерфейсы для событий или просто имеет публичные методы On(EventType e) [defer]
- Ref: docs/OPEN_QUESTIONS.md:266 — - После Complete(), данные в gridNextNative заполнены. Скопируйте их обратно в обычную структуру (или, если вы полностью переходите на NativeArray как основное хранилище, можно хранить так). Например, можно иметь float infectionLevel для UI или отладки, или сразу перебирать NativeArray при визуализации [defer]
- Ref: docs/OPEN_QUESTIONS.md:317 — - Вы пишете код SimulationLoop. Не уверены, правильно ли сделали паузу. Вы спрашиваете: “Как правильно реализовать паузу в Unity с фиксированным шагом симуляции?”. AI отвечает, упоминая Time.timeScale и свой loop. Вы сравниваете с вашим методом. Решаете, что ваш метод ок, но добавляете совет AI про Animator.updateMode = UnscaledTime для UI анимаций [defer]

## Architecture
- Decision: Принять 4-слойную архитектуру: Domain/Application/Infrastructure/Presentation
- Decision: Unity API только в Presentation/Infrastructure; Domain/Application — чистый C#
- Decision: asmdef на слой; ссылки направлены сверху вниз (Presentation -> Application -> Domain)
- Decision: DI вручную (композиция в точке входа/сцене), без контейнеров
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:26 — - Стабильность при разных FPS: Сравните поведение тиков при 30 FPS и при 200 FPS (можно ограничить FPS через QualitySettings или vsync). Число тиков в секунду и общее развитие симуляции должно быть одинаковым. Это ключевое свойство фиксированного цикла – независимость от частоты кадров [defer]
- Ref: docs/OPEN_QUESTIONS.md:37 — - Для каждого типа данных создайте класс ScriptableObject. Например, InfectionParams (ScriptableObject) с полями для коэффициентов модели заражения, или BuildingDef с полями стоимости строительства, радиуса действия и пр. В документе архитектуры есть пример TechDef – ScriptableObject для технологии [defer]
- Ref: docs/OPEN_QUESTIONS.md:41 — - Сохраняйте их в удобной структуре, например, словарь Dictionary<string, Tech> для технологий по ID, чтобы потом быстро получать по идентификатору. Учтите: словари нельзя напрямую сериализовать через JsonUtility, но для быстрого доступа в памяти они удобны. Позже при сохранении нужно будет перенести их в список или другой формат [defer]
- Ref: docs/OPEN_QUESTIONS.md:44 — - Сделайте GameState , чтобы JsonUtility могла его сериализовать. Если в нём есть сложные поля (например, Dictionary), замените или пометьте их как и заполняйте через вспомогательные списки. Важно: JsonUtility не поддерживает Dictionary и полиморфные типы без специальных атрибутов. Поэтому убедитесь, что все поля GameState – либо примитивы/структуры, либо списки/массивы таких примитивов/структур [defer]
- Ref: docs/OPEN_QUESTIONS.md:46 — - Сохранение: сбор текущего состояния игры в экземпляр GameState и сериализация его в JSON. Используйте JsonUtility.ToJson(gameState). Полученную строку можно сохранить в файл (например, в Application.persistentDataPath) или просто в PlayerPrefs для простоты [defer]
- Ref: docs/OPEN_QUESTIONS.md:51 — - Загрузка данных: Создайте скрипт GameDataLoader (MonoBehaviour на отдельном объекте менеджере или внутри SimulationLoop). В его Awake или Start получите списки ассетов. Если используете Resources, то: TechDef techs = Resources.LoadAll<TechDef>(""); (путь можно уточнить). Далее инициализируйте, например, Dictionary<string, Tech> techMap = new(); и цикл: foreach(var techDef in techs) { techMap = new Tech(techDef.Id, techDef.ResearchCost, techDef.Prereq.Select(t => t.Id).ToList()); }. Аналогично для других типов (Buildings, InfectionParams и т.п.). Теперь ваши системы могут обращаться к этим структурам для получения параметров [defer]
- Ref: docs/OPEN_QUESTIONS.md:56 — - JsonUtility ограничения: Попробуйте прямо сейчас выполнить JsonUtility.ToJson(someScriptableObject) – убедитесь, что, например, поля-словарики там не сохраняются. Если ваши runtime-модели содержат несериализуемые поля, подумайте, как их исключить или преобразовать. Например, Dictionary заменить на список пар ключ-значение при сохранении/загрузке. Лучше выявить и решить эти моменты заранее, написав простые тесты на сериализацию [defer]
- Ref: docs/OPEN_QUESTIONS.md:57 — - Частые проблемы: забыли пометить класс – тогда JsonUtility выдаст пустой JSON. Или, например, попытались сериализовать что-то вроде Dictionary – JSON выйдет пустой. Лечится заменой структур. Другая ошибка – сериализация больших структур (сетка 1000x1000) может быть медленной или громоздкой; но пока игра маленькая, это приемлемо [defer]
- Ref: docs/OPEN_QUESTIONS.md:61 — - Оптимизация данных: Codex способен объяснить и рекомендуемые практики. Например: «Почему Unity не сохраняет Dictionary в JSON и как это обойти?» – поможет понять и выбрать решение (конверсия или использование другой JSON библиотеки) [defer]
- Ref: docs/OPEN_QUESTIONS.md:74 — - Создайте в игре два объекта/сервиса: stateEconomy и playerEconomy. Их начальные балансы можно задать в конфиге (например, ScriptableObject с начальными финансами) или в коде (какими-нибудь значениями для теста) [defer]
- Ref: docs/OPEN_QUESTIONS.md:83 — - Например, в GameDataLoader после загрузки конфигов: stateEconomy = new Economy(initialStateFunds); playerEconomy = new Economy(initialPlayerFunds);. Или напишите классы StateEconomy/PlayerEconomy, если хотите переопределить Tick: stateEconomy.Tick начисляет, скажем, +1 каждый тик (или +10 каждую секунду как выше) [defer]
- Ref: docs/OPEN_QUESTIONS.md:84 — - Начисление дохода: В методе Tick у StateEconomy добавьте: incomeAccumulator += dt; if(incomeAccumulator >= 1) { incomeAccumulator -= 1; balance += incomePerSec; }. Так каждую игровую секунду (не зависимо от FPS) будет приходить фиксированная сумма. У игрока можно ничего не делать или аналогично (если есть, например, пассивный доход) [defer]

## Units/Combat
- Decision: Бой: простой HP и урон без резист/брони на первом этапе
- Decision: Единица — сущность Domain; визуал — отдельный View компонент
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:33 — - Unity Frame Debugger: На этом этапе рендеринг минимален, но вы можете открыть Frame Debugger и убедиться, что Tilemap отрисовывается оптимально (Tilemap можно оставить режим Chunk для минимизации draw calls, если уже есть несколько слоёв). Это скорее ознакомительно – что профилировщик и дебаггер кадров работают, и вы умеете их открывать [defer]
- Ref: docs/OPEN_QUESTIONS.md:38 — - Runtime-модель: для каждого ScriptableObject определите соответствующую чистую C# модель (можно struct или record). Например, для TechDef – класс или record Tech с аналогичными полями, но вместо ссылок на другие SO храните, например, списки ID или индексы (т.к. runtime-объекты будут связываться между собой иначе) [defer]
- Ref: docs/OPEN_QUESTIONS.md:39 — - Связи и идентификаторы: продумайте систему идентификаторов. Например, у каждой технологии TechDef.Id – уникальный строковый ID, то же для юнитов/зданий. Эти ID можно использовать как ключи при преобразовании в runtime-модели (например, список prerequisite-технологий хранить как список строк ID или enum, вместо прямых ссылок на SO, чтобы легко сериализовать) [defer]
- Ref: docs/OPEN_QUESTIONS.md:43 — - Состояние инфекции: можно хранить как двумерный массив или список значений заражения по каждой клетке. Например, infectionGrid – массив float или небольшой класс CellState (уровень заражения + статус S/I/R) [defer]
- Ref: docs/OPEN_QUESTIONS.md:49 — - Создание ScriptableObject: В Unity выберите Create → C# Script, назовите его, например, TechDef.cs. Наследуйте класс от ScriptableObject. Добавьте сверху, чтобы в меню Assets → Create появилось создание Tech. Опишите поля: строка Id, название, числовые параметры, ссылки на другие ScriptableObject (например, список prereq типа TechDef). Скомпилируйте, затем правой кнопкой в папке создайте пару таких ассетов и заполните поля в инспекторе [defer]
- Ref: docs/OPEN_QUESTIONS.md:50 — - Runtime-модель: В папке Scripts/Domain/ соответствующей создайте класс или struct Tech (лучше struct или record, т.к. данные иммутабельны). Дайте ему такие же поля (Id, cost, prerequisites), но в prerequisites храните список строк ID или других простых значений. Почему не держать ссылки на объекты? – чтобы этот класс был “чистым” и не включал UnityEngine.ScriptableObject (что затруднит сериализацию) [defer]
- Ref: docs/OPEN_QUESTIONS.md:72 — - Создайте класс Economy реализующий IEconomy. В конструкторе или инициализации задавайте стартовый баланс. Реализуйте хранилища: например, храните balance и reserved суммы. На упрощённом этапе можно при TryReserve просто уменьшать balance сразу (имитируя мгновенное резервирование), а Commit не менять баланс (т.к. уже вычтено). Либо не уменьшать при резерве, а уменьшить при Commit – но тогда надо хранить сколько зарезервировано. Выберите подход и задокументируйте его, главное – после Commit общий баланс должен уменьшиться на сумму, а если TryReserve не был выполнен – баланс не меняется [defer]
- Ref: docs/OPEN_QUESTIONS.md:78 — - Тест: после TryReserve (успешного) баланс не должен уменьшиться (если вы выбрали так) или уменьшился ровно на сумму (если списываете сразу) – зависит от вашей логики. Главное – после соответствующего Commit суммарное снижение равно сумме транзакции. Например: старт 100, TryReserve(30) -> balance либо 70 (если сразу списали), либо 100 (если пока держите на резервах), затем Commit(30) -> баланс 70 (во втором случае). В любом случае, деньги не должны исчезать или создаваться из ниоткуда – сумма списанная должна равняться сумме транзакции [defer]
- Ref: docs/OPEN_QUESTIONS.md:82 — - Реализуйте один из вариантов. Прокомментируйте в коде, как оно работает [defer]
- Ref: docs/OPEN_QUESTIONS.md:87 — - Тест MultipleReservesAndCommits: например, TryReserve(50) x2. Если вы списываете сразу, то первый вернёт true и баланс 50, второй – true и баланс 0 (если позволили ровно занулить). Если не списываете, можно имитировать контракт: TryReserve(50) -> true, TryReserve(60) -> false (потому что зарезервировано уже 50 и больше нельзя) [defer]
- Ref: docs/OPEN_QUESTIONS.md:95 — - Генерация тестов: Очень полезно – попросите: «Придумай несколько unit-тестов для класса Economy, который умеет резервировать и списывать баланс». AI поможет сформулировать проверки инвариантов. Используйте это как шаблон, заменив на синтаксис NUnit (Assert.AreEqual и пр.) [defer]
- Ref: docs/OPEN_QUESTIONS.md:99 — - Unit-тесты: Убедитесь, что все разработанные тесты зелёные. Это формальный критерий, что базовая логика корректна. Попробуйте и негативные сценарии: искусственно вызвать Commit без TryReserve – ожидаете ли вы исключение или ничего? Если ничего – тоже хорошо, убедитесь, что так и есть [defer]

## Save/Load
- Decision: Формат сохранений — JSON (System.Text.Json)
- Decision: Один корневой SaveDto + версия для миграций
- Decision: Экономику сохранять в спринте 1; юниты/постройки/исследования — в спринте 2
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:40 — - Простой вариант: поместите ассеты в Resources папку и вызывайте Resources.LoadAll<T>() для каждого типа (например, всех TechDef) [defer]
- Ref: docs/OPEN_QUESTIONS.md:42 — - Глобальное хранилище состояния. Спроектируйте класс GameState или несколько классов, описывающих текущее состояние игры, которое нужно будет сохранять: [defer]
- Ref: docs/OPEN_QUESTIONS.md:45 — - Реализация сохранения и загрузки. Добавьте в проект скрипт SaveLoadService (или методы в существующем менеджере), реализующие: [defer]
- Ref: docs/OPEN_QUESTIONS.md:54 — - infectionGrid (возможно, сериализуем как массив float или int статусов; большие двумерные массивы JsonUtility тоже умеет), [defer]
- Ref: docs/OPEN_QUESTIONS.md:59 — - Сбор загрузки: Если не уверены, как программно загрузить ассеты, спросите: «Как загрузить все ScriptableObject определённого типа в Unity?». Codex может подсказать про Resources.LoadAll или адресаблы [defer]
- Ref: docs/OPEN_QUESTIONS.md:60 — - Поиск ошибок сериализации: Если при сохранении что-то не сохраняется, вы можете показать Codex JSON вывод и код GameState, спросив: «Почему поле X не появляется в JSON?». Часто он подскажет, что, к примеру, свойство не сериализуется (сериализуются только поля) или тип не поддерживается [defer]
- Ref: docs/OPEN_QUESTIONS.md:63 — - Нажмите кнопку Save (или вызовите метод через консоль/дебаг) [defer]
- Ref: docs/OPEN_QUESTIONS.md:64 — - Сбросьте состояние – например, перезапустите сцену или вызовите метод Load сразу после Save (имитируя загрузку) [defer]
- Ref: docs/OPEN_QUESTIONS.md:65 — - Сравните: совпадают ли ключевые показатели? Число заражённых клеток, значения балансов и т.п. должны быть такими же, как в момент сохранения [defer]
- Ref: docs/OPEN_QUESTIONS.md:107 — - Инициализация инфекции. Добавьте в начало игры (например, в GameDataLoader или отдельном InfectionSystem.Start) логику заполнения сетки: [defer]
- Ref: docs/OPEN_QUESTIONS.md:115 — - После полного прохода замените grid = newGrid (предварительно можно старую сетку сохранить или копировать, если нужно сравнивать) [defer]
- Ref: docs/OPEN_QUESTIONS.md:149 — - Jobs/ECS на будущее: Codex можно спросить: «Как перенести обновление 2D grid в Unity Job System?». Он может дать пример использования IJobParallelFor по массиву – сохраните эту идею для модуля 8 [defer]

## AI/Path
- Decision: Путь: grid-based A* на 2D тайлкарте; 4-соседей; одна сущность на клетку
- Decision: Интерфейс IGridPathfinder — в спринте 2; реализацию можно отложить
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:211 — - «How to normalize values for Utility AI scoring?» might yield formulas or best practices (like using logistic curves, etc.). For now, linear clamp is fine [defer]
- Ref: docs/OPEN_QUESTIONS.md:215 — - Освоить использование Codex для анализа сложного алгоритма: можно просить объяснить код A*, помочь оптимизировать его или найти ошибку (например, если путь странно прокладывается) [defer]
- Ref: docs/OPEN_QUESTIONS.md:225 — - Восстановление пути: когда достигли цели, пройдите от целевого Node по parent-ссылкам до стартового, собирая координаты. Затем инвертируйте список или добавляйте в обратном порядке – это и будет путь от старта к цели [defer]
- Ref: docs/OPEN_QUESTIONS.md:232 — - Проходимость заражения: если вы делали заражённые клетки проходимыми, можно вручную сравнить путь, проходящий через заражённую зону vs обход. Если желаете, попробуйте задать “стоимость” заражённой клетки выше: например, добавляйте +20 к gCost при входе в инфицированную клетку. Тогда A* будет обходить заражение, если путь сильно удлиняется – полезно для AI, чтобы они обходили опасные зоны. Протестируйте: цель внутри заражённой области – алгоритм пойдёт напрямую (придётся зайти в “красную” зону, иначе не достигнуть), а если цель за заражённой зоной, может обходить вокруг [defer]
- Ref: docs/OPEN_QUESTIONS.md:237 — - Отмечайте, если цель или окружение изменились в процессе (например, путь стал недействительным из-за нового препятствия) – тогда проложите путь заново [defer]
- Ref: docs/OPEN_QUESTIONS.md:240 — - Финальный путь – отрисуйте и проверьте, что он действительно самый короткий (можно прикинуть глазом или сравнить с альтернативными маршрутами) [defer]
- Ref: docs/OPEN_QUESTIONS.md:249 — - «Почему алгоритм A не находит путь, хотя должен»* – предоставьте свой код, AI может найти упущенное условие или баг [defer]
- Ref: docs/OPEN_QUESTIONS.md:284 — - Расчёты AI: Если у вас сложный Utility или планер, убедитесь, что он не срабатывает слишком часто: [defer]
- Ref: docs/OPEN_QUESTIONS.md:296 — - «Какие ещё способы оптимизации RTS?» – AI может упомянуть, например, fixed-point math вместо float (редко нужно), или специализированные структуры. Это даст идеи на будущее [defer]
- Ref: docs/OPEN_QUESTIONS.md:298 — - AI-друг поможет и с Addressables: «Как выгрузить Addressable после использования?» – подскажет про Addressables.Release и тонкости [defer]
- Ref: docs/OPEN_QUESTIONS.md:303 — - Контекст и файлы: Используйте возможность давать контекст. Например, расширение CodeGPT поддерживает упоминание файла или выделенного кода. Вы можете выделить фрагмент кода и вызвать команду Ask CodeGPT – AI увидит только этот фрагмент. Или в чате написать @MyClass.cs – тогда ассистент учтёт содержимое файла MyClass.cs. Это очень полезно, когда вопрос касается конкретного кода – не нужно копировать вручную [defer]

## Assets
- Decision: Addressables отложить; пока прямые ссылки/Resources
- Status: accepted

- Ref: docs/OPEN_QUESTIONS.md:283 — - Проверьте Memory Profiler (есть отдельный пакет) или хотя бы профайлер вкладку Memory: посмотрите, нет ли всплеска памяти после, например, сцены загрузки/выгрузки. Addressables часто ловят на том, что загрузили, а Release забыли – тогда на каждый повтор загрузка дублируется в памяти [defer]


## Research (current iteration)
- Decision: Minimal research loop — states (Locked/Queued/Done) stored in ResearchStore; data in ResearchConfig (id, cost). Effects are placeholders for later.
- Status: accepted (in-progress)

## Pathfinding (Planning)
- Grid
  - 2D grid aligned to world; initial cell size: 1 unit (configurable via settings later).
  - World → grid: floor(x/size), floor(y/size); origin at (0,0) for now.
- Neighbors
  - Start with 4-connected (no diagonals) to avoid corner cutting; consider 8-connected later (with corner checks).
- Costs
  - Base move cost = 1 per cell; terrain weights (later): cost = base * weight; blocked = impassable.
- Heuristic
  - Manhattan (|dx|+|dy|) for 4-connected; if add diagonals, switch to Octile.
- API
  - Keep IGridPathfinder interface; implement A* service in Infrastructure; UnitView/AI request paths (Presentation controls movement).
- Dynamics
  - Cache static grid; mark dirty cells for dynamic obstacles; recompute local regions when needed.
- Performance
  - Small maps: single-thread A* is fine; later — partition grid, pool nodes, consider Jobs/Burst if needed.
- DoD
  - Decisions documented; interface in place; pathfinder impl tracked as a separate task (not required in this sprint).
