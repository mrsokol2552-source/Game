# Open Questions

Пункты, требующие решения/выбора. Перенесено из Unified Plan.

## A) Свой `SimulationLoop` (accumulator + fixed tick)
- Решить: 6) Профилирование: `Window → Analysis → Profiler` (Ctrl+7) и треки `Scripts`/`UI`. Смотри консистентное время тика, нет ли всплесков по GC. citeturn0search12  [chosen]

## 6) Возведение фортификаций юнитами (MUST)
- Решить: - **Линейное строительство** (траншеи по полилинии)  [chosen]

## 13) Баланс и контроль (SHOULD)
- Решить: - «Мобилизация»: X% CivGrowth → войска; проверка узких мест по еде/материалам [defer]

## Модуль 1: Базовый цикл симуляции и управление временем
- Решить: - Вычитайте из аккумулятора величину tick и затем вызывайте обновление всех систем игры в определённом порядке. Пока системы (экономика, инфекция, ИИ и др.) не реализованы, можете временно вызывать заглушки или логировать вызов тикov для каждой подсистемы. Позже, по мере прохождения модулей, сюда будут добавляться реальные вызовы: InfectionSystem.Tick(tick), EconomySystem.Tick(tick) и т.д.. Сейчас достаточно вывести в лог, например, "Tick X processed", где X – номер тика  [chosen]
- Решить: - Реализуйте возможность паузы: флаг IsPaused. В начале Update() проверяйте: если игра на паузе, не накапливайте время и сразу возвращайтесь (пропуская логику тика). В интерфейсе IClock сделайте Delta = IsPaused ? 0 : tick для удобства (или просто используйте флаг)  [chosen]
- Решить: - Добавьте метод SetPaused(bool) для изменения состояния паузы. Его будем вызывать из UI или горячей клавиши  [chosen]
- Решить: - Скорости ×0.5, ×1, ×2, ×4: Введите множитель времени (например, timeMultiplier), который будет влиять на скорость симуляции. Можно просто делить/умножать значение tick или накапливаемое время. Например, для ускорения ×2 уменьшайте tick вдвое (или увеличивайте accumulator в 2 раза быстрее). Учтите, что UI и анимации должны продолжать работать с нормальной скоростью (они и так на unscaled время, так что изменение нашего tick не затронет UI)  [chosen]
- Решить: - Одиночный тик (Step): Реализуйте отдельную функцию или кнопку, по нажатию которой симуляция выполняет ровно один тик и снова останавливается. Для этого можно: если игра на паузе, принудительно вызвать один цикл while(acc >= tick) либо вызвать методы Tick() всех систем один раз вручную. Сделайте проверку (Assert), что при одном нажатии выполняется не более одного тика  [chosen]
- Решить: - Добавьте UI-контролы или горячие клавиши для управления скоростью и паузой. Например, кнопки «Пауза/Продолжить», «Шаг», а также переключатели скорости. Эти элементы можно разместить в простом Overlay-меню для разработчика  [chosen]
- Решить: - Счётчик тиков: Добавьте на экран простой текстовый индикатор (например, в углу UI) или Debug.Log вывод, который увеличивается каждый раз, когда происходит тик. Это поможет отследить, что тики идут регулярно и не пропускаются. Можно хранить счётчик tickCount в SimulationLoop и обновлять его в цикле  [chosen]
- Решить: - Профилирование производительности цикла (базовое измерение): [defer]
- Решить: - Удостоверьтесь, что GC не генерируется каждый тик из-за ваших операций. Например, если логируете каждую итерацию while, это может создавать сборки мусора из-за конкатенации строк. В продакшн-коде постоянный лог внутри цикла следует отключить или обернуть условием if (Debug.isDebugBuild)  [chosen]
- Решить: - Индикатор тиков: Проверьте, что UI-индикатор или лог счётчика тиков увеличивается равномерно и без пропусков. Если при паузе он останавливается, а при изменении скорости – меняет темп, всё правильно  [chosen]
- Решить: - Одиночный шаг: Нажатие кнопки «Step» должно приводить к выполнению ровно одного цикла while(acc>=tick). После шага цикл не должен сразу продолжаться, иначе это признак, что неправильно контролируется пауза или accumulator. Проверьте через Assert, что за один вызов Step производится не более 1 тика  [chosen]
- Решить: - Стабильность при разных FPS: Сравните поведение тиков при 30 FPS и при 200 FPS (можно ограничить FPS через QualitySettings или vsync). Число тиков в секунду и общее развитие симуляции должно быть одинаковым. Это ключевое свойство фиксированного цикла – независимость от частоты кадров  [chosen]
- Решить: - Типичные ошибки: Если замечаете, что тики «плавают» или идут быстрее/медленнее заявленного – проверьте сброс аккумулятора в цикле while. Нередко ошибка – не полностью вычитать tick из acc, что приводит к ускорению или замедлению цикла. Другой частый баг – забыть вызвать EventBus.Flush() в конце тика (пока EventBus не работает, это не влияет, но позже будет критично). Также убедитесь, что симуляционное время отделено от времени UI: не используйте Time.deltaTime там, где нужен unscaledDeltaTime  [chosen]
- Решить: - Исправление ошибок: Если цикл работает не так, как ожидалось (например, ticks пропускаются или идут неритмично), скопируйте свой код и запросите: «Найди ошибку в логике фиксированного цикла». Расширение Codex может подсветить проблемные места (например, неправильный сброс acc или использование deltaTime вместо unscaledDeltaTime)  [chosen]
- Решить: - Пояснение кода: Если какие-то конструкции непонятны (например, Time.unscaledDeltaTime или работа while цикла), можно спросить: «Объясни, как работает этот код строчка за строчкой». Это поможет глубже понять шаблон фиксированного тика  [chosen]
- Решить: - Создание UI через Codex: Не уверены, как добавить UI-кнопки или текстовый индикатор? Спросите: «Как в Unity через код создать на экране текст для отображения счётчика тиков?». Codex может подсказать использование Canvas и TextMeshPro, либо изменение текста через скрипт  [chosen]
- Решить: - Сниппеты для проверки: Также Codex поможет со скриптами отладки – например, команду для печати текущего Application.targetFrameRate или для переключения VSync через скрипт, что пригодится при тестировании [defer]
- Решить: - Тест с переменным FPS: Включите Stats в Game View (показывает текущий FPS). Изменяйте нагрузку (например, сожмите окно игры для увеличения FPS или включите интенсивную графику для просадки FPS) и наблюдайте за счётчиком тиков. Он должен быть стабильным. Например, если на высокой нагрузке FPS упал до 30, тики всё равно должны идти 10 раз/сек, просто по несколько за кадр. Если при просадке FPS игра «замедляется», значит, цикл не успевает нагнать – нужно проверить логику accumulator  [chosen]
- Решить: - Unity Frame Debugger: На этом этапе рендеринг минимален, но вы можете открыть Frame Debugger и убедиться, что Tilemap отрисовывается оптимально (Tilemap можно оставить режим Chunk для минимизации draw calls, если уже есть несколько слоёв). Это скорее ознакомительно – что профилировщик и дебаггер кадров работают, и вы умеете их открывать  [chosen]
- Решить: - Перед переходом дальше: Добейтесь, чтобы механизм времени работал полностью предсказуемо. Критерии готовности: пауза без багов, изменение скорости влияет только на симуляцию, в профайлере нет бесконтрольного роста нагрузки или утечек, а вы уверены в том, как устроен ваш цикл. Только после этого переходите к введению игровых данных и систем  [chosen]

## Модуль 2: Данные и конфигурации (ScriptableObject → Runtime-модели)
- Решить: - Для каждого типа данных создайте класс ScriptableObject. Например, InfectionParams (ScriptableObject) с полями для коэффициентов модели заражения, или BuildingDef с полями стоимости строительства, радиуса действия и пр. В документе архитектуры есть пример TechDef – ScriptableObject для технологии  [chosen]
- Решить: - Runtime-модель: для каждого ScriptableObject определите соответствующую чистую C# модель (можно struct или record). Например, для TechDef – класс или record Tech с аналогичными полями, но вместо ссылок на другие SO храните, например, списки ID или индексы (т.к. runtime-объекты будут связываться между собой иначе)  [chosen]
- Решить: - Связи и идентификаторы: продумайте систему идентификаторов. Например, у каждой технологии TechDef.Id – уникальный строковый ID, то же для юнитов/зданий. Эти ID можно использовать как ключи при преобразовании в runtime-модели (например, список prerequisite-технологий хранить как список строк ID или enum, вместо прямых ссылок на SO, чтобы легко сериализовать)  [chosen]
- Решить: - Простой вариант: поместите ассеты в Resources папку и вызывайте Resources.LoadAll<T>() для каждого типа (например, всех TechDef)  [chosen]
- Решить: - Сохраняйте их в удобной структуре, например, словарь Dictionary<string, Tech> для технологий по ID, чтобы потом быстро получать по идентификатору. Учтите: словари нельзя напрямую сериализовать через JsonUtility, но для быстрого доступа в памяти они удобны. Позже при сохранении нужно будет перенести их в список или другой формат  [chosen]
- Решить: - Глобальное хранилище состояния. Спроектируйте класс GameState или несколько классов, описывающих текущее состояние игры, которое нужно будет сохранять:  [chosen]
- Решить: - Состояние инфекции: можно хранить как двумерный массив или список значений заражения по каждой клетке. Например, infectionGrid – массив float или небольшой класс CellState (уровень заражения + статус S/I/R)  [chosen]
- Решить: - Сделайте GameState , чтобы JsonUtility могла его сериализовать. Если в нём есть сложные поля (например, Dictionary), замените или пометьте их как и заполняйте через вспомогательные списки. Важно: JsonUtility не поддерживает Dictionary и полиморфные типы без специальных атрибутов. Поэтому убедитесь, что все поля GameState – либо примитивы/структуры, либо списки/массивы таких примитивов/структур  [chosen]
- Решить: - Реализация сохранения и загрузки. Добавьте в проект скрипт SaveLoadService (или методы в существующем менеджере), реализующие:  [chosen]
- Решить: - Сохранение: сбор текущего состояния игры в экземпляр GameState и сериализация его в JSON. Используйте JsonUtility.ToJson(gameState). Полученную строку можно сохранить в файл (например, в Application.persistentDataPath) или просто в PlayerPrefs для простоты  [chosen]
- Решить: - Безопасная точка сохранения: Решите, как игрок инициирует сохранение. Хороший подход – сохранять только когда игра остановлена или на паузе, чтобы не захватить промежуточное состояние. Либо дождаться конца тика (после EventBus.Flush()) и затем снять снимок состояния. Сейчас, для упрощения, можно сохранять по кнопке, которая ставит игру на паузу и вызывает Save  [chosen]
- Решить: - Добавьте счётчики или логи сколько ассетов загружено/выгружено, используя events или отладочный UI, чтобы убедиться, что нет избыточно висящих в памяти объектов  [chosen]
- Решить: - Создание ScriptableObject: В Unity выберите Create → C# Script, назовите его, например, TechDef.cs. Наследуйте класс от ScriptableObject. Добавьте сверху, чтобы в меню Assets → Create появилось создание Tech. Опишите поля: строка Id, название, числовые параметры, ссылки на другие ScriptableObject (например, список prereq типа TechDef). Скомпилируйте, затем правой кнопкой в папке создайте пару таких ассетов и заполните поля в инспекторе  [chosen]
- Решить: - Runtime-модель: В папке Scripts/Domain/ соответствующей создайте класс или struct Tech (лучше struct или record, т.к. данные иммутабельны). Дайте ему такие же поля (Id, cost, prerequisites), но в prerequisites храните список строк ID или других простых значений. Почему не держать ссылки на объекты? – чтобы этот класс был “чистым” и не включал UnityEngine.ScriptableObject (что затруднит сериализацию)  [chosen]
- Решить: - Загрузка данных: Создайте скрипт GameDataLoader (MonoBehaviour на отдельном объекте менеджере или внутри SimulationLoop). В его Awake или Start получите списки ассетов. Если используете Resources, то: TechDef techs = Resources.LoadAll<TechDef>(""); (путь можно уточнить). Далее инициализируйте, например, Dictionary<string, Tech> techMap = new(); и цикл: foreach(var techDef in techs) { techMap = new Tech(techDef.Id, techDef.ResearchCost, techDef.Prereq.Select(t => t.Id).ToList()); }. Аналогично для других типов (Buildings, InfectionParams и т.п.). Теперь ваши системы могут обращаться к этим структурам для получения параметров  [chosen]
- Решить: - Использование данных в системах: Подумайте, как передать эти конфиги туда, где они нужны. Например, InfectionSystem может хранить ссылку на загруженный InfectionParams runtime-объект, EconomySystem – на настройки экономики (если такие есть). Можно сделать так, что GameDataLoader после загрузки устанавливает нужные поля в синглтонах систем или через событие сообщает о готовности данных  [chosen]
- Решить: - tickCount или текущее время симуляции,  [chosen]
- Решить: - infectionGrid (возможно, сериализуем как массив float или int статусов; большие двумерные массивы JsonUtility тоже умеет),  [chosen]
- Решить: - возможно, список построек или технологий (если к тому времени появятся, иначе пропустите)  [chosen]
- Решить: - JsonUtility ограничения: Попробуйте прямо сейчас выполнить JsonUtility.ToJson(someScriptableObject) – убедитесь, что, например, поля-словарики там не сохраняются. Если ваши runtime-модели содержат несериализуемые поля, подумайте, как их исключить или преобразовать. Например, Dictionary заменить на список пар ключ-значение при сохранении/загрузке. Лучше выявить и решить эти моменты заранее, написав простые тесты на сериализацию  [chosen]
- Решить: - Частые проблемы: забыли пометить класс – тогда JsonUtility выдаст пустой JSON. Или, например, попытались сериализовать что-то вроде Dictionary – JSON выйдет пустой. Лечится заменой структур. Другая ошибка – сериализация больших структур (сетка 1000x1000) может быть медленной или громоздкой; но пока игра маленькая, это приемлемо  [chosen]
- Решить: - Адресация ассетов: Если применили Addressables, включите режим PlayMode (Use Existing Build или Simulate) и отследите, что после сцены, где вы загрузили ассеты, при выходе или переходе они выгружаются. Логи или профайлер памяти помогут заметить, не остались ли ассеты висеть (у Addressables есть профайл и EventViewer, но это за рамками базового плана)  [chosen]
- Решить: - Сбор загрузки: Если не уверены, как программно загрузить ассеты, спросите: «Как загрузить все ScriptableObject определённого типа в Unity?». Codex может подсказать про Resources.LoadAll или адресаблы  [chosen]
- Решить: - Поиск ошибок сериализации: Если при сохранении что-то не сохраняется, вы можете показать Codex JSON вывод и код GameState, спросив: «Почему поле X не появляется в JSON?». Часто он подскажет, что, к примеру, свойство не сериализуется (сериализуются только поля) или тип не поддерживается  [chosen]
- Решить: - Оптимизация данных: Codex способен объяснить и рекомендуемые практики. Например: «Почему Unity не сохраняет Dictionary в JSON и как это обойти?» – поможет понять и выбрать решение (конверсия или использование другой JSON библиотеки)  [chosen]
- Решить: - Проверка загрузки конфигов: Запустите сцену и в консоли проверьте логи: должно выводиться, сколько объектов загружено и какие ID у них. Сравните с вашими созданными ассетами – все ли считаны. Если чего-то не хватает, убедитесь, что ассеты находятся в Resources или привязаны к сцене/ScriptableObject-реестру [defer]
- Решить: - Нажмите кнопку Save (или вызовите метод через консоль/дебаг)  [chosen]
- Решить: - Сбросьте состояние – например, перезапустите сцену или вызовите метод Load сразу после Save (имитируя загрузку)  [chosen]
- Решить: - Сравните: совпадают ли ключевые показатели? Число заражённых клеток, значения балансов и т.п. должны быть такими же, как в момент сохранения  [chosen]

## Модуль 3: Экономическая система (двойное ВВП)
- Решить: - Понять принципы построения финансовой системы в игре: учёт ресурсов, транзакции, инварианты (сохранение баланса)  [chosen]
- Решить: - Освоить написание модульных тестов для бизнес-логики (проверка инвариантов, корректности резервирования) [defer]
- Решить: - Метод bool TryReserve(float amount): попытка зарезервировать сумму. Логика: если на счету достаточно средств, зарезервировать их под будущую операцию и вернуть true; иначе вернуть false. На этом этапе можно реализовать резервирование просто как проверку баланса (и, например, временное уменьшение баланса или отдельный счетчик резерва)  [chosen]
- Решить: - Метод void Tick(float dt): обновление экономики каждый тик. Пока можно оставить пустым или использовать для пассивного дохода/расхода  [chosen]
- Решить: - Создайте класс Economy реализующий IEconomy. В конструкторе или инициализации задавайте стартовый баланс. Реализуйте хранилища: например, храните balance и reserved суммы. На упрощённом этапе можно при TryReserve просто уменьшать balance сразу (имитируя мгновенное резервирование), а Commit не менять баланс (т.к. уже вычтено). Либо не уменьшать при резерве, а уменьшить при Commit – но тогда надо хранить сколько зарезервировано. Выберите подход и задокументируйте его, главное – после Commit общий баланс должен уменьшиться на сумму, а если TryReserve не был выполнен – баланс не меняется  [chosen]
- Решить: - Две реализации или два экземпляра. Решите, как отличить экономику государства и игрока:  [chosen]
- Решить: - Создайте в игре два объекта/сервиса: stateEconomy и playerEconomy. Их начальные балансы можно задать в конфиге (например, ScriptableObject с начальными финансами) или в коде (какими-нибудь значениями для теста)  [chosen]
- Решить: - Убедитесь, что эти объекты доступны остальным системам: например, BuildService (будет позже) сможет получить ссылку на тот IEconomy, который оплачивает строительство (игрок или государство)  [chosen]
- Решить: - Если будут сложные кейсы (например, штрафы или возвраты), тоже логируйте [defer]
- Решить: - Unit-тесты инвариантов. Напишите тесты, чтобы убедиться в корректности работы экономики:  [chosen]
- Решить: - Тест: после TryReserve (успешного) баланс не должен уменьшиться (если вы выбрали так) или уменьшился ровно на сумму (если списываете сразу) – зависит от вашей логики. Главное – после соответствующего Commit суммарное снижение равно сумме транзакции. Например: старт 100, TryReserve(30) -> balance либо 70 (если сразу списали), либо 100 (если пока держите на резервах), затем Commit(30) -> баланс 70 (во втором случае). В любом случае, деньги не должны исчезать или создаваться из ниоткуда – сумма списанная должна равняться сумме транзакции  [chosen]
- Решить: - Создание IEconomy: В папке Scripts/Domain/Economy создайте интерфейс IEconomy и опишите сигнатуры методов. Затем в Scripts/Application или где уместно – класс Economy : IEconomy  [chosen]
- Решить: - Вариант A (простой): при TryReserve(amount) сразу уменьшать balance на amount, если хватает, и возвращать true; если не хватает – возвращать false, ничего не меняя. А Commit(amount) в таком случае может вообще ничего не делать (или просто для симметрии, хотя можно оставить пустым). Этот вариант проще, но терминология "Reserve/Commit" теряет смысл – вы сразу тратите деньги на этапе резерва. Однако для начала так можно [defer]
- Решить: - Вариант B (двухфазный): TryReserve только проверяет и, допустим, добавляет в некоторую переменную reserved += amount (или ставит флаг, что столько-то зарезервировано), но не списывает. Commit уже уменьшает balance на фактически зарезервированную сумму. Тут надо быть осторожным: а если за время между TryReserve и Commit баланс изменился? Но в однопоточной игре между ними обычно ничего не вставляется, кроме, возможно, другого TryReserve. Можно не углубляться: предположим, что TryReserve и Commit вызываются подряд без других операций [defer]
- Решить: - Реализуйте один из вариантов. Прокомментируйте в коде, как оно работает  [chosen]
- Решить: - Например, в GameDataLoader после загрузки конфигов: stateEconomy = new Economy(initialStateFunds); playerEconomy = new Economy(initialPlayerFunds);. Или напишите классы StateEconomy/PlayerEconomy, если хотите переопределить Tick: stateEconomy.Tick начисляет, скажем, +1 каждый тик (или +10 каждую секунду как выше)  [chosen]
- Решить: - Начисление дохода: В методе Tick у StateEconomy добавьте: incomeAccumulator += dt; if(incomeAccumulator >= 1) { incomeAccumulator -= 1; balance += incomePerSec; }. Так каждую игровую секунду (не зависимо от FPS) будет приходить фиксированная сумма. У игрока можно ничего не делать или аналогично (если есть, например, пассивный доход)  [chosen]
- Решить: - Юнит-тесты: В папке Assets/Tests (или через Window → General → Test Runner) создайте EditMode тесты. Например, EconomyTests:  [chosen]
- Решить: - Тест ReserveDoesNotChangeBalance (если вы выбрали вариант B): создайте экономику с балансом 100, вызовите TryReserve(30) – ожидайте, что возвращено true, а balance всё ещё 100 (если вы не списываете сразу). Commit(30) – после него balance 70. И второй кейс: если TryReserve(200) – должно вернуть false и balance остаться 100  [chosen]
- Решить: - Тест MultipleReservesAndCommits: например, TryReserve(50) x2. Если вы списываете сразу, то первый вернёт true и баланс 50, второй – true и баланс 0 (если позволили ровно занулить). Если не списываете, можно имитировать контракт: TryReserve(50) -> true, TryReserve(60) -> false (потому что зарезервировано уже 50 и больше нельзя)  [chosen]
- Решить: - Логирование: Внутри Economy добавьте Debug.LogWarning или Log для отказов. Чтобы в лог было понятно, какая экономика, добавьте либо разный префикс (например, сделать свойство Name или передавать в конструктор "Player" vs "State"). Лог на успехи можно делать через Log с уровнем Developer (например, Debug.Log(" -50 for building X"))  [chosen]
- Решить: - Связь с другими системами: Продумайте наперёд: экономика должна взаимодействовать с системой строительства (Module 5) и ИИ (Module 6). Это значит, что там будет вызываться if(playerEconomy.TryReserve(cost)) ... Commit(cost). Чтобы это сделать, те системы должны знать о playerEconomy. Вы можете внедрить зависимости, например, передать Economy ссылку в конструктор BuildService или сделать BuildService методом внутри Economy (нежелательно). Пока можно оставить глобальные ссылки или синглтон GameManager, откуда статически доступ к экономике  [chosen]
- Решить: - Стресс-тест баланса: Если у государства много дохода и много расходов, не возникает ли багов? Попробуйте резко увеличить доход (например, 100 ед./сек) и одновременно тратить 50/сек, посмотрите в профайлер – не проседает ли (экономика код лёгкий, но вдруг). Заодно убедитесь, что нигде не появляется бесконечного роста памяти  [chosen]
- Решить: - Накопление ошибок округления: если dt=0.1, за 10 тиков incomeAccumulator = 1.0, все ок. Но если dt не точно 0.1 (что может быть, если accumulator работает с флотами), за N тиков может накопиться чуть больше 1.0 и дать лишний доход. Это не критично, но осознайте: такая погрешность возможна. В финансовой системе иногда используют целые числа (копейки, центы) или Decimal. В игре можно закрыть глаза или периодически нормализовать accumulator  [chosen]
- Решить: - Несоответствие Reserve/Commit: например, вызвали TryReserve, получили true, но забыли вызвать Commit – деньги как бы висят. В простом варианте A это сразу списано, нет проблемы. В варианте B важно, чтобы в коде, где резервируете, всегда был парный Commit (например, в BuildService)  [chosen]
- Решить: - Data races нет (игра однопоточная), но логика может сталкиваться: например, одновременно ИИ и игрок пытаются резервировать гос-бюджет – этого у нас нет, т.к. бюджеты раздельные. Но вдруг решите сделать общий резерв – тогда нужны мьютексы или блокировки. В Unity MonoBehaviour контексте это редкость, но упомянуть полезно  [chosen]
- Решить: - Класс Economy: Запрос «Реализуй класс Economy, который реализует IEconomy с базовым функционалом (баланс, проверка средств)». Codex, вероятно, предложит простой вариант с if(balance >= amount) { balance -= amount; return true; } для TryReserve. Проанализируйте, подходит ли вам эта модель (это вариант A). Вы можете уточнить: «А как реализовать отдельно резервирование и списание?», чтобы получить идею для варианта B [defer]
- Решить: - Генерация тестов: Очень полезно – попросите: «Придумай несколько unit-тестов для класса Economy, который умеет резервировать и списывать баланс». AI поможет сформулировать проверки инвариантов. Используйте это как шаблон, заменив на синтаксис NUnit (Assert.AreEqual и пр.)  [chosen]
- Решить: - Советы по дизайну: Задайте помощнику вопрос: «Лучше сразу списывать деньги при TryReserve или при Commit? Какие плюсы-минусы?». Возможно, он объяснит про транзакционность. Полезно для принятия решения [defer]
- Решить: - Расширенные механики: Если вы решите реализовать займы или контракты, можно проконсультироваться у Codex: «Как реализовать систему займов с процентами для игровой экономики?» – он может накидати идею формул. Или «Как спланировать бюджет с категориями (оборона, исследования)?» – тоже выдаст идеи, как хранить и обновлять  [chosen]
- Решить: - Отладка: Если тесты не сходятся, скормите Codex свой метод TryReserve/Commit и тест, который падает, с вопросом: «Почему этот тест не проходит?». Помощник проанализирует код и вероятно поймёт (например, вычитание не там стоит или сравнение float) [defer]
- Решить: - Unit-тесты: Убедитесь, что все разработанные тесты зелёные. Это формальный критерий, что базовая логика корректна. Попробуйте и негативные сценарии: искусственно вызвать Commit без TryReserve – ожидаете ли вы исключение или ничего? Если ничего – тоже хорошо, убедитесь, что так и есть  [chosen]

## Модуль 4: Система инфекции (модель заражения на сетке)
- Решить: - Реализовать обновление сетки клеток по соседям (соседство Moore или Von Neumann) и понять разницу [defer]
- Решить: - Научиться визуализировать и логировать состояние поля для отладки (например, через Gizmos или цветовую карту) [defer]
- Решить: - Если карта не слишком велика (например, 100x100), удобно завести двумерный массив или Grid<CellState> [defer]
- Решить: - Создайте структуру CellInfection с полями: level (float от 0 до 1, степень заражённости) и state (тип InfectionState). В начале игры все клетки кроме, допустим, нескольких – Susceptible с level=0. Можно начальные очаги вручную задать или случайно [defer]
- Решить: - Выберите один подход (например, Moore для более “круглого” распространения, или Von Neumann для более “крестообразного”). Зафиксируйте это и используйте везде одинаково  [chosen]
- Решить: - Инициализация инфекции. Добавьте в начало игры (например, в GameDataLoader или отдельном InfectionSystem.Start) логику заполнения сетки:  [chosen]
- Решить: - Определите 1-3 начальных заражённых клетки для старта сценария. Можно хардкодом: центр карты, или случайно выбрать несколько координат. У этих клеток state = Infected, level = 1 (максимум) [defer]
- Решить: - Возможно, при наличии PopulatonDensity или Mobility (из расширений) – пока опустим, сконцентрируемся на базовой модели [defer]
- Решить: - Используйте двойной буфер: заведите второй массив или такой же размер CellInfection newGrid, чтобы вычислять новые значения на основе старых, не переписывая старый на лету. После завершения расчёта, замените старую сетку новым (или скопируйте результаты) [defer]
- Решить: - Она сама может продолжать быть заражённой; можно реализовать выздоровление: например, уменьшить её уровень на небольшую величину (иммунизация, если хочется SEIR эффект). Либо оставить как есть, решив, что выздоровление дольше чем один тик – можно не делать тут, а делать по таймеру или отдельной фазой  [chosen]
- Решить: - Рассмотрим всех соседей этой клетки (по выбранной схеме). Для каждого соседа, если он Susceptible, увеличиваем в newGrid его level на некоторую величину, зависящую от уровня текущей клетки и коэффициентов. Простой вариант: newLevel = oldNeighbor.level + infectRate * dt. InfectRate возьмите из InfectionParams (например, 0.2) [defer]
- Решить: - Если после увеличения newLevel >= 1 (или какой-то порог), то в newGrid помечаем соседа как Infected (state) и можно задать newLevel = 1 [defer]
- Решить: - Отдельно: можно вне цикла заразных соседей обработать выздоровление: для клеток Infected уменьшить уровень или, например, через какое-то время перевести в Recovered. Например, если клетка заражена X тиков, перевести её. Но для простоты: можете каждую заражённую понемногу снижать level, и если упадёт ниже 0.1 – перевести в Recovered  [chosen]
- Решить: - После полного прохода замените grid = newGrid (предварительно можно старую сетку сохранить или копировать, если нужно сравнивать)  [chosen]
- Решить: - Gizmos: В скрипте InfectionSystem (или отдельном MonoBehaviour) реализуйте OnDrawGizmos() или OnDrawGizmosSelected(). В ней проходите по grid и рисуйте, например, квадраты или точки: [defer]
- Решить: - UI-оверлей: Более сложный вариант – отрисовать текстуру или Tilemap с цветовой заливкой поверх игрового поля. Если хотите, можете динамически обновлять цвет тайлов в зависимости от уровня заражения (Tilemap позволяет менять цвет отдельного тайла). Либо отрисовывать примитивы (например, Spawn sprite с прозрачным красным кружком в заражённых клетках). Это по желанию – можно ограничиться Gizmos, т.к. они уже дают картину в редакторе  [chosen]
- Решить: - Поддерживайте список или набор координат, которые являются «активными» – где произошли изменения (например, недавно заражённые клетки, или клетки границы между заражёнными и здоровыми)  [chosen]
- Решить: - Также можно добавлять соседей, у которых уровень заметно изменился, даже если не заразились – но это тонкости. Минимум – новые заражённые и, возможно, клетки, которые стали здоровыми опять  [chosen]
- Решить: - Карантинные зоны: Позже, когда будет система строительства, можно предусмотреть, что определённые постройки (например, блокпосты) создают области, через которые заражение распространяется хуже или не распространяется вовсе. Реализовать это можно сейчас, если добавить в InfectionParams какой-нибудь коэффициент quarantineEffect, и в диффузии: если клетка сосед – карантинная (нужно знать, есть ли кордон на ней, а это значит, что система построек должна сообщать), то либо пропустить заражение, либо сильно ослабить (умножить на 0.1 например)  [chosen]
- Решить: - Очаги и фронт: Можно определить, что если уровень заражения клетки > 0.8, она считается “очагом”. Это чисто для статистики или для AI, но вы можете помечать такие клетки и, например, даже изменять стратегию распространения (например, очаги быстрее заражают вокруг)  [chosen]
- Решить: - Транспортные коридоры: если карта предусматривает дороги или порты – можно добавить, что некоторые клетки заражают дальние, не только соседей (например, вероятность переноса инфекции на большое расстояние). Но это уже усложнение, без которого модель тоже работает  [chosen]
- Решить: - Создание InfectionSystem: В Scripts/Application создайте класс InfectionSystem. Он может не быть MonoBehaviour (можно делать обычный класс, который управляется SimulationLoop), либо MonoBehaviour без Update (раз вызывается вручную). В нём: поля ширины/высоты (можете взять из Tilemap size или зашить), двумерный массив CellInfection grid  [chosen]
- Решить: - Инициализация: В конструкторе или при первом вызове Tick проверьте, если grid не создан, то создайте массив нужного размера и заполните Susceptible. Можно вынести в отдельный метод Initialize(width, height) и вызвать из GameManager при старте  [chosen]
- Решить: - Начальные очаги: Например, grid.state = Infected; grid.level = 1; frontierCells.Add((50,50)). Добавьте 2-3 таких для проверки, или сделайте функцию для заражения клетки (чтобы можно было и потом заражать искусственно) [defer]
- Решить: - Создайте временный массив nextGrid того же размера. Лайфхак: можно копировать ссылки или MemberwiseClone, но проще пройтись по всем клеткам и скопировать. Либо изначально nextGrid = deep copy of grid, а потом изменять. В целях читаемости, сделайте двойной цикл: for x, for y – скопируйте значения. Затем ещё раз цикл – применяйте правила. (Или объедините, как удобнее, но следите, чтобы вы не перезаписывали, пока используете)  [chosen]
- Решить: - Обход соседей: пропишите 4 или 8 проверок, или заведите массив neighbors = new int2{(1,0),(-1,0),(0,1),(0,-1), ...} и итерируйтесь по нему. Первый вариант явно длиннее код, второй – чище [defer]
- Решить: - Если используете frontierCells: тогда внешний цикл будет foreach(var (x,y) in frontierCells) и плюс возьмёте всех их соседей тоже. Но аккуратно: если у вас только заражённые клетки в фронтире, то соседи могут стать заражёнными – они войдут в nextFrontier. А что если заражённая клетка остаётся заражённой? Её тоже надо держать во фронте пока она имеет здоровых соседей. Так что, вероятно, и текущие заражённые тоже надо оставлять, пока вокруг них есть Susceptible  [chosen]
- Решить: - Recovery: Добавьте простое правило: если клетка Infected, уменьшаем её level на, скажем, recoveryRate * dt (например, 0.1 * dt). Если level упало <= 0, или вы можете считать, что после 10 секунд заражения она переходит в Recovered. То есть, у вас может быть счётчик времени заражения. Но можно и проще: фиксированный шанс выздоровления. Чтобы сильно не усложнять – можете вообще не делать recovery, или сделать по таймеру: например, в CellInfection добавить поле infectionTime, в каждую Tick для Infected увеличивать его, и если > threshold, state = Recovered  [chosen]
- Решить: - Решите: Recovered клетки будут иметь level = 0? Или оставлять уровень как был? Наверное, лучше обнулить, или хранить, что они переболели (может влиять на AI)  [chosen]
- Решить: - Межсистемная интеграция: Пока у нас нет эффекта экономики или построек на инфекцию, но имейте в виду: построенные игроком укрепления должны снижать распространение, требуя взаимодействия. Когда будет EventBus/BuildService, сделаем: при постройке, InfectionSystem узнает, что на клетке появился объект (например, фортификация), и меняет локально параметры (может, state = Recovered? или особый статус, или cell.protectionFactor)  [chosen]
- Решить: - Проверка модели SIR: Убедитесь, что базовая «физика» SIR соблюдается. То есть если вы настроили параметры (например, infectionRate, recoveryRate), попробуйте в небольшом примере на бумаге или в таблице прикинуть, как S->I->R должно происходить. Запустите симуляцию на маленькой сетке 3x3 и проследите, как одна заражённая клетка заражает соседей. Если уровень накапливается плавно, все хорошо. Если сразу все стали заражены – значит infectionRate слишком высок или threshold низкий  [chosen]
- Решить: - Соседство: Очень важно, чтобы вы реализовали соседей точно и не упустили никого. Проведите тест: выберите одну заражённую клетку, логируйте список её соседей координат. Сравните с тем, что вы ожидаете (например, у угловой клетки на краю должно быть 3 соседа в Moore, или 2 в Von Neumann). Вы можете для уверенности ручной тест сделать: например, функция, которая возвращает список соседей, и unit-тест, что для центра возвращает 8 (в Moore) уникальных, а для угла – 3  [chosen]
- Решить: - Двойной буфер: Проведите мысленный эксперимент или даже тест: если нет двойного буфера, то если вы обновляете сетку на лету, одна заражённая клетка может заразить соседа, а потом этот сосед в этом же тик заразит других – эффект «волны за один тик», чего быть не должно. С double buffer этого не случается – инфекция распространяется максимум на 1 клетку за тик, как задумано. Убедитесь, что вы правильно меняете newGrid, а старый читаете. Чтобы проверить:  [chosen]
- Решить: - Frontier: Если реализовали обновление по фронту, сравните с наивным полным обновлением на каком-то шаге. Например, отключите frontier и запустите 50 тиков, сохраните состояние. Затем откатитесь, включите frontier-логику, запустите те же 50 тиков – состояния должны совпасть (проверить на паре клеток, или глобально подсчитать, например, общую зараженность). Если равны – оптимизация корректна  [chosen]
- Решить: - Отладка времени шага: Вывели время выполнения InfectionSystem.Tick (через Time или Stopwatch)? На маленьких размерах будет миллисекунды или меньше, но на больших (>100k клеток) может быть уже ощутимо. Не стремитесь к нулю пока, но держите в уме  [chosen]
- Решить: - Спустя какое-то время образуется «пятно» заражения, распространяющееся плавно. Если видите скачки (например, внезапно дальняя клетка стала зараженной без цепочки) – вероятно, баг с индексами или не учли dt [defer]
- Решить: - Логирование прогресса: Выводите периодически (например, раз в секунду или раз в 10 тиков) процент заражённых клеток или количество текущих Infected. Это поможет убедиться, что модель не взорвалась или не заглохла. В SIR-модели обычно график: сначала экспоненциальный рост, потом насыщение и спад. Ваша игра – не обязательно реальная эпидемия, но похожие тренды могут быть  [chosen]
- Решить: - Неправильное вычисление соседних индексов (например, перепутали X и Y, или сделали neighbors массив неправильно). Это сразу видно по рисунку распространения – он будет искажён [defer]
- Решить: - Не забыли ли обрабатывать Recovered? Иначе у вас никогда не убывает инфекция. Если recoveryRate=0, то Infected будут инфицировать вечно. Это ок, если игра про постоянную борьбу. Но если хотите реализовать спад, то нужно  [chosen]
- Решить: - GC: Если каждый тик вы создаёте новый массив 100x100, это 10k objects GC может мусорить (на 60 FPS * 10000 = 600k alloc/sec – не супер страшно, но лучше избегать). Можно сделать массив полем и переиспользовать, или, лучше, перейти на NativeArray (будет в оптимизации). На данном этапе, можно смириться, а оптимизировать в модуле 8  [chosen]
- Решить: - Генерация кода распространения: Попробуйте запрос: «Алгоритм распространения инфекции на сетке 2D (Moore соседи) на C#». Codex может выдать псевдокод или даже близкий вариант. Используйте его идеи, но убедитесь, что код не содержит типичных ошибок (например, не обновляет сетку сразу)  [chosen]
- Решить: - Двойной буфер: Спросите: «Почему нужен double-buffer при обновлении клеточного автомата?». Помощник объяснит и вы сможете убедиться, что делаете правильно [defer]
- Решить: - Работа с массивами: Если вам сложно с синтаксисом двумерных массивов или списков, Codex подскажет. «Как объявить двумерный массив 100x100 в C# и обойти его в цикле?» – это базово, но AI может быстро сгенерировать шаблон фор-циклов  [chosen]
- Решить: - Gizmos пример: Можно спросить: «Как через OnDrawGizmos нарисовать цветные кубики на каждой ячейке tilemap?». Codex, вероятно, выдаст пример использования Gizmos.DrawCube [defer]
- Решить: - Оптимизация frontier: Сформулируйте: «Как оптимизировать обновление клеточной автомата, обновляя только изменившиеся клетки?». Получите идеи насчёт frontiers. Вы можете даже попросить конкретно: «Напиши C# код, который хранит список изменённых клеток и обновляет только их соседей» [defer]
- Решить: - Отладка: Если какая-то клетка ведёт себя странно (например, внезапно стала заражённой, хоть должна не сразу), можете описать ситуацию Codex: «У меня клеточный автомат, соседний алгоритм Moore. Заражённая клетка (5,5) за один шаг заразила (7,5), хотя между ними (6,5) не был заражён. Где искать ошибку?». Он может посоветовать проверить если вы не обновляете сетку по ходу (то есть укажет на double buffering) [defer]
- Решить: - Визуализация: Если вы затрудняетесь с UI, можете спросить: «Как сделать тепловую карту заражения на Unity Tilemap?». AI подскажет про Tilemap.color или про Texture2D, это может дать идеи  [chosen]
- Решить: - Jobs/ECS на будущее: Codex можно спросить: «Как перенести обновление 2D grid в Unity Job System?». Он может дать пример использования IJobParallelFor по массиву – сохраните эту идею для модуля 8  [chosen]
- Решить: - Первый тик – очаг заражает своих (на 5x5 много крайних случаев – возьмите очаг не на краю для чистоты). Должны заразиться (или повыситься уровень) у соседей. Проверьте консоль/визуализацию  [chosen]
- Решить: - Если сделали recovery, убедитесь, что через какое-то время рост замедляется и число заражённых стабилизируется или снижается [defer]
- Решить: - Проверка frontier оптимизации: Если включили, сравните скорость: [defer]

## Модуль 5: Событийная шина и команды, система строительства и сохранение игры
- Решить: - Subscribe(object handler): регистрация подписчика. Подписчиком может быть любой объект, имеющий методы-обработчики событий. Проще всего – пусть подписчик реализует интерфейсы для событий или просто имеет публичные методы On(EventType e)  [chosen]
- Решить: - Самый простой вариант (из документа) – использовать dynamic: foreach(var h in subs) (h as dynamic).On((dynamic)e). Это позволит вызывать метод On у подписчика, соответствующий типу события. Например, если e типа BuildOrder, а подписчик имеет On(BuildOrder order), то dynamic-система найдёт его  [chosen]
- Решить: - Например, public record BuildOrder(BuildingType Type, GridPos Position, Guid Who) – как в документе, где Who или какой-то идентификатор, кто заказал (может быть игрок или ИИ)  [chosen]
- Решить: - Определите enum BuildingType (например, Tower, Wall, Hospital… или просто для теста)  [chosen]
- Решить: - Если нельзя, возвращает какой-то результат (можно сделать BuildOrder со статусом Failed или null)  [chosen]
- Решить: - Если резерв успешно: вызывает whoPays.Commit(cost) сразу (или можно публиковать событие и в подписчике списывать, но проще здесь) [defer]
- Решить: - Подписчик события: решите, кто будет создавать сам объект игры (например, спрайт башни на карте). Логично, чтобы это сделал, например, класс BuildingManager или сам MapSystem. Сделайте простой MonoBehaviour BuildingPlacer который подпишется на BuildOrder. В нём метод On(BuildOrder order): там вы, например, можете нарисовать на Tilemap специальный тайл в этой клетке, или создать GameObject с соответствующим спрайтом. Пока можно просто логировать: Debug.Log($"Building placed: {order.Type} at {order.Position}") чтобы убедиться, что цепочка работает  [chosen]
- Решить: - Хранение занятости клетки: Вам понадобится понимать, занята ли клетка уже зданием, чтобы CanPlace работал. Можно завести в InfectionSystem или отдельном GridManager флаг для клетки hasBuilding. Поскольку у нас Tilemap, можно использовать Tilemap to check (но лучше свой массив bool parallel to infectionGrid). На начальном этапе, можно хранить простейший Set<GridPos> occupiedBuildings  [chosen]
- Решить: - Главное: убедитесь, что вы не сохраняете в середине обработки событий или середине тика, иначе состояние может быть неполным (например, деньги списаны, а здание ещё не создано, или infectionGrid обновлён, а события о вспышках не разосланы)  [chosen]
- Решить: - Добавьте проверку: если Save вызывается по событию (например, UI), то либо ставьте паузу перед вызовом, либо внутри SaveLoadService, если SimulationLoop.IsPaused == false, сначала сделайте SetPaused(true), потом Save, потом можно вернуть обратно (или требовать, чтобы игрок нажимал паузу)  [chosen]
- Решить: - Сделайте список или лог буфер для команд: например, List<object> commandLog в EventBus или GameManager, куда добавляете все опубликованные события-команды. Можно ограничивать длину, чтобы не рос бесконечно [defer]
- Решить: - Playback: Сохраняя командный лог, можно воспроизводить игру с начала для реплея или отладки. Это за рамками текущей задачи, просто знайте, что командный буфер такой опцией может стать  [chosen]
- Решить: - Subscribe(object handler) { subs.Add(handler); } – желательно проверять на дубли или отписку, но пока можно без [defer]
- Решить: - Вызывать EventBus.Flush() в конце каждого SimulationLoop.Update (после цикла while(acc>=tick) ) – мы уже вставили вызов в модуле 1, убедитесь, что так и осталось  [chosen]
- Решить: - Создайте класс (можно статический) BuildService с методом, или инстанс (если нужно хранить что-то, но вроде нет)  [chosen]
- Решить: - Сделайте enum BuildingType { Tower, ... } и struct/record GridPos(x,y) или просто используйте Vector2Int  [chosen]
- Решить: - Стоимость строительства: определите, откуда брать. Можно хранить в ScriptableObject (например, BuildingDef) – но вы еще не сделали BuildingDef. Для теста можно сделать в коде словарь cost: Tower -> 50, Wall -> 20. Или если в Data/Buildings/BuildingDef (SO) у вас есть, можно использовать: тогда BuildService надо знать BuildingDef по типу. Если вы сделали ScriptableObject BuildingDef with Id = "Tower" cost=50, то можно сделать Dictionary<string,BuildingDef> from module 2 load. Допустим, у BuildService есть доступ к GameDataLoader.buildingDefs or something. Но чтоб не сложно: можно захардкодить пару значений  [chosen]
- Решить: - Where to call BuildService.Place? – Это будет вызвано, например, из UI (когда игрок нажимает кнопку постройки и указывает куда) или из AI (когда AI решит строить). Пока у нас ни UI строительства, ни IИ команды. Для теста можем вызывать BuildService.Place прямо в коде (например, после 10 тиков автоматически, или по клавише). Можно, например, сделать: на клавишу "B" строить Tower в случайной клетке (or fixed cell)  [chosen]
- Решить: - Подписка/Отписка: Если у вас есть перезагрузка сцены, EventBus.subs остается статическим. Тогда старые подписчики могут накопиться. Простое решение: при стартовой инициализации (например, в GameManager.Awake) вызовите EventBus.subs.Clear(). Или, лучше, не делать EventBus static global across play sessions – but likely it is static for whole runtime. Just be cautious if writing Editor tests etc., clear between runs  [chosen]
- Решить: - Event order: If you publish events from within events (not our case yet, but imagine On(BuildOrder) publishes another event), note that flush processes queue fully. So if On(BuildOrder) publishes, that new event will be queued and processed in the same flush after current loop or next loop? Actually, our implementation: while(q.Count>0) so if On publishes, that event goes to queue, and current while will catch it and process it in the same tick flush. That's fine usually. But if you want to delay to next tick, you'd have to design differently  [chosen]
- Решить: - Coalescing events: If you did implement something like grouping infection events, test it: are multiple similar events combined as intended? If yes, ensure flush still picks them up properly  [chosen]
- Решить: - If something goes wrong (e.g., building not appearing but money gone), check logs: Did BuildOrder event publish? Did flush run? Did On(BuildOrder) get called? Perhaps a typo in method signature (On(BuildOrder order) must match exactly the event type)  [chosen]
- Решить: - Dynamic dispatch issues: If On signature mismatches (like parameter type not exactly the class, maybe you used struct vs class?), dynamic might not find method. E.g., if BuildOrder is record (class by default) and you pass record instance, it should match On(BuildOrder)  [chosen]
- Решить: - EventBus not flushed: ensure SimulationLoop calls Flush at end even if game paused? Actually, if paused, flush won't be called (because in Update we return early). If the game is paused, might want flush events from before pausing. But likely you'd pause after flush anyway. It's a corner case: if an event triggered exactly at pause, might remain queued. Could handle in SetPaused(true): flush events first [defer]
- Решить: - Использование dynamic: Если не уверены, спросите: «Как с помощью dynamic вызвать метод подписчика с подходящей сигнатурой?». Codex может объяснить или показать пример [defer]
- Решить: - Взаимодействие с экономикой: Если сомневаетесь, правильно ли списываете деньги, спросите: «Как связать систему экономики и команду строительства в Unity?». Может подсказать, что вы уже сделали  [chosen]
- Решить: - Debugging: При сложных связях, можно описать Codex проблему: «Опубликовал событие, но подписчик не получает. Что проверить?». Он может подсказать проверить подписку, flush, method signature [defer]
- Решить: - Сохранение: «Как убедиться, что сохранение игры происходит после всех действий кадра?». Может предложить некоторые Unity patterns (like LateUpdate, etc., хотя EventBus flush already a kind of late update)  [chosen]
- Решить: - Такого плана. Если flush count != events processed count, может значит, coalescing? But ideally one line per event from flush or subscriber [defer]

## Модуль 6: Система ИИ (стратегический и тактический интеллект)
- Решить: - Научиться соединять эти три подхода: Utility выбирает цель -> GOAP выдает план -> BT и/или скрипты выполняют конкретные шаги, плюс BT работает постоянно для реакции на окружение  [chosen]
- Решить: - Примеры: ContainOutbreak (сдержать заражение в очаге), FortifyChokepoint (укрепить узкий проход/границу), ResearchVaccine (исследовать технологию лечения), SupportPlayer (помочь игроку ресурсами или юнитами)  [chosen]
- Решить: - ContainOutbreak: например, берём максимальный уровень заражения среди всех регионов или количество заражённых клеток. Нормируем: 0 – нет инфекции, 1 – инфекция вышла из-под контроля. Можно: score = clamp((infectedCellsCount - threshold) / (maxCells - threshold), 0,1). Или проще: score = infectedCellsCount / totalCells (доля карты заражена) [defer]
- Решить: - FortifyChokepoint: надо определить, есть ли "горлышки" (chokepoints). Можно грубо: если заражение близко к базе или к важной точке (например, столице) и там мало обороны. Определите условно, что если какой-то регион со стратегическим значением и он под угрозой, score высокий. Или просто наличие незакрытых проходов на границе безопасной зоны  [chosen]
- Решить: - SupportPlayer: если у игрока мало денег или ситуация у игрока плохая (например, потерял много строений), гос-ИИ может помочь. Пока сложно симулировать, но можно: если playerEconomy balance << stateEconomy balance, то score для поддержки  [chosen]
- Решить: - enemyPressure – например, уровень инфекции или врагов в данной точке (можно взять infectionGrid normalized) [defer]
- Решить: - friendlyStrength – число оборонительных сооружений или юнитов (пока, скажем, 1 для каждой башни)  [chosen]
- Решить: - Для каждой цели вычисляет score = consideration.Score(worldState). Логирует эти значения (табличкой или JSON)  [chosen]
- Решить: - Выбирает цель с максимальным скором. Если она уже текущая цель и план по ней выполняется – можно оставаться. Если другая стала значительно выше – можно переключить цель (завершив предыдущую или прервав, в реальности) [defer]
- Решить: - Реализуйте интерфейс IAction с методами: Preconditions(IWorldState), Execute() (или Apply) и Cost()  [chosen]
- Решить: - Execute: собственно, делает действие (в нашем случае, может быть: вызывает BuildService.PlaceTower на конкретной клетке, или просто publishes Event "DeployUnits")  [chosen]
- Решить: - Cost: для планирования, можно возвращать ресурсную стоимость, или время. GOAP планер обычно ищет минимальный cost план. У нас небольшие деревья, можно не заморачиваться, просто возвращать, например, 1 для кажд. действия, или actual money cost  [chosen]
- Решить: - Завести, например, переменную currentActionIndex. Каждые N тиков (или каждый тик) проверять: если текущий план не пуст:  [chosen]
- Решить: - После выполнения последнего действия, цель считается достигнутой или цикл заново оценит Utility и выберет новую [defer]
- Решить: - Например, AllocateBudget – может просто log, т.к. у нас нет детализации бюджета по статьям (или можно уменьшить playerEconomy, но зачем). Можно skip actual effect, или simulate by storing a variable "defenseBudget += X"  [chosen]
- Решить: - Behavior Trees – тактическая логика. Если у нас будут юниты (в RTS обычно есть), Behavior Tree управляет их действиями. Пока у нас нет реализованных юнитов, но можем смоделировать на примере ремонта башен или патруля:  [chosen]
- Решить: - Допустим, у игрока/ИИ есть рабочий или солдат (представим один объект). Он может: патрулировать, чинить постройки, реагировать на угрозу  [chosen]
- Решить: - Иначе, если есть повреждённое здание (для примера, представим, что заражение может "повреждать" постройки, или просто случайно сделаем здание нуждающимся в ремонте): тогда юнит идёт туда и "чинит"  [chosen]
- Решить: - Иначе – патрулирует (можно лог или перемещать по маршруту) [defer]
- Решить: - See results: Are towers placed where needed? Are finances adjusting? [defer]
- Решить: - Implement Score: you have worldState accessible. For ContainOutbreak: maybe float infectedRatio = worldState.TotalInfected() / worldState.TotalCells(); return Mathf.Clamp01((infectedRatio - 0.1f)/0.5f); as an example. Or simpler: return worldState.TotalInfected() > someThreshold ? 1 : worldState.TotalInfected()/threshold; [defer]
- Решить: - If precond fails (maybe world changed so plan invalid?), could replan or skip. For simplicity, re-check preconditions rarely fails since we planned on current world state. We might ignore this scenario or just replan entire goal if fails  [chosen]
- Решить: - We could incorporate an effect: if tower present at a cell, maybe infection doesn't spread beyond? If so, that's actual containment. But we didn't implement infection effect of fortifications. We could:  [chosen]
- Решить: - If always one goal is maxed, others never chosen (which might be fine if outbreak persists). But test scenario with no infection: do we then see research or support become top? If no infection, containOutbreak score should be 0, others might have some baseline  [chosen]
- Решить: - Ask for advice: «Examples of Utility AI considerations for RTS?». Possibly get ideas like "if enemy units > threshold then defense score high", etc. Adapt to infection context  [chosen]
- Решить: - «How to normalize values for Utility AI scoring?» might yield formulas or best practices (like using logistic curves, etc.). For now, linear clamp is fine  [chosen]

## Модуль 7: Поиск пути (Pathfinding) на карте
- Решить: - Интегрировать поиск пути в игру: уметь вызывать функцию pathfinding для перемещения юнита или рассчитывать расстояния; если есть время – использовать pathfinding в поведении ИИ (например, чтобы тактический ИИ мог двигаться к цели)  [chosen]
- Решить: - Освоить использование Codex для анализа сложного алгоритма: можно просить объяснить код A*, помочь оптимизировать его или найти ошибку (например, если путь странно прокладывается)  [chosen]
- Решить: - Если у вас уже есть Tilemap в Unity, можно использовать координаты тайлов. Заведите, например, двумерный массив bool walkable или подобную структуру, где true означает, что по клетке можно пройти, а false – препятствие  [chosen]
- Решить: - Заполните этот массив на старте: отметьте границы карты как непроходимые, клетки с зданиями (башнями, стенами) как непроходимые. Можно также решить, считать ли заражённые клетки препятствиями: реалистично юниты могут через них проходить, но с риском. Для начала пометьте инфекцию как проходимую, но можно задать ей повышенную стоимость (например, чтобы путь через заражение был менее желателен). В простейшем случае используем бинарную сетку (проходимо/нет); усложнить можно позже добавлением весов  [chosen]
- Решить: - Определитесь с соседством для движения: обычно 8-смежное (включая диагонали) на сетке. A* на 8-соседях должен учитывать, что движение по диагонали чуть дороже (длина √2 ≈ 1.414). Для упрощения можно разрешить только 4 направления (вверх/вниз/влево/вправо) – тогда движение по диагонали возможно лишь в два хода. Мы выберем 8-направлений, но с учётом стоимости: по горизонтали/вертикали – 1, по диагонали – √2 (можно хранить эти значения как 10 и 14, если работаем с целыми для эффективности)  [chosen]
- Решить: - Определите функцию эвристики для A*: обычно берут манхэттеновское расстояние (|dx|+|dy|) для 4-напр. движения или диагональную эвристику (которая учитывает и диагонали) для 8-направлений. Манхэттенская часто подходит и для 8 направлений, но слегка недооценивает путь; можно использовать h = 10 * max(|dx|, |dy|) если 10 — цена шага по горизонтали, тогда учитываем диагонали  [chosen]
- Решить: - Структуры данных: создайте класс/структуру Node с полями: координаты (x,y), gCost (стоимость от старта), hCost (эвристика до цели), fCost = g+h, а также ссылку parent (для восстановления маршрута). Также понадобится коллекция open set (например, List<Node> или лучше приоритетная очередь) и closed set (список или bool-массив отмечающий закрытые клетки)  [chosen]
- Решить: - Взять узел с наименьшим fCost (и hCost при равенстве) из open set (вручную найти или использовать приоритетную очередь) [defer]
- Решить: - Если сосед вне границ или !walkable, пропустить [defer]
- Решить: - Вычислить предполагаемую новую gCost = current.gCost + стоимость шага (10 или 14) [defer]
- Решить: - Если сосед не в open set, или новая gCost меньше старой (нашли более короткий путь к соседу):  [chosen]
- Решить: - Восстановление пути: когда достигли цели, пройдите от целевого Node по parent-ссылкам до стартового, собирая координаты. Затем инвертируйте список или добавляйте в обратном порядке – это и будет путь от старта к цели  [chosen]
- Решить: - Логируйте некоторые моменты, если трудно: например, выводите координаты узла, извлекаемого из open set, его fCost, или количество узлов проверенных. Чтобы не залить консоль, можно ограничиться отдельными тестами [defer]
- Решить: - Open set: текущие пограничные клетки, которые алгоритм рассматривает – отметьте синими или зелёными квадратиками  [chosen]
- Решить: - Финальный путь: после поиска, сохраните путь и нарисуйте его – например, используя UnityEngine.LineRenderer для линии или Gizmos.DrawLine между последовательными точками  [chosen]
- Решить: - Визуализация путей мгновенно выявляет ошибки. Например, вы увидите, если алгоритм лезет сквозь стену (значит, где-то walkable неправильно), или если open/closed распространяются странно. Tip: хороший признак правильной работы A* – фронт волны (open set) распространяется примерно кругом от старта, а закрытые тянутся «пучком» вдоль найденного оптимального пути  [chosen]
- Решить: - Прямой путь: старт и финиш без препятствий. Проверьте, что A* возвращает прямую (диагональную или прямую) в зависимости от расположения  [chosen]
- Решить: - Тупик: если цель окружена непроходимыми клетками, алгоритм должен вернуться с пустым путём (или null). Проверьте, что не происходит бесконечного цикла, open set станет пустым и вы обработаете это (например, возвращая пустой список)  [chosen]
- Решить: - Проходимость заражения: если вы делали заражённые клетки проходимыми, можно вручную сравнить путь, проходящий через заражённую зону vs обход. Если желаете, попробуйте задать “стоимость” заражённой клетки выше: например, добавляйте +20 к gCost при входе в инфицированную клетку. Тогда A* будет обходить заражение, если путь сильно удлиняется – полезно для AI, чтобы они обходили опасные зоны. Протестируйте: цель внутри заражённой области – алгоритм пойдёт напрямую (придётся зайти в “красную” зону, иначе не достигнуть), а если цель за заражённой зоной, может обходить вокруг  [chosen]
- Решить: - Проверка JPS: убедитесь, что JPS всегда находит путь той же длины, что и обычный A*, только быстрее. Сравните длины или набор шагов на нескольких примерах – они должны совпадать. Если где-то JPS даёт иной (больший) путь, значит, ошибка в логике “прыжков” или пропущена “forced neighbor”  [chosen]
- Решить: - На небольшой карте разница может быть едва заметна по времени, но на большой открытой – JPS должен рассматривать на порядки меньше узлов (например, вместо тысячи – десятки). В профайлере или засечкой времени (Stopwatch) сравните время выполнения A* vs JPS на большой пустой карте: JPS будет быстрее  [chosen]
- Решить: - HPA требует приличного кодирования (генерация порталов, сохранение промежуточных путей). Полной реализации в рамках квартала, возможно, не потребуется. Но знайте: этот метод даёт резкий* прирост производительности на больших мирах, особенно если структура карт изменяется нечасто (потому что можно кешировать пути между порталами)  [chosen]
- Решить: - Вы можете не кодировать HPA, но изложите на бумаге/в комментариях, как разбили бы карту и сколько узлов графа получили. Это поможет оценить выигрыш: например, карта 1000x1000 (1,000,000 клеток) разбита на регионы 20x20 = 2500 регионов; поиск на графе из 2500 узлов + локальные A внутри пары десятков регионов вместо поиска по миллиону узлов [defer]
- Решить: - Отмечайте, если цель или окружение изменились в процессе (например, путь стал недействительным из-за нового препятствия) – тогда проложите путь заново  [chosen]
- Решить: - AI принятие решений: AI может использовать длину пути как фактор. Например, при оценке Utility “поддержать игрока”, можно учесть расстояние между их базами (через pathfinding) – если слишком далеко, приоритет ниже. Или при планировании GOAP: если действие “отправить отряд в точку X” – вы можете заранее оценить время по длине пути  [chosen]
- Решить: - Нарисованные open/closed узлы должны логически располагаться: closed образуют область от старта до цели по оптимальному пути, open – в основном по периметру этой области (волна). Если видите closed далеко в сторону, не имея отношения к кратчайшему пути, возможно, эвристика неадекватна (не информативна) или есть ошибка, что узлы не исключаются должным образом  [chosen]
- Решить: - Финальный путь – отрисуйте и проверьте, что он действительно самый короткий (можно прикинуть глазом или сравнить с альтернативными маршрутами)  [chosen]
- Решить: - JPS тесты: Обязательно сравните длины путей A и JPS на нескольких случаях. Они должны совпадать до клетки. Если нет – JPS упускает какой-то узел. Логируйте «forced neighbors» и сравните с теоретическим ожиданием: JPS должен останавливать прыжок, когда появляется препятствие по стороне движения или по диагонали (которое в обычном A породило бы альтернативный обход). Отладка JPS может быть нетривиальна, тут поможет внимательное чтение статьи/псевдокода и поэтапный вывод [defer]
- Решить: - HPA* обоснование: Если не реализовали HPA, ничего страшного. Но можно провести мысленный эксперимент: возьмите большую карту и прикиньте, через какие регионы пойдёт путь. Нарисуйте схему на бумаге, выделите порталы. Если видите, что путь пересекает много однотипных открытых клеток – ясно, что A тратит время на них, а HPA перепрыгнул бы регион целиком. Само это понимание помогает проектировать уровни (например, можно заранее планировать “узкие места” – тогда и без HPA AI решения принимает быстрее, потому что вариантов меньше)  [chosen]
- Решить: - Производительность: Pathfinding – одна из самых тяжёлых подсистем, особенно когда юнитов или запросов много. Поэтому:  [chosen]
- Решить: - Если у вас 100 юнитов, не запускайте всем путь в один кадр – распределите или делайте более грубые цели (неперекалиброванный AI, дергающий pathfinding каждый тик, может съесть всю CPU)  [chosen]
- Решить: - Profiler: используйте профиль Unity – запустите сценарий с множеством запросов, посмотрите время функции pathfinding. Оптимизируйте: например, убедитесь, что не создаёте лишних объектов (Node) на каждую клетку – можно переиспользовать или хранить в массиве, сбрасывая значения. Сборщик мусора (GC) не должен работать на каждое построение пути  [chosen]
- Решить: - Отладка эвристики: Heuristic должна не переоценивать реальный путь, иначе A* теряет оптимальность. Если вдруг вы сделали эвристику, которая иногда больше фактического расстояния – алгоритм мог пропустить оптимальный путь. Обычно манхэттен или диагональная не переоценивают, они допустимы. Если сомневаетесь, тестируйте: любой найденный путь должен иметь длина ≤ h(start); если нашли случай, где найденный путь длиннее эвристики от старта – проблема  [chosen]
- Решить: - Ошибки с диагоналями через углы: разрешаете ли движение по диагонали между двумя препятствиями по углам “уголком”? Классически, если оба смежных по горизонтали и вертикали клетки от текущей – непреодолимы, то диагональ тоже должна быть запрещена (чтобы не “просачиваться сквозь угол”). Добавьте эту проверку: перед добавлением диагонального соседа убедитесь, что оба соседних прямых клетки свободны  [chosen]
- Решить: - Не забывайте закрывать узлы: если забыть помещать обработанный узел в closed, алгоритм может зациклиться или повторно его рассматривать. В итоге или зависание, или не оптимально  [chosen]
- Решить: - «Почему алгоритм A не находит путь, хотя должен»* – предоставьте свой код, AI может найти упущенное условие или баг  [chosen]
- Решить: - «Как улучшить производительность поиска пути» – может напомнить об асинхронности, кешировании, что мы уже обсудили [defer]

## Модуль 8: Оптимизация производительности и масштабирование
- Решить: - Научиться профилировать память: отслеживать утечки (например, неосвобождённые NativeArray), контролировать использование Addressables (правильно ли выгружаются ассеты, нет ли дублирования в памяти)  [chosen]
- Решить: - Научиться эффективно использовать Codex для оптимизационных подсказок: просить проверить, где узкое место, или переписать метод с учетом многопоточности [defer]
- Решить: - Профилирование базовой игры. Прежде чем что-либо оптимизировать, измерьте:  [chosen]
- Решить: - Вкладку CPU Usage: какие методы/frame пожирают больше всего времени. Например, может оказаться, что InfectionSystem.Tick занимает 40% кадра (потому что там двойной цикл по большой сетке), или Pathfinding.FindPath скачет при вызове и отъедает 10 мс. Выпишите топ-3 самых тяжёлых места  [chosen]
- Решить: - GC Alloc: посмотрите, генерируется ли сборка мусора каждый кадр (желтые всплески). Если да – выясните, что создаётся. Часто причины: создание новых объектов/коллекций каждый Update. Например, if FindPath создает много new Node, их потом собирает GC. Или EventBus генерирует что-то. Зафиксируйте объем (в байтах). Задача – минимизировать частые аллокации, чтобы GC не мешал (идеально 0B per frame в стабильном состоянии)  [chosen]
- Решить: - Timeline: переключитесь в режим Timeline, рассмотрите кадр. Видно ли, что какие-то системы можно выполнять параллельно (например, Infection и AI могли бы идти вразнобой)? Unity по умолчанию выполняет весь ваш код в одном потоке (Main Thread). Нам нужно выявить, какие куски можно вынести в job’ы  [chosen]
- Решить: - Результат этого шага – понимание: что тормозит прямо сейчас? Например: “Система инфекции – 5 мс, Behaviour Tree – 2 мс, Pathfinding (при запросе) – 3 мс, отрисовка – 4 мс, GCAlloc – 0.5 KB/frame”. С такими данными можно решать, что оптимизировать  [chosen]
- Решить: - Вынос тяжёлых циклов в Jobs + Burst. На основе профайлера выберите самую затратную функцию – скорее всего, обновление инфекции (двойной цикл по всей сетке) или массовое вычисление influence-карт, или обработка сотен агентов. Попробуем оптимизировать на примере InfectionSystem:  [chosen]
- Решить: - Подготовка данных: переводим нужные структуры в формат, пригодный для job. Например, у нас CellInfection grid. В Unity Jobs нельзя directly использовать многомерный массив или List, но можно NativeArray<CellInfection> одномерный. Представим сетку как одномерный массив длины widthheight (с индексом idx = ywidth + x). Создайте NativeArray<CellInfection> gridNative и скопируйте данные туда. Либо создайте отдельный NativeArray<float> infectionLevels и NativeArray<int> infectionStates (если struct сложен)  [chosen]
- Решить: - Определение Job: Напишите struct InfectionJob : IJobParallelFor (если хотите параллельно по индексу) или IJob (если будете внутри делать свой параллелизм). Например: [defer]
- Решить: - Внутри Execute нельзя обращаться к обычным полям/свойствам Unity или к managed-объектам. Поэтому все данные надо передать как простые значения или NativeArray. Также нельзя использовать List или Dictionary. Поэтому, если вам нужны, скажем, массив соседних индексов – можете вычислять на лету или заранее передать массив смещений соседей  [chosen]
- Решить: - BurstCompile: Атрибут перед классом job – заставит компилировать его в высокопроизводительный код, но есть ограничения: нельзя выводить в лог внутри bursted job (Debug.Log не поддерживается), нельзя использовать managed memory [defer]
- Решить: - Перед циклом while или где удобно, можно заполнить gridNative текущими данными. (Если gridNative у вас Persistent, вы можете его обновлять в OnEnable, а потом только перезаписывать изменённые значения) [defer]
- Решить: - После Complete(), данные в gridNextNative заполнены. Скопируйте их обратно в обычную структуру (или, если вы полностью переходите на NativeArray как основное хранилище, можно хранить так). Например, можно иметь float infectionLevel для UI или отладки, или сразу перебирать NativeArray при визуализации  [chosen]
- Решить: - В конце, не забудьте: если NativeArray создан с Allocator.TempJob или Allocator.Persistent, нужно его .Dispose() когда он не нужен. Хорошо, если gridNative вы сделали полем и держите постоянно (Allocator.Persistent) – тогда нет аллокации каждый кадр, и Dispose сделаете в OnDestroy  [chosen]
- Решить: - Если все ок, вы можете удалить старый код или оставить комментированным [defer]
- Решить: - Забыли Complete() – тогда игра пойдёт дальше, и вы начнёте использовать gridNextNative до того, как job завершился, что плохо (может быть исключение или неправильные данные). Можно вместо ручного Complete использовать механизм JobHandle: например, цепочку job’ов илиDependency injection, но это сложно – пока просто Complete [defer]
- Решить: - Неправильный Allocator: TempJob нужно освобождать через .Dispose() вручную или он автоматически освободится через короткое время, но лучше явно  [chosen]
- Решить: - Race conditions: если бы у нас, например, два job – нужно учитывать, не конфликтуют ли они. В Unity Jobs, если один job пишет, а другой читает один массив – надо указывать job.WithReadOnly(array) или разделять на Write/ReadDependency, но в простейшем случае, когда job один, это не нужно  [chosen]
- Решить: - Debugging: Вы не можете просто Debug.Log внутри job (под Burst он игнорируется). В Unity Burst компиляторе есть опция Native Debug Mode, её можно включить в Burst меню – тогда job выполняется без оптимизаций, и можно хотя бы try-catch. Однако, чаще проще отлаживать job, запустив его без Burst (временно убрать ) – тогда можно даже Debug.Log (медленно, но для теста) или attach-дебагер. После отладки вернуть   [chosen]
- Решить: - Pathfinding: можно выполнение одного поиска пути сделать job’ом, но больше выигрыш, если вы запускаете сразу пачку поисков. Например, 10 запросов – можно запустить 10 job’ов параллельно (или 1 IJobParallelFor, который в Execute(index) запускает маленький поиск на подкарте – но pathfinding не тривиально параллелится на уровне одного запроса). Unity предлагает NavMesh за нас, но если пишете свой – держите в голове  [chosen]
- Решить: - Массовая физика или столкновения: у нас нет явно, но если бы были сотни пуль – их обновление/проверка столкновений – кандидат для jobs [defer]
- Решить: - Мы пометили – значит, система будет работать с фиксированным шагом (например, 10 тиков/сек), аналогично нашему SimulationLoop. Unity сама позаботится, чтобы вызывался нужный Group с заданной периодичностью (можно настроить)  [chosen]
- Решить: - Здесь Entities.ForEach – уже распараллеливает по сущностям. С Burst по умолчанию. Очень удобно, если работа локальная, но у нас проблема – нужно учитывать соседей. Как в ECS узнать соседние клетки?  [chosen]
- Решить: - Выигрыш ECS: В чём же профит? ECS + Jobs + Burst дает то же, что мы сделали вручную: параллельный код на C, но упакованный удобно. Преимущество в том, что Entities могут динамически создаваться, и ECS позаботится, чтобы это происходило безопасно – через EntityCommandBuffer (ECB)  [chosen]
- Решить: - Вывод: Попробовав ECS, решите, нужно ли внедрять его во всё. Возможно, вы ограничитесь job-ами на критичных местах, не переписывая всё на ECS – это нормально для малого проекта. Помните: “сначала сделать, чтобы работало; потом – оптимизировать”. У вас уже есть рабочие MonoBehaviour-системы, и вы точечно их ускоряете job’ами. Переписывать всё на ECS имеет смысл, если планируется действительно массовая масштабируемость (например, тысячи юнитов) или если вы изначально хотели освоить DOTS как цель  [chosen]
- Решить: - Объединение отрисовки: Проверьте настройки Tilemap. Если у вас несколько Tilemap-слоёв, старайтесь, чтобы большинство были в режиме Chunk – тогда Unity рисует их по блокам и меньше вызовов. Если есть особые слои (где нужны индивидуальные спрайты между, как указано в документе), используйте Sprite Atlas для них, чтобы Unity мог батчить и их. Откройте Frame Debugger: он покажет, где батчинг прерывается (например, разные материалы – значит, атлас не используется, или разные слои – не избежать)  [chosen]
- Решить: - Object Pooling: Если у вас появляются объекты во время игры (например, вы планировали снаряды, визуальные эффекты или даже те же башни строятся и уничтожаются часто), вместо Instantiate/Destroy каждый раз – сделайте пул: [defer]
- Решить: - В вашем проекте, пул могли бы требовать разве что визуальные части (например, мигающие индикаторы, если бы вы ими спамили). Но знать стоит, т.к. RTS могут иметь эффекты (взрывы, пули)  [chosen]
- Решить: - Загруженное -> освобожденное: каждая пара Addressables.LoadAsync -> Addressables.Release, чтобы не копились невидимые объекты в памяти  [chosen]
- Решить: - Проверьте Memory Profiler (есть отдельный пакет) или хотя бы профайлер вкладку Memory: посмотрите, нет ли всплеска памяти после, например, сцены загрузки/выгрузки. Addressables часто ловят на том, что загрузили, а Release забыли – тогда на каждый повтор загрузка дублируется в памяти  [chosen]
- Решить: - Расчёты AI: Если у вас сложный Utility или планер, убедитесь, что он не срабатывает слишком часто:  [chosen]
- Решить: - Кэширование результатов: Если один и тот же расчет повторяется с теми же входными данными – закэшируйте. Например, AI каждый тик запрашивает “сколько заражено клеток?” – посчитайте это в InfectionSystem один раз за тик и сохраните, а AI пусть берет готовое значение. Такие мелочи устраняют дублирование труда  [chosen]
- Решить: - Выключение неиспользуемого: Unity тратит время на каждый активный Update(). Если у вас есть объекты/скрипты, которые сейчас ничего не делают – выключайте их (enabled=false) или уничтожайте, чтобы не занимали цикл  [chosen]
- Решить: - Profiler Iteration: Повторяйте процесс профилирования на каждом шаге оптимизации: [defer]
- Решить: - Сравнивайте: снизилось ли время на функцию X? Переместилась ли нагрузка на Worker Threads? Нет ли новых подозрительных всплесков (например, After job – GCAlloc уменьшился, но вдруг где-то стало больше, значит, возможно, мы создаём NativeArray каждый кадр и не освобождаем)  [chosen]
- Решить: - GPU: Если были проблемы с количеством draw calls, после оптимизации Tilemap/атласа – стало ли меньше SetPass? Если да, FPS вырастет, если GPU была узким местом [defer]
- Решить: - Следите за Main Thread frame time – для 60 FPS он должен быть ~16 ms или ниже. Если у вас ранее было 30 ms, а после оптимизации стало 12 ms – цель достигнута [defer]
- Решить: - Burst не поддерживает обращение к классам/ссылкам – если очень надо, пометьте поле или – но лучше перепроектировать. Обычно, если нужно что-то сложное (например, поиск пути) – оставьте на Main Thread или делайте отдельной одиночной job, а не параллельно клеткам [defer]
- Решить: - «Как преобразовать этот метод в Job?» – можете показать Codex кусок кода, он подскажет, как вынести [defer]
- Решить: - «Почему Burst не работает с моим кодом?» – если получили ошибку компиляции, AI может подсказать, что не так (например, использован недопустимый тип)  [chosen]
- Решить: - «Как работает EntityCommandBuffer в Unity ECS?» – Codex может объяснить или дать шаблон, как правильно создавать сущности внутри системы  [chosen]
- Решить: - «Как правильно профилировать Unity игру» – AI может перечислить шаги, вдруг вы что-то забыли (например, отключить Deep Profile, если он не нужен, или включить Profile Editor)  [chosen]
- Решить: - «Какие ещё способы оптимизации RTS?» – AI может упомянуть, например, fixed-point math вместо float (редко нужно), или специализированные структуры. Это даст идеи на будущее  [chosen]
- Решить: - Используйте AI для ревью: пусть посмотрит ваш оптимизированный код – «Не пропустил ли я Dispose где-нибудь?» – он часто может заметить, например, отсутствие Dispose  [chosen]
- Решить: - AI-друг поможет и с Addressables: «Как выгрузить Addressable после использования?» – подскажет про Addressables.Release и тонкости  [chosen]

## Общие советы: эффективная работа с Codex и Visual Studio Code
- Решить: - Установка и настройка: Убедитесь, что расширение Codex (например, CodeGPT) установленно и авторизовано. Часто требуется ввести API-ключ OpenAI или залогиниться. В VS Code обычно появляется боковая панель чата или команды в Command Palette  [chosen]
- Решить: - Обращение к Codex через чат: В VS Code, скорее всего, есть команда открыть чат CodeGPT. Вы можете задавать вопросы на любом языке (AI понимает и русский, и английский; технические термины лучше оставлять по-английски, чтобы избежать недопонимания)  [chosen]
- Решить: - Контекст и файлы: Используйте возможность давать контекст. Например, расширение CodeGPT поддерживает упоминание файла или выделенного кода. Вы можете выделить фрагмент кода и вызвать команду Ask CodeGPT – AI увидит только этот фрагмент. Или в чате написать @MyClass.cs – тогда ассистент учтёт содержимое файла MyClass.cs. Это очень полезно, когда вопрос касается конкретного кода – не нужно копировать вручную  [chosen]
- Решить: - /Fix – автоматически найти и предложить исправление ошибок в выделенном коде. Если у вас ошибка компиляции или логическая, можно выделить проблемный метод и набрать /Fix: AI попытается переписать код правильно. Пример: вылетает NullReferenceException – AI может заметить, что забыли проверку на null или перепутали порядок инициализации  [chosen]
- Решить: - /Document – сгенерировать комментарии или описание для выделенного кода. Можно использовать, чтобы получить понятное объяснение функции. Это и для себя полезно (лучше поймёте, что написали), и для практики написания doc-комментариев  [chosen]
- Решить: - «Как мне оптимизировать обновление 1000 объектов в Unity?» – AI может предложить использовать Jobs или ECS, как мы обсуждали  [chosen]
- Решить: - «Почему метод X выдаёт ошибку Y?» – укажите конкретную ошибку/стек-трейс. Часто Codex сможет объяснить: например, NullReferenceException – подскажет, что возможно объект не присвоен в инспекторе или не инициализирован [defer]
- Решить: - «Не понимаю, как работает этот код» – выделите кусок кода, используйте /Document или спросите: «Расскажи пошагово, что делает этот метод». AI опишет своими словами. Это очень помогает, когда разбираетесь с чужим или старым кодом  [chosen]
- Решить: - «Приведи пример использования класса X из Unity API» – Codex может сгенерировать небольшой пример. Например: «Как использовать NavMeshAgent для перемещения?» – выдаст код с agent.SetDestination(). Проверяйте с документацией, но часто примеры корректны  [chosen]
- Решить: - Если у вас подключен GitHub Copilot или аналог авто-дополнения, он может дописывать строки, когда вы пишете комментарий или начало функции. Попробуйте: введите // функция, которая вычисляет фиксированный тик... (на русском Copilot тоже иногда реагирует) и несколько пустых строк – возможно, авто-дополнение предложит реализацию SimulationLoop. Такие инструменты работают на основе AI (Codex), только в инлайн-режиме  [chosen]
- Решить: - CodeGPT тоже может подсказывать, но чаще через чат. Вы можете сочетать: Copilot для автодополнения, CodeGPT для вопросов/отладки. Многие разработчики так и делают  [chosen]
- Решить: - Автопереформатирование: нажмите Shift+Alt+F (или Configure Format Document) – код выровняется по стилю. Если подключен .editorconfig или Unity C# Extension, будет по стандарту Unity. Красивый код легче читать (и AI тоже)  [chosen]
- Решить: - Поиск по проекту: Ctrl+Shift+F – найти все упоминания, например, "TODO". Вы так не забудете части кода, которые помечали для доработки  [chosen]
- Решить: - Unity-specific Snippets: Есть расширения, добавляющие сниппеты. Например, набираете for и два раза Tab – появляется шаблон цикла. Или prop – шаблон свойства. Используйте их, чтобы не писать шаблонный код вручную. AI тоже умеет делать сниппеты, но встроенные быстрее  [chosen]
- Решить: - Конкретизируйте запрос. Вместо: “помоги, не работает” – укажите, что ожидалось и что получилось. Например: “В функции InfectionSystem.Tick ожидал, что все Susceptible с уровнем >0.5 перейдут в Infected, но этого не происходит. Вот код... Что не так?” – такой подробный вопрос заставит AI анализировать именно вашу проблему  [chosen]
- Решить: - Проверьте несколько источников. Codex – не единственный ресурс. Изучайте официальную документацию Unity, блоги, форумы. AI иногда может ошибаться или устаревшую информацию дать (например, про старый API). Всегда сверяйте ответы с актуальной документацией  [chosen]
- Решить: - Вы пишете код SimulationLoop. Не уверены, правильно ли сделали паузу. Вы спрашиваете: “Как правильно реализовать паузу в Unity с фиксированным шагом симуляции?”. AI отвечает, упоминая Time.timeScale и свой loop. Вы сравниваете с вашим методом. Решаете, что ваш метод ок, но добавляете совет AI про Animator.updateMode = UnscaledTime для UI анимаций  [chosen]
- Решить: - Вы запускаете, но видите: при паузе один тик всё же проскакивает. Путём логов не можете найти причину. Вы копируете код Update и спрашиваете AI: “Почему при таком коде SimulationLoop может выполнить лишний тик при установке паузы?”. AI анализирует и подсказывает, что, возможно, acc не обнуляется правильно или pausing не мгновенно. Вы находите баг – например, нужно сбросить acc при паузе. Исправляете  [chosen]
- Решить: - Позже, вам нужно быстро добавить юнит-тесты для Economy. Вы пишете вручную пару, затем думаете – а все ли случаи покрыли? Пишете Codex: “Сгенерируй дополнительные unit-тесты на класс Economy (TryReserve/Commit)”. Он предлагает тест на отрицательные суммы, на последовательные транзакции. Вы некоторые берёте, некоторые адаптируете  [chosen]
- Решить: - Вы чувствовали, что не до конца понимаете GOAP. В свободное время спрашиваете: “Объясни принцип GOAP на простом примере”. AI рассказывает (или даже на C# пример). Вы лучше разбираетесь в теме, углубляете свой проект  [chosen]

## Цикл симуляции, пауза и фиксированный тик
- Решить: - Реализовать паузу: флаг IsPaused блокирует накопление времени – при паузе Delta = 0 и цикл тиков пропускается. Метод SimulationLoop.SetPaused(bool) управляет этим флагом внешне (через UI или горячую клавишу)  [chosen]
- Решить: - Добавить поддержку изменения скорости: 0.5× / 1× / 2× / 4×. Проще всего вводить множитель времени, влияющий на длительность tick или на скорость накопления. Например, для ускорения 2× можно временно уменьшить tick вдвое, чтобы цикл шел чаще (UI останется на unscaled-времени и продолжит работать нормально). Альтернативно – увеличивать acc быстрее  [chosen]
- Решить: - Добавить режим «шаг за шагом»: отдельная кнопка или клавиша, которая при паузе выполняет ровно один тик симуляции. Это можно сделать либо вызвав цикл while(acc>=tick) один раз принудительно, либо напрямую вызвав Tick() всех систем по очереди и сразу остановившись. Желательно защититься через Assert, чтобы за один шаг действительно произошел только один тик  [chosen]

## Экономика: двойная модель бюджета и ресурсы
- Решить: - Госбюджет (StateEconomy): формируется из налогов и базовых ресурсов. Тратится автоматически ИИ-государством по стратегическим приоритетам – оборона, карантинные мероприятия, базовые исследования и логистика. ИИ перераспределяет бюджет между этими направлениями на основе Utility AI (см. раздел AI) – то есть автоматически оценивает, куда вложения сейчас важнее всего. Например, при вспышке инфекции приоритет сместится на оборону и карантин. Гос-ИИ может также субсидировать игрока (например, в виде “контрактов” или целевых грантов)  [chosen]
- Решить: - Бюджет игрока (PlayerEconomy): это своего рода личный ВВП игрока. Игрок напрямую инвестирует эти средства в особые проекты – прорывные исследования, постройку фортификаций, поддержку операций ИИ. Игрок может брать краткосрочные займы под проценты, если не хватает средств. В геймдизайне это отражает волевые усилия игрока, которые выходят за рамки бюрократической машины государства  [chosen]

## Искусственный интеллект: стратегический и тактический (Utility AI, GOAP, BT)
- Решить: - Utility AI (утилитарный ИИ): быстрый слой оценки того, что сейчас наиболее важно. Реализуется набором функций-рассуждений (Considerations), каждая из которых возвращает рейтинг 0..1 для определенной цели. Например, одна функция оценивает срочность сдерживания очага инфекции – чем больше заражение на границе и меньше доступных ресурсов, тем выше приоритет удержать линию. Другая функция – важность закрыть узкое место (chokepoint) фортификацией, третья – вложиться в конкретное исследование вакцины, четвертая – поддержать действия игрока в горячей точке. Все оценки вычисляются на основе текущего мира (WorldState), который предоставляет необходимые метрики: уровень инфекции в точке, силы своих войск в регионе, наличие укреплений, узловые позиции и т.д.. Пример: Consideration HoldLine возвращает высокий score, если на клетке-форпосте близок прорыв инфекции. Utility AI регулярно (каждый N тиков) пересчитывает эти оценки и выбирает наиболее приоритетную цель для ИИ. Этот подход очень легковесен, объясним (можно вывести, почему ИИ выбрал именно эту цель) и хорошо подходит для верхнеуровневого управления  [chosen]
- Решить: - GOAP (Goal-Oriented Action Planning): когда цель выбрана, стратегический ИИ строит план из последовательности действий для ее достижения. Планировщик (Planner) берет набор возможных действий (Action) с пред- и постусловиями и ищет цепочку, ведущую к цели, похожим образом на планировщик STRIPS. Применение GOAP – на стратегическом уровне (“государственном” ИИ): например, цель “локализовать вспышку в регионе X” может выразиться планом: собрать ресурсы → исследовать технологию «Щит-I» (улучшение вакцины) → построить 3 турели на дуге вокруг региона X. Каждое действие (IAction) имеет проверку Preconditions(IWorldState) и эффект Apply(). Классический референс этой системы – AI игры F.E.A.R. (Jeff Orkin), где GOAP впервые успешно применили для динамического планирования поведения врагов. Для нашего ИИ планировщик будет ограничен несколькими типами действий: строительство определенного здания, начало исследования, переброска войск, введение карантина и т.д. – этого достаточно, чтобы формировать осмысленные последовательности. GOAP-план обновляется реже, чем Utility (например, при смене цели или раз в несколько секунд). Ограничиваем глубину и время поиска плана, чтобы не было просадки производительности, и кешируем уже найденные краткие планы (если ситуация мало изменилась)  [chosen]

## Pathfinding (пути юнитов) и карты пути
- Решить: - A: классический алгоритм поиска кратчайшего пути на grid-графе. Реализуем сначала его для корректности. В отладочном режиме делаем визуализацию: при запросе пути, рисуем на сцене* через Gizmos или LineRenderer открытые и закрытые узлы, а также итоговый путь. Это моментально выявит проблемы с эвристикой или проходимостью (можно увидеть, где поиск буксует). Также сравниваем длину пути с эталоном (например, с прямой дистанцией * стоимость шага) – для сетки без препятствий разница должна быть минимальна  [chosen]
- Решить: - Jump Point Search (JPS): оптимизация над A, сокращающая поиск за счет пропуска симметричных путей. На равномерной сетке JPS ускоряет A* в разы, зачастую на порядок. Он не требует предварительной подготовки данных и не расходует доп. память – алгоритм во время поиска “перепрыгивает” через последовательности тривиальных узлов. Мы интегрируем JPS в поиск: после отладки A включаем опцию JPS, убеждаемся, что найденные пути идентичны по длине (оптимальные) и что время поиска снизилось (например, логировать время или считать число рассмотренных узлов). Есть также улучшенная версия JPS+ (offline-оптимизации, как кэширование), но на первом этапе достаточно базового JPS. Согласно исследованиям, JPS может ускорить поиск более чем в 10 раз на больших сетках, и часто не уступает сложным иерархическим техникам  [chosen]

## Этапы разработки и контроль прогресса (3 месяца)
- Решить: - Реализовать сохранение/загрузку состояния игры в JSON (используя JsonUtility). Учесть ограничения: например, вместо Dictionary в моделях использовать списки или сериализуемые классы. Добавить поле версии в сохраняемые данные. Протестировать end-to-end: запустить игру, промотать несколько тиков, сохранить, загрузить – убедиться, что состояние идентично (балансы, статус клеток и т.д.). Этот тест можно автоматизировать (PlayMode тест: старт → несколько тиков → сейв → лоад → сравнение)  [chosen]
- Решить: - Добавить первые Utility-скоры (3–5 штук) для гос-ИИ: например, приоритет сдерживания инфекции, приоритет укрепления узкого прохода, приоритет инвестировать в конкретное исследование. Пока можно захардкодить их возвращающие рандом или по простым формулам, главное – интегрировать структуру Utility AI. Сделать простой стратегический тикер: отдельный MonoBehaviour или часть SimulationLoop, который раз в N тиков выводит в лог выбранную цель ИИ на основе Utility  [chosen]
- Решить: - Сформировать первую Influence Map – карта заражения: массив float по тайлам, где 0 = чисто, 1 = полностью заражено. Каждый тик обновлять ее на основе InfectionSystem (или даже внутри InfectionSystem). Визуализировать эту карту через UI оверлей (см. UI раздел) – цветом или интенсивностью. Добавить концепцию “линии фронта” – список клеток на границе заражения, и тоже отобразить (например, контуром)  [chosen]
- Решить: - Внедрить EventBus полностью и добавить обработку базовых команд: например, команду PlaceBuilding (строительство) и StartResearch (начать исследование). Пока реализации могут быть упрощенными (PlaceBuilding сразу строит без времени, Research сразу завершается), но структура событий должна заработать. Протестировать: при вызове команды через код или UI сообщение попадает в EventBus, исполняется сервисом и приводит к изменению состояния. Убедиться, что EventBus.Flush вызывается после тиков, как запланировано  [chosen]
- Решить: - Behavior Tree v1: разработать несколько узлов BT для тактических юнитов. Например, патруль по маршруту (циклическая последовательность точек), ремонт ближайшего строения, реагирование на врага (пока врагами может выступать инфекция как абстрактный враг). Построить небольшое дерево и навесить его на условный “инженерный юнит” или “солдата” для теста. Проверить, что BT корректно переключается между узлами (можно логировать активные ноды)  [chosen]
- Решить: - Pathfinding: интегрировать A для юнитов. Сделать класс PathfindingService, который по запросу выдает путь (список координат). Протестировать на примере: разместить юнит и цель, вызвать поиск – отобразить линию пути через LineRenderer в сцене. Затем включить оптимизацию JPS* для поиска на сетке. Убедиться, что путь не изменился (оптимальность сохранена), а скорость возросла (можно профилировать на длинных маршрутах). Включить поддержку пакетного поиска: например, несколько агентов запрашивают путь одновременно – продумать, как избежать подвисания (например, выполнять один путь за кадр, если нет срочности, или использовать Job на поиск)  [chosen]
- Решить: - Фортификации: добавить возможность строить фортификации. Например, в UI добавить кнопку “Построить окоп” – при выборе клетки создается постройка типа Fortification с временем строительства. Инженерные юниты (можно упростить – пусть строится само по себе за заданное время) через каждый тик уменьшают оставшиеся часы. По завершении – на клетке отмечается укрепление (можно поменять спрайт тайла или поставить объект). Интегрировать влияние на инфекцию: если клетка имеет фортификацию, снизить скорость заражения через нее. Добавить в EventBus событие FortificationBuilt для логов  [chosen]
- Решить: - Jobs + Burst: профилировать самые тяжелые места (вероятно InfectionSystem, InfluenceMap расчет). Вынести одну-две такие задачи в джобы с Burst. Например, сделать Job для обновления infection grid frontier параллельно. Сравнить время до/после в профайлере. Аналогично для influence map – IJobParallelFor пробегает по тайлам и суммирует влияния. Включить опцию Burst Debug (Native Debug Mode) и убедиться, что все джобы работают без ошибок  [chosen]
- Решить: - Адресация ассетов: если к этому моменту подключены реальные ассеты (спрайты большого размера и т.п.), перевести их загрузку на Addressables. Протестировать на слабых устройствах или в профайлере память: загружать сцену, потом выгружать – не осталось ли “висящих” объектов  [chosen]
- Решить: - CI/CD: настроить в репо действие CI: сборка проекта в headless и запуск тестов. Проверить, что при ошибке теста CI падает (чтобы не пропустить регресс). Также настроить nightly build на Unity Cloud Build или локальном CI – получить автономный build игры  [chosen]

## Архитектурные модули
- Решить: - Application (Приложение): Слой координации, связывает Domain, AI, инфраструктуру и презентацию. Здесь располагается EventBus (централизованная шина событий) для реагирования на игровые события асинхронно и декуплинга модулей (отделяет момент отправки события от момента обработки). Application реализует основной игровой цикл: фиксированный тик симуляции, последовательный вызов subsystems (например, Economy -> Infection -> AI -> и т.д.) и затем рассылку событий через EventBus (например, событие о постройке здания или заражении юнита). Также здесь находятся контроллеры случаев использования – например, сервис команд игрока: получение команды от UI, валидация и передача в Domain (паттерн Command). Пример: класс GameLoopController в каждом FixedUpdate вызывает SimulationTick(deltaTime), который обновляет экономику, инфекцию, AI и др., после чего вызывает eventBus.Flush() для обработки накопленных событий  [chosen]
- Решить: - Presentation (Презентация): Отвечает за визуализацию и ввод. Состоит из MonoBehaviour-скриптов на сцене, UI экранов и эффектов. Presentation проецирует состояние Domain на экран: спрайты юнитов, анимации, эффекты боя, интерфейс игрока. Вся логика Presentation пассивна: она подписывается на события EventBus или наблюдает за моделями Domain. Например, UnitView : MonoBehaviour слушает события о перемещении юнита или изменении здоровья и воспроизводит анимацию. UI включает экран экономики/отчёта (показывает баланс ресурсов и статистику производства), панели приказов логистики (переброска юнитов, ETA), постройки фортификаций и т.д. Input (команды игрока) через UI или клики по карте преобразуется в события или команды в Application. Presentation также отвечает за отображение “фронтовой карты” – стратегического обзора всего мира: показываются сектора, уровень заражения, принадлежность территорий, чтобы игрок видел общую ситуацию. Эта карта обновляется из агрегированных данных Domain по секторам (даже если они вне обзора), например, меняет цвет сектора при его захвате врагом вне поля зрения  [chosen]
- Решить: - Infrastructure (Инфраструктура): Низкоуровневые детали Unity и вспомогательные системы. Здесь – менеджеры сцены, загрузка данных, файловая система для сохранений, а также интеграция Unity Jobs/ECS для оптимизации. Например, тяжёлые циклы (расчёт pathfinding, массовый апдейт инфекций) выносятся в многопоточные Jobs с Burst-компиляцией для максимального использования 12 потоков CPU AMD Ryzen 9 5900X. Возможно использование Unity ECS (Entity Component System) для отдельных подсистем: например, массовое обновление позиций снарядов или агентов инфекции через ECS- системы с фиксированным шагом. Infrastructure предоставляет сервис Pathfinding: хранит данные сетки пути (grid-graph), кэширует поисковые структуры и может выполнять поиск маршрутов параллельно. Также инфраструктура отвечает за профилирование и сбор метрик – интеграция с Unity Profiler, сбор логов производительности, точек расширения для автотестов (например, режим детальной отладки, когда на N-м тике печатаются ключевые данные для сравнения с эталоном)  [chosen]


## Resolved This Iteration
- Input Handling: decided to support New Input System with legacy fallback via compile-time; recommended Active Input Handling = Both.
- Persistence scope (Sprint 1): Economy saved via JsonUtility; extended to units (positions + destinations). Further state (build/research) to be added in S2-07.
- UI prototype: HUD via IMGUI; clicks over HUD filtered from world input.
- Resolved: Research MVP — start/complete flow with cost; queued/done statuses; effects deferred.
